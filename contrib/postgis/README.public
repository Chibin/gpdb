=============================================================================
Portions of this file modified by EMC Corporation, 2011

The only modifications made to the open source code were minor bug fixes. 
This product may be distributed with open source code, licensed to you in 
accordance with the applicable open source license.  If you would like a copy 
of any such source code, EMC will provide a copy of the source code that is 
required to be made available in accordance with the applicable open source 
license.  EMC may charge reasonable shipping and handling charges for such 
distribution.  Please direct requests in writing to 
EMC Legal, 176 South St., Hopkinton, MA 01748, ATTN: Open Source Program Office.
=============================================================================

PostGIS - Geographic Information Systems Extensions to PostgreSQL
~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VERSION: 1.4.1 (2009/12/16)

MORE INFORMATION: http://postgis.refractions.net

GREENPLUM NOTES
---------------

* The estimated_extent functions will not work, because they rely on a 
Postgres model of statistics gathering that Greenplum does not support.

* The PostGIS long transaction support will not work, because it relies
on triggers, for which Greenplum has limited support.

CREATING NEW SPATIAL DATABASES
------------------------------

PostGIS support must be enabled for each database that requires
its usage. This is done by feeding the postgis.sql (the enabler script)
file to the target database. 

The enabler script requires the PL/pgSQL procedural language in order
to operate correctly, you can use the 'createlang' program from the
PostgreSQL installation.
(The PostgreSQL Programmer's Guide has details if you want to do this
manually for some reason.)

So, as postgres run:

  createlang plpgsql <yourdatabase>
  psql -f postgis/postgis.sql -d <your_database>

Your database should now be spatially enabled.

UPGRADING EXISTING SPATIAL DATABASES
------------------------------------

Upgrading existing spatial databases can be tricky as it requires
replacement or introduction of new PostGIS object definitions.

Unfortunately not all definitions can be easily replaced in 
a live database, so sometimes your best bet is a dump/reload
process. 

PostGIS provides a SOFT UPGRADE procedure for minor or bugfix
releases, and an HARD UPGRADE procedure for major releases.

--- SOFT UPGRADE ---

Soft upgrade consists of sourcing the postgis_upgrade_*.sql
script in your spatial database:

 * postgis_upgrade_12_to_14.sql, upgrade a 1.2.x database
   to 1.4
 * postgis_upgrade_13_to_14.sql, upgrade a 1.3.x database 
   to 1.4
 * postgis_upgrade_14_minor.sql, upgrade a 1.4.x database
   to the latest minor release

If a soft upgrade is not possible the script will abort and 
no harm will be done. You can then move on to the 
HARD UPGRADE process. Always try a soft upgrade first, they 
are much simpler.

--- HARD UPGRADE ---

Hard upgrade is a PostgreSQL dump/restore procedure combined 
with a filter to selectively update PostGIS functions and 
objects to point to a new library version.

Hard upgrades are required when object definitions have changed,
aggregates have changed or been added, and when the underlying
PostgreSQL database itself has undergone a major update.

For this purpose, PostGIS provides a utility script to restore a dump
in "custom" format. The hard upgrade procedure is as follows:

	# Create a "custom-format" dump of the database you want
	# to upgrade (let's call it "olddb")
	$ pg_dump -Fc olddb olddb.dump

	# Restore the dump while upgrading postgis into
	# a new database. 
        # Note: The new database does NOT have to exist.
	# Let's call it "newdb"
	$ sh utils/postgis_restore.pl postgis.sql newdb olddb.dump > restore.log

	# Check that all restored dump objects really had to be 
        # restored from dump and do not conflict with the 
        # ones defined in postgis.sql
	$ grep ^KEEPING restore.log | less

	# If upgrading from PostgreSQL < 8.0 to >= 8.0 you will want to 
	# drop the attrelid, varattnum and stats columns in the geometry_columns
	# table, which are no-more needed. Keeping them won't hurt.
	# !!! DROPPING THEM WHEN REALLY NEEDED WILL DO HARM !!!!
	$ psql newdb -c "ALTER TABLE geometry_columns DROP attrelid"
	$ psql newdb -c "ALTER TABLE geometry_columns DROP varattnum"
	$ psql newdb -c "ALTER TABLE geometry_columns DROP stats"

	# The spatial_ref_sys table is restored from the dump, to 
        # ensure your custom additions are kept, but the distributed 
        # one might contain modification so you should backup your 
        # entries, drop the table and source the new one.
	# If you did make additions we assume you know how to backup them before
	# upgrading the table. Replace it with the new like this:
	$ psql newdb
	newdb=> DELETE FROM spatial_ref_sys;
	DROP
	newdb=> \i spatial_ref_sys.sql


USAGE
-----

Try the following example SQL statements to create non-OpenGIS tables and 
geometries:

  CREATE TABLE geom_test ( gid int4, geom geometry,name varchar(25) );
  INSERT INTO geom_test ( gid, geom, name ) 
    VALUES ( 1, 'POLYGON((0 0 0,0 5 0,5 5 0,5 0 0,0 0 0))', '3D Square');
  INSERT INTO geom_test ( gid, geom, name ) 
    VALUES ( 2, 'LINESTRING(1 1 1,5 5 5,7 7 5)', '3D Line' );
  INSERT INTO geom_test ( gid, geom, name )
    VALUES ( 3, 'MULTIPOINT(3 4,8 9)', '2D Aggregate Point' );
  SELECT * from geom_test WHERE geom && 'BOX3D(2 2 0,3 3 0)'::box3d;

The following SQL creates proper OpenGIS entries in the SPATIAL_REF_SYS
and GEOMETRY_COLUMNS tables, and ensures that all geometries are created
with an SRID.

  INSERT INTO SPATIAL_REF_SYS
    ( SRID, AUTH_NAME, AUTH_SRID, SRTEXT ) VALUES
    ( 1, 'EPSG', 4269,
      'GEOGCS["NAD83",
        DATUM[
          "North_American_Datum_1983",
          SPHEROID[
          "GRS 1980",
          6378137,
          298.257222101
        ]
      ],
      PRIMEM["Greenwich",0],
      UNIT["degree",0.0174532925199433]]'
    );

  CREATE TABLE geotest (
    id INT4,
    name VARCHAR(32)
    );

  SELECT AddGeometryColumn('db','geotest','geopoint',1,'POINT',2);

  INSERT INTO geotest (id, name, geopoint)
    VALUES (1, 'Olympia', GeometryFromText('POINT(-122.90 46.97)',1));
  INSERT INTO geotest (id, name, geopoint)
    VALUES (2, 'Renton', GeometryFromText('POINT(-122.22 47.50)',1));

  SELECT name,AsText(geopoint) FROM geotest;


Spatial Indexes:

PostgreSQL provides support for GiST spatial indexing. The GiST scheme offers 
indexing even on large objects, using a system of "lossy" indexing where 
a large object is proxied by a smaller one in the index.  In the case 
of the PostGIS indexing system, all objects are proxied in the index by 
their bounding boxes.

You can build a GiST index with:

  CREATE INDEX <indexname> 
    ON <tablename> 
    USING GIST ( <geometryfield> );

Always run the "VACUUM ANALYZE <tablename>" on your tables after
creating an index. This gathers statistics which the query planner
uses to optimize index usage.

