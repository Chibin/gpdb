<?xml version="1.0" encoding="UTF-8"?>
<chapter>
  <title>PostGIS Reference</title>

  <para>The functions given below are the ones which a user of PostGIS is
  likely to need. There are other functions which are required support
  functions to the PostGIS objects which are not of use to a general
  user.</para>

  <note>
	<para>PostGIS has begun a transition from the existing naming convention
	to an SQL-MM-centric convention. As a result, most of the functions that
	you know and love have been renamed using the standard spatial type (ST)
	prefix. Previous functions are still available, though are not listed in
	this document where updated functions are equivalent. These will be
	deprecated in a future release.</para>
  </note>

  <sect1 id="Management_Functions">
	<title>Management Functions</title>

	<refentry id="AddGeometryColumn">
	  <refnamediv>
		<refname>AddGeometryColumn</refname>

		<refpurpose>Adds a geometry column to an existing table of
		attributes.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>AddGeometryColumn</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>type</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>dimension</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>AddGeometryColumn</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>type</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>dimension</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>AddGeometryColumn</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>catalog_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>type</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>dimension</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Adds a geometry column to an existing table of attributes. The
		<varname>schema_name</varname> is the name of the table schema (unused
		for pre-schema PostgreSQL installations). The <varname>srid</varname>
		must be an integer value reference to an entry in the SPATIAL_REF_SYS
		table. The <varname>type</varname> must be an uppercase string
		corresponding to the geometry type, eg, 'POLYGON' or
		'MULTILINESTRING'.  An error is thrown if the schemaname doesn't exist
		(or not visible in the current search_path) or the specified SRID,
		geometry type, or dimension is invalid.</para>

		<note>
			<para>Views and derivatively created spatial tables will need to be registered in geometry_columns manually,
				since AddGeometryColumn also adds a spatial column which is not needed when you already have a spatial column.  Refer to <xref linkend="Manual_Register_Spatial_Column"/>.
			</para>
		</note>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the
		  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		  Features Implementation Specification for SQL.</ulink>
		</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
		</inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>
-- Create a new simple PostgreSQL table
postgis=# CREATE TABLE my_schema.my_spatial_table (id serial);

-- Describing the table shows a simple table with a single "id" column.
postgis=# \d my_schema.my_spatial_table
							 Table "my_schema.my_spatial_table"
 Column |  Type   |                                Modifiers
--------+---------+-------------------------------------------------------------------------
 id     | integer | not null default nextval('my_schema.my_spatial_table_id_seq'::regclass)

-- Add a spatial column to the table
postgis=# SELECT AddGeometryColumn ('my_schema','my_spatial_table','the_geom',4326,'POINT',2);

--Add a curvepolygon
SELECT AddGeometryColumn ('my_schema','my_spatial_table','the_geomcp',4326,'CURVEPOLYGON',2);

-- Describe the table again reveals the addition of a new "the_geom" column.
postgis=# \d my_schema.my_spatial_table
   Column   |   Type   |                                Modifiers

------------+----------+-------------------------------------------------------------------------
 id         | integer  | not null default nextval('my_schema.my_spatial_table_id_seq'::regclass)
 the_geom   | geometry |
 the_geomcp | geometry |
Check constraints:
	"enforce_dims_the_geom" CHECK (ndims(the_geom) = 2)
	"enforce_dims_the_geomcp" CHECK (ndims(the_geomcp) = 2)
	"enforce_geotype_the_geom" CHECK (geometrytype(the_geom) = 'POINT'::text OR
the_geom IS NULL)
	"enforce_geotype_the_geomcp" CHECK (geometrytype(the_geomcp) = 'CURVEPOLYGON
'::text OR the_geomcp IS NULL)
	"enforce_srid_the_geom" CHECK (srid(the_geom) = 4326)
	"enforce_srid_the_geomcp" CHECK (srid(the_geomcp) = 4326)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="DropGeometryColumn"/>, <xref linkend="DropGeometryTable"/>, <xref linkend="Manual_Register_Spatial_Column"/></para>
	  </refsection>
	</refentry>

	<refentry id="DropGeometryColumn">
	  <refnamediv>
		<refname>DropGeometryColumn</refname>

		<refpurpose>Removes a geometry column from a spatial
		table.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>DropGeometryColumn</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>DropGeometryColumn</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>DropGeometryColumn</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>catalog_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Removes a geometry column from a spatial table. Note that
		schema_name will need to match the f_table_schema field of the table's
		row in the geometry_columns table.</para>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the
		  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		  Features Implementation Specification for SQL.</ulink>
		</para>
			<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This function supports 3d geometry fields.</para>
		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>
	  <refsection>
		<title>Examples</title>

		<programlisting>
			SELECT DropGeometryColumn ('my_schema','my_spatial_table','the_geomcp');
			----RESULT output ---
			my_schema.my_spatial_table.the_geomcp effectively removed.
		</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="AddGeometryColumn"/>, <xref linkend="DropGeometryTable"/></para>
	  </refsection>
	</refentry>

	<refentry id="DropGeometryTable">
	  <refnamediv>
		<refname>DropGeometryTable</refname>

		<refpurpose>Drops a table and all its references in
		geometry_columns.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>DropGeometryTable</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>boolean <function>DropGeometryTable</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>boolean <function>DropGeometryTable</function></funcdef>
			<paramdef><type>varchar </type>
			<parameter>catalog_name</parameter></paramdef>
			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>
			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Drops a table and all its references in geometry_columns. Note:
		uses current_schema() on schema-aware pgsql installations if schema is
		not provided.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>
			SELECT DropGeometryTable ('my_schema','my_spatial_table');
			----RESULT output ---
			my_schema.my_spatial_table dropped.
		</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="AddGeometryColumn"/>, <xref linkend="DropGeometryColumn"/></para>
	  </refsection>
	</refentry>


	<refentry id="PostGIS_Full_Version">
	  <refnamediv>
		<refname>PostGIS_Full_Version</refname>

		<refpurpose>Reports full postgis version and build configuration
		infos.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Full_Version</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Reports full postgis version and build configuration
		infos.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Full_Version();
							   postgis_full_version
----------------------------------------------------------------------------------
 POSTGIS="1.3.3" GEOS="3.1.0-CAPI-1.5.0" PROJ="Rel. 4.4.9, 29 Oct 2004" USE_STATS
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_GEOS_Version" />, <xref
		linkend="PostGIS_Lib_Version" />, <xref
		linkend="PostGIS_PROJ_Version" />, <xref
		linkend="PostGIS_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_GEOS_Version">
	  <refnamediv>
		<refname>PostGIS_GEOS_Version</refname>

		<refpurpose>Returns the version number of the GEOS
		library.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_GEOS_Version</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the version number of the GEOS library, or
		<varname>NULL</varname> if GEOS support is not enabled.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_GEOS_Version();
 postgis_geos_version
----------------------
 3.1.0-CAPI-1.5.0
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref
		linkend="PostGIS_Lib_Version" />, <xref
		linkend="PostGIS_PROJ_Version" />, <xref
		linkend="PostGIS_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_Lib_Build_Date">
	  <refnamediv>
		<refname>PostGIS_Lib_Build_Date</refname>

		<refpurpose>Returns build date of the PostGIS library.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Lib_Build_Date</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns build date of the PostGIS library.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Lib_Build_Date();
 postgis_lib_build_date
------------------------
 2008-06-21 17:53:21
(1 row)</programlisting>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_Lib_Version">
	  <refnamediv>
		<refname>PostGIS_Lib_Version</refname>

		<refpurpose>Returns the version number of the PostGIS
		library.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Lib_Version</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the version number of the PostGIS library.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Lib_Version();
 postgis_lib_version
---------------------
 1.3.3
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref
		linkend="PostGIS_GEOS_Version" />,  <xref
		linkend="PostGIS_PROJ_Version" />, <xref
		linkend="PostGIS_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_PROJ_Version">
	  <refnamediv>
		<refname>PostGIS_PROJ_Version</refname>

		<refpurpose>Returns the version number of the PROJ4
		library.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_PROJ_Version</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the version number of the PROJ4 library, or
		<varname>NULL</varname> if PROJ4 support is not enabled.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_PROJ_Version();
  postgis_proj_version
-------------------------
 Rel. 4.4.9, 29 Oct 2004
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref
		linkend="PostGIS_GEOS_Version" />,  <xref
		linkend="PostGIS_Lib_Version" />, <xref
		linkend="PostGIS_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_Scripts_Build_Date">
	  <refnamediv>
		<refname>PostGIS_Scripts_Build_Date</refname>

		<refpurpose>Returns build date of the PostGIS scripts.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Scripts_Build_Date</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns build date of the PostGIS scripts.</para>

		<para>Availability: 1.0.0RC1</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Scripts_Build_Date();
  postgis_scripts_build_date
-------------------------
 2007-08-18 09:09:26
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref
		linkend="PostGIS_GEOS_Version" />, <xref
		linkend="PostGIS_Lib_Version" />, <xref
		linkend="PostGIS_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_Scripts_Installed">
	  <refnamediv>
		<refname>PostGIS_Scripts_Installed</refname>

		<refpurpose>Returns version of the postgis scripts installed in this
			database.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Scripts_Installed</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns version of the postgis scripts installed in this
			database.</para>

		<note>
			  <para>If the output of this function doesn't match the output of
			  <xref linkend="PostGIS_Scripts_Released" />
			  you probably missed to properly upgrade an existing database.
			  See the <link linkend="upgrading">Upgrading</link> section for
			  more info.</para>
		</note>

		<para>Availability: 0.9.0</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Scripts_Installed();
  postgis_scripts_installed
-------------------------
 1.3.4SVN
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref linkend="PostGIS_Scripts_Released" />, <xref linkend="PostGIS_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_Scripts_Released">
	  <refnamediv>
		<refname>PostGIS_Scripts_Released</refname>

		<refpurpose>Returns the version number of the lwpostgis.sql script
		released with the installed postgis lib.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Scripts_Released</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the version number of the lwpostgis.sql script
		released with the installed postgis lib.</para>

		<note>
		  <para>Starting with version 1.1.0 this function returns the same
		  value of <xref linkend="PostGIS_Lib_Version" />. Kept
		  for backward compatibility.</para>
		</note>

		<para>Availability: 0.9.0</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Scripts_Released();
  postgis_scripts_released
-------------------------
 1.3.4SVN
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref linkend="PostGIS_Scripts_Installed" />, <xref linkend="PostGIS_Lib_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_Uses_Stats">
	  <refnamediv>
		<refname>PostGIS_Uses_Stats</refname>

		<refpurpose>Returns <varname>TRUE</varname> if STATS usage has been
		enabled.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Uses_Stats</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns <varname>TRUE</varname> if STATS usage has been enabled,
		<varname>FALSE</varname> otherwise.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Uses_Stats();
 postgis_uses_stats
--------------------
 t
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="PostGIS_Version">
	  <refnamediv>
		<refname>PostGIS_Version</refname>

		<refpurpose>Returns PostGIS version number and compile-time
		options.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>PostGIS_Version</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns PostGIS version number and compile-time options.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT PostGIS_Version();
			postgis_version
---------------------------------------
 1.3 USE_GEOS=1 USE_PROJ=1 USE_STATS=1
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref
		linkend="PostGIS_GEOS_Version" />,<xref
		linkend="PostGIS_Lib_Version" />, <xref
		linkend="PostGIS_PROJ_Version" /></para>
	  </refsection>
	</refentry>

	<refentry id="Populate_Geometry_Columns">
	  <refnamediv>
		<refname>Populate_Geometry_Columns</refname>

		<refpurpose>Ensures geometry columns have appropriate spatial constraints
		and exist in the <varname>geometry_columns</varname> table.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>Populate_Geometry_Columns</function></funcdef>

			<paramdef></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>int <function>Populate_Geometry_Columns</function></funcdef>

			<paramdef><type>oid</type> <parameter>relation_oid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Ensures geometry columns have appropriate spatial constraints and
		exist in the <varname>geometry_columns</varname> table.  In particular,
		this means that every geometry column belonging to a table has at least
		three constraints:</para>

		<itemizedlist>
		  <listitem>
			<para><varname>enforce_dims_the_geom</varname> - ensures every
			geometry has the same dimension (see <xref
			linkend="ST_NDims" />)</para>
		  </listitem>

		  <listitem>
			<para><varname>enforce_geotype_the_geom</varname> - ensures every
			geometry is of the same type (see <xref
			linkend="GeometryType" />)</para>
		  </listitem>

		  <listitem>
			<para><varname>enforce_srid_the_geom</varname> - ensures every
			geometry is in the same projection (see <xref
			linkend="ST_SRID" />)</para>
		  </listitem>
		</itemizedlist>

		<para>If a table <varname>oid</varname> is provided, this function
		tries to determine the srid, dimension, and geometry type of all
		geometry columns in the table, adding contraints as necessary. If
		successful, an appropriate row is inserted into the geometry_columns
		table, otherwise, the exception is caught and an error notice is raised
		describing the problem.</para>

		<para>If the <varname>oid</varname> of a view is provided, as with a
		table oid, this function tries to determine the srid, dimension, and
		type of all the geometries in the view, inserting appropriate entries
		into the <varname>geometry_columns</varname> table, but nothing is done
		to enforce contraints.</para>

		<para>The parameterless variant is a simple wrapper for the parameterized
		variant that first truncates and repopulates the geometry_columns table
		for every spatial table and view in the database, adding spatial
		contraints to tables where appropriate.  It returns a summary of the
		number of geometry columns detected in the database and the number that
		were inserted into the <varname>geometry_columns</varname> table.  The
		parameterized version simply returns the number of rows inserted into
		the <varname>geometry_columns</varname> table.</para>
		<para>Availability: 1.4.0</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT Populate_Geometry_Columns('public.myspatial_table'::regclass);</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="Probe_Geometry_Columns" /></para>
	  </refsection>
	</refentry>

	<refentry id="Probe_Geometry_Columns">
	  <refnamediv>
		<refname>Probe_Geometry_Columns</refname>

		<refpurpose>Scans all tables with PostGIS geometry constraints and adds them to the <varname>geometry_columns</varname>
			table if they are not there.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>Probe_Geometry_Columns</function></funcdef>
			<paramdef></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Scans all tables with PostGIS geometry constraints and adds them to the <varname>geometry_columns</varname>
			table if they are not there.  Also give stats on number of inserts and already present or possibly obsolete.</para>
		<note><para>This will usually only pick up records added by AddGeometryColumn() function.  It will not scan views so views
			will need to be manually added to geometry_columns table.</para></note>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT Probe_Geometry_Columns();
			probe_geometry_columns
---------------------------------------
probed:6 inserted:0 conflicts:6 stale:0
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="AddGeometryColumn" /></para>
	  </refsection>
	</refentry>


	<refentry id="UpdateGeometrySRID">
	  <refnamediv>
		<refname>UpdateGeometrySRID</refname>

		<refpurpose>Updates the SRID of all features in a geometry
		column, geometry_columns metadata and srid table constraint</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>UpdateGeometrySRID</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>UpdateGeometrySRID</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>UpdateGeometrySRID</function></funcdef>

			<paramdef><type>varchar </type>
			<parameter>catalog_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>schema_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>table_name</parameter></paramdef>

			<paramdef><type>varchar </type>
			<parameter>column_name</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Updates the SRID of all features in a geometry column, updating
		constraints and reference in geometry_columns. Note: uses
		current_schema() on schema-aware pgsql installations if schema is not
		provided.</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_SetSRID"/></para>
	  </refsection>
	</refentry>
  </sect1>

  <sect1 id="Geometry_Constructors">
	  <title>Geometry Constructors</title>
		<refentry id="ST_BdPolyFromText">
		  <refnamediv>
			<refname>ST_BdPolyFromText</refname>

			<refpurpose>Construct a Polygon given an arbitrary collection of closed
			linestrings as a MultiLineString Well-Known text representation.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_BdPolyFromText</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Construct a Polygon given an arbitrary collection of closed
			linestrings as a MultiLineString Well-Known text representation.</para>

			<!-- optionally mention that this function uses indexes if appropriate -->
			<note>
				<para>Throws an error if WKT is not a MULTILINESTRING. Throws an
			error if output is a MULTIPOLYGON; use ST_BdMPolyFromText in that case, or
			see ST_BuildArea() for a
			postgis-specific approach.</para>
			</note>

			<!-- Optionally mention OpenGIS compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL.</ulink> OGC SFSQL 1.1 - 3.2.6.2</para>

			 <para>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0.</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>Forthcoming</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_BuildArea" />, <xref linkend="ST_BdMPolyFromText" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_BdMPolyFromText">
			<refnamediv>
				<refname>ST_BdMPolyFromText</refname>
				<refpurpose>Construct a MultiPolygon given an arbitrary collection of
					closed linestrings as a MultiLineString text
					representation Well-Known text representation.</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<funcsynopsis>
				  <funcprototype>
					<funcdef>geometry <function>ST_BdMPolyFromText</function></funcdef>
					<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
					<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
				  </funcprototype>
				</funcsynopsis>
			</refsynopsisdiv>

			<refsection>
				<title>Description</title>

				<para>Construct a Polygon given an arbitrary collection of closed
				linestrings, polygons, MultiLineStrings as  Well-Known text representation.</para>

				<!-- optionally mention that this function uses indexes if appropriate -->
				<note>
					 <para>Throws an error if WKT is not a MULTILINESTRING. Forces
					MULTIPOLYGON output even when result is really only composed by a
					single POLYGON; use <link
					linkend="ST_BdPolyFromText">ST_BdPolyFromText</link> if you're sure a
					single POLYGON will result from operation, or see <link
					linkend="ST_BuildArea">ST_BuildArea()</link> for a postgis-specific
					approach.</para>
				</note>

				<!-- Optionally mention OpenGIS compliancy if appropriate -->
				<para><inlinemediaobject>
					<imageobject>
					  <imagedata fileref="images/check.png" />
					</imageobject>
				  </inlinemediaobject> This method implements the <ulink
				url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
				Implementation Specification for SQL.</ulink> OGC SFSQL 1.1 - 3.2.6.2</para>

				 <para>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0.</para>
			</refsection>

			<refsection>
				<title>Examples</title>

				<programlisting>Forthcoming</programlisting>
			</refsection>

			<refsection>
				<title>See Also</title>
				<para><xref linkend="ST_BuildArea" />, <xref linkend="ST_BdPolyFromText" /></para>
			</refsection>
	</refentry>


	<refentry id="ST_GeomCollFromText">
	  <refnamediv>
		<refname>ST_GeomCollFromText</refname>

		<refpurpose>Makes a collection Geometry from collection WKT with the given SRID. If SRID is
			not give, it defaults to -1.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeomCollFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_GeomCollFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		  <para>Makes a collection Geometry from the Well-Known-Text (WKT) representation with the given SRID. If SRID is
			not give, it defaults to -1.</para>

		  <para>OGC SPEC 3.2.6.2 - option SRID is from the conformance suite</para>

		  <para>Returns null if the WKT is not a GEOMETRYCOLLECTION</para>
		 <note>
			<para>If you are absolutely sure all your WKT geometries are collections, don't use this function.
				It is slower than ST_GeomFromText since it adds an additional validation step.
			</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL. OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: ?</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_GeomCollFromText('GEOMETRYCOLLECTION(POINT(1 2),LINESTRING(1 2, 3 4))');
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromText" />, <xref linkend="ST_SRID" /></para>
	  </refsection>
	</refentry>


	<refentry id="ST_GeomFromEWKB">
	  <refnamediv>
		<refname>ST_GeomFromEWKB</refname>
		<refpurpose>Return a specified ST_Geometry value from Extended Well-Known Binary representation (EWKB).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeomFromEWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>EWKB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Constructs a PostGIS ST_Geometry object from the OGC Extended Well-Known binary (EWKT) representation.</para>
		<note>
			<para>The EWKB format is not an OGC standard, but a PostGIS specific format that includes the spatial reference system (SRID)
			identifier</para>
		</note>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>line string binary rep 0f
		LINESTRING(-71.160281 42.258729,-71.160837 42.259113,-71.161144 42.25932) in NAD 83 long lat (4269).</para>
		<note><para>NOTE: Even though byte arrays are delimited with \ and may have ', we need to escape both out with \ and ''.  So it does not
			look exactly like its AsEWKB representation.</para></note>
	<programlisting>SELECT ST_GeomFromEWKB(E'\\001\\002\\000\\000 \\255\\020\\000\\000\\003\\000\\000\\000\\344J=
\\013B\\312Q\\300n\\303(\\010\\036!E@''\\277E''K
\\312Q\\300\\366{b\\235*!E@\\225|\\354.P\\312Q
\\300p\\231\\323e1!E@');</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_AsBinary" />, <xref linkend="ST_AsEWKB" />, <xref linkend="ST_GeomFromWKB" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_GeomFromEWKT">
	  <refnamediv>
		<refname>ST_GeomFromEWKT</refname>
		<refpurpose>Return a specified ST_Geometry value from Extended Well-Known Text representation (EWKT).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeomFromEWKT</function></funcdef>
			<paramdef><type>text </type> <parameter>EWKT</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Constructs a PostGIS ST_Geometry object from the OGC Extended Well-Known text (EWKT) representation.</para>
		<note>
			<para>The EWKT format is not an OGC standard, but an PostGIS specific format that includes the spatial reference system (SRID)
			identifier</para>
		</note>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
		</inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
	<programlisting>SELECT ST_GeomFromEWKT('SRID=4269;LINESTRING(-71.160281 42.258729,-71.160837 42.259113,-71.161144 42.25932)');
SELECT ST_GeomFromEWKT('SRID=4269;MULTILINESTRING((-71.160281 42.258729,-71.160837 42.259113,-71.161144 42.25932))');

SELECT ST_GeomFromEWKT('SRID=4269;POINT(-71.064544 42.28787)');

SELECT ST_GeomFromEWKT('SRID=4269;POLYGON((-71.1776585052917 42.3902909739571,-71.1776820268866 42.3903701743239,
-71.1776063012595 42.3903825660754,-71.1775826583081 42.3903033653531,-71.1776585052917 42.3902909739571))');

SELECT ST_GeomFromEWKT('SRID=4269;MULTIPOLYGON(((-71.1031880899493 42.3152774590236,
-71.1031627617667 42.3152960829043,-71.102923838298 42.3149156848307,
-71.1023097974109 42.3151969047397,-71.1019285062273 42.3147384934248,
-71.102505233663 42.3144722937587,-71.10277487471 42.3141658254797,
-71.103113945163 42.3142739188902,-71.10324876416 42.31402489987,
-71.1033002961013 42.3140393340215,-71.1033488797549 42.3139495090772,
-71.103396240451 42.3138632439557,-71.1041521907712 42.3141153348029,
-71.1041411411543 42.3141545014533,-71.1041287795912 42.3142114839058,
-71.1041188134329 42.3142693656241,-71.1041112482575 42.3143272556118,
-71.1041072845732 42.3143851580048,-71.1041057218871 42.3144430686681,
-71.1041065602059 42.3145009876017,-71.1041097995362 42.3145589148055,
-71.1041166403905 42.3146168544148,-71.1041258822717 42.3146748022936,
-71.1041375307579 42.3147318674446,-71.1041492906949 42.3147711126569,
-71.1041598612795 42.314808571739,-71.1042515013869 42.3151287620809,
-71.1041173835118 42.3150739481917,-71.1040809891419 42.3151344119048,
-71.1040438678912 42.3151191367447,-71.1040194562988 42.3151832057859,
-71.1038734225584 42.3151140942995,-71.1038446938243 42.3151006300338,
-71.1038315271889 42.315094347535,-71.1037393329282 42.315054824985,
-71.1035447555574 42.3152608696313,-71.1033436658644 42.3151648370544,
-71.1032580383161 42.3152269126061,-71.103223066939 42.3152517403219,
-71.1031880899493 42.3152774590236)),
((-71.1043632495873 42.315113108546,-71.1043583974082 42.3151211109857,
-71.1043443253471 42.3150676015829,-71.1043850704575 42.3150793250568,-71.1043632495873 42.315113108546)))');

--3d circular string
SELECT ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)');
	</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_GeomFromEWKT" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_GeometryFromText">
		  <refnamediv>
			<refname>ST_GeometryFromText</refname>
			<refpurpose>Return a specified ST_Geometry value from Well-Known Text representation (WKT).  This is an alias name for ST_GeomFromText</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_GeometryFromText</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>geometry <function>ST_GeometryFromText</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>
		  <refsection>
			<title>Description</title>
			<!-- Optionally mention OpenGIS compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL.</ulink></para>
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 5.1.40</para>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromText" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_GeomFromText">
		  <refnamediv>
			<refname>ST_GeomFromText</refname>
			<refpurpose>Return a specified ST_Geometry value from Well-Known Text representation (WKT).</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_GeomFromText</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>geometry <function>ST_GeomFromText</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Constructs a PostGIS ST_Geometry object from the OGC Well-Known text representation.</para>

			<!-- optionally mention that this function uses indexes if appropriate -->
			<note>
				<para>There are 2 variants of ST_GeomFromText function, the first takes no SRID and returns a geometry
					with no defined spatial reference system.  The second takes a spatial reference id as the second argument
					and returns an ST_Geometry that includes this srid as part of its meta-data.  The srid must be defined
					in the spatial_ref_sys table.</para>
			</note>

			<!-- Optionally mention OpenGIS compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL.
			OGC SPEC 3.2.6.2 - option SRID is from the conformance suite.</ulink></para>
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 5.1.40</para>

			<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and Curves </para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
	<programlisting>SELECT ST_GeomFromText('LINESTRING(-71.160281 42.258729,-71.160837 42.259113,-71.161144 42.25932)');
SELECT ST_GeomFromText('LINESTRING(-71.160281 42.258729,-71.160837 42.259113,-71.161144 42.25932)',4269);

SELECT ST_GeomFromText('MULTILINESTRING((-71.160281 42.258729,-71.160837 42.259113,-71.161144 42.25932))');

SELECT ST_GeomFromText('POINT(-71.064544 42.28787)');

SELECT ST_GeomFromText('POLYGON((-71.1776585052917 42.3902909739571,-71.1776820268866 42.3903701743239,
-71.1776063012595 42.3903825660754,-71.1775826583081 42.3903033653531,-71.1776585052917 42.3902909739571))');

SELECT ST_GeomFromText('MULTIPOLYGON(((-71.1031880899493 42.3152774590236,
-71.1031627617667 42.3152960829043,-71.102923838298 42.3149156848307,
-71.1023097974109 42.3151969047397,-71.1019285062273 42.3147384934248,
-71.102505233663 42.3144722937587,-71.10277487471 42.3141658254797,
-71.103113945163 42.3142739188902,-71.10324876416 42.31402489987,
-71.1033002961013 42.3140393340215,-71.1033488797549 42.3139495090772,
-71.103396240451 42.3138632439557,-71.1041521907712 42.3141153348029,
-71.1041411411543 42.3141545014533,-71.1041287795912 42.3142114839058,
-71.1041188134329 42.3142693656241,-71.1041112482575 42.3143272556118,
-71.1041072845732 42.3143851580048,-71.1041057218871 42.3144430686681,
-71.1041065602059 42.3145009876017,-71.1041097995362 42.3145589148055,
-71.1041166403905 42.3146168544148,-71.1041258822717 42.3146748022936,
-71.1041375307579 42.3147318674446,-71.1041492906949 42.3147711126569,
-71.1041598612795 42.314808571739,-71.1042515013869 42.3151287620809,
-71.1041173835118 42.3150739481917,-71.1040809891419 42.3151344119048,
-71.1040438678912 42.3151191367447,-71.1040194562988 42.3151832057859,
-71.1038734225584 42.3151140942995,-71.1038446938243 42.3151006300338,
-71.1038315271889 42.315094347535,-71.1037393329282 42.315054824985,
-71.1035447555574 42.3152608696313,-71.1033436658644 42.3151648370544,
-71.1032580383161 42.3152269126061,-71.103223066939 42.3152517403219,
-71.1031880899493 42.3152774590236)),
((-71.1043632495873 42.315113108546,-71.1043583974082 42.3151211109857,
-71.1043443253471 42.3150676015829,-71.1043850704575 42.3150793250568,-71.1043632495873 42.315113108546)))',4326);

SELECT ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)');
	</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_GeomFromWKB" />, <xref linkend="ST_SRID" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_GeomFromWKB">
	  <refnamediv>
		<refname>ST_GeomFromWKB</refname>
		<refpurpose>Creates a geometry instance from a Well-Known Binary geometry
		representation (WKB) and optional SRID.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeomFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>geom</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_GeomFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>geom</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>The <varname>ST_GeomFromWKB</varname> function, takes a well-known
		binary representation of a geometry and a Spatial Reference System ID
		(<varname>SRID</varname>) and creates an instance of the appropriate
		geometry type. This function plays the role of the Geometry Factory in
		SQL. This is an alternate name for ST_WKBToSQL.</para>

		<para>If SRID is not specified, it defaults to -1 (Unknown).</para>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL. OGC SPEC 3.2.7.2</ulink> - the optional SRID is from the conformance suite</para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject>This method implements the SQL/MM specification: SQL-MM 3: 5.1.41</para>

	`	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>--Although bytea rep contains single \, these need to be escaped when inserting into a table
SELECT ST_AsEWKT(
ST_GeomFromWKB(E'\\001\\002\\000\\000\\000\\002\\000\\000\\000\\037\\205\\353Q\\270~\\\\\\300\\323Mb\\020X\\231C@\\020X9\\264\\310~\\\\\\300)\\\\\\217\\302\\365\\230C@',4326)
);
					  st_asewkt
------------------------------------------------------
 SRID=4326;LINESTRING(-113.98 39.198,-113.981 39.195)
(1 row)

SELECT
  ST_AsText(
	ST_GeomFromWKB(
	  ST_AsEWKB('POINT(2 5)'::geometry)
	)
  );
 st_astext
------------
 POINT(2 5)
(1 row)</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_WKBToSQL" />, <xref linkend="ST_AsBinary" />, <xref linkend="ST_GeomFromEWKB" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_LineFromMultiPoint">
	  <refnamediv>
		<refname>ST_LineFromMultiPoint</refname>

		<refpurpose>Creates a LineString from a MultiPoint geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LineFromMultiPoint</function></funcdef>
			<paramdef><type>geometry </type> <parameter>aMultiPoint</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Creates a LineString from a MultiPoint geometry.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>
--Create a 3d line string from a 3d multipoint
SELECT ST_AsEWKT(ST_LineFromMultiPoint(ST_GeomFromEWKT('MULTIPOINT(1 2 3, 4 5 6, 7 8 9)')));
--result--
LINESTRING(1 2 3,4 5 6,7 8 9)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_Collect" />,<xref linkend="ST_MakeLine" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_LineFromText">
	  <refnamediv>
		<refname>ST_LineFromText</refname>

		<refpurpose>Makes a Geometry from WKT representation with the given SRID. If SRID is
				not given, it defaults to -1.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LineFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_LineFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Makes a Geometry from WKT with the given SRID. If SRID is
				not give, it defaults to -1.  If WKT passed in is not a LINESTRING, then null is returned.  </para>

		<note>
		  <para>OGC SPEC 3.2.6.2 - option SRID is from the conformance
				suite.</para>
		</note>

		<note>
		  <para>If you know all your geometries are LINESTRINGS, its more efficient to just use ST_GeomFromText.
			This just calls ST_GeomFromText and adds additional validation that it returns a linestring.</para>
		</note>


		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.  OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 7.2.8</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_LineFromText('LINESTRING(1 2, 3 4)') AS aline, ST_LineFromText('POINT(1 2)') AS null_return;
aline                            | null_return
------------------------------------------------
010200000002000000000000000000F ... | t
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromText" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_LineFromWKB">
	  <refnamediv>
		<refname>ST_LineFromWKB</refname>

		<refpurpose>Makes a <varname>LINESTRING</varname> from WKB with the given SRID</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LineFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>WKB</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_LineFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>WKB</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

	  <para>The <varname>ST_LineFromWKB</varname> function, takes a well-known binary
		representation of geometry and a Spatial Reference System ID (<varname>SRID</varname>)
		and creates an instance of the appropriate geometry type - in this case, a
		<varname>LINESTRING</varname> geometry. This function plays the role of the Geometry
		Factory in SQL.</para>

	  <para>If an SRID is not specified, it defaults to -1. <varname>NULL</varname> is
		returned if the input <varname>bytea</varname>
		does not represent a <varname>LINESTRING</varname>.</para>

		<note>
		  <para>OGC SPEC 3.2.6.2 - option SRID is from the conformance
				suite.</para>
		</note>

		<note>
		  <para>If you know all your geometries are <varname>LINESTRING</varname>s, its more
		  efficient to just use <xref linkend="ST_GeomFromWKB" />.  This function just
		  calls <xref linkend="ST_GeomFromWKB" /> and adds additional validation that
		  it returns a linestring.</para>
		</note>


		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.  OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 7.2.9</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_LineFromWKB(ST_AsBinary(ST_GeomFromText('LINESTRING(1 2, 3 4)'))) AS aline,
		ST_LineFromWKB(ST_AsBinary(ST_GeomFromText('POINT(1 2)'))) IS NULL AS null_return;
aline                            | null_return
------------------------------------------------
010200000002000000000000000000F ... | t
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromWKB" />, <xref linkend="ST_LinestringFromWKB" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_LinestringFromWKB">
	  <refnamediv>
		<refname>ST_LinestringFromWKB</refname>

		<refpurpose>Makes a geometry from WKB with the given SRID.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LinestringFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>WKB</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_LinestringFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>WKB</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

	  <para>The <varname>ST_LinestringFromWKB</varname> function, takes a well-known binary
		representation of geometry and a Spatial Reference System ID (<varname>SRID</varname>)
		and creates an instance of the appropriate geometry type - in this case, a
		<varname>LINESTRING</varname> geometry. This function plays the role of the Geometry
		Factory in SQL.</para>

	  <para>If an SRID is not specified, it defaults to -1.  <varname>NULL</varname> is
		returned if the input <varname>bytea</varname> does not represent a
		<varname>LINESTRING</varname> geometry. This an alias for <xref linkend="ST_LineFromWKB" />.</para>

		<note>
		  <para>OGC SPEC 3.2.6.2 - optional SRID is from the conformance suite.</para>
		</note>

		<note>
		  <para>If you know all your geometries are <varname>LINESTRING</varname>s, it's more
		  efficient to just use <xref linkend="ST_GeomFromWKB" />.  This function just calls
		  <xref linkend="ST_GeomFromWKB" /> and adds additional validation that it returns a
		  <varname>LINESTRING</varname>.</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.  OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 7.2.9</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT
  ST_LineStringFromWKB(
	ST_AsBinary(ST_GeomFromText('LINESTRING(1 2, 3 4)'))
  ) AS aline,
  ST_LinestringFromWKB(
	ST_AsBinary(ST_GeomFromText('POINT(1 2)'))
  ) IS NULL AS null_return;
   aline                            | null_return
------------------------------------------------
010200000002000000000000000000F ... | t</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromWKB" />, <xref linkend="ST_LineFromWKB" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MakeBox2D">
	  <refnamediv>
		<refname>ST_MakeBox2D</refname>

		<refpurpose>Creates a BOX2D defined by the given point
			geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>box2d <function>ST_MakeBox2D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>pointLowLeft</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>pointUpRight</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Creates a BOX2D defined by the given point
			geometries.  This is useful for doing range queries</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Return all features that fall reside or partly reside in a US national atlas coordinate bounding box
--It is assumed here that the geometries are stored with SRID = 2163 (US National atlas equal area)
SELECT feature_id, feature_name, the_geom
FROM features
WHERE the_geom &amp;&amp; ST_SetSRID(ST_MakeBox2D(ST_Point(-989502.1875, 528439.5625),
	ST_Point(-987121.375 ,529933.1875)),2163)</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_MakePoint" />, <xref linkend="ST_Point" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_SRID" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MakeBox3D">
	  <refnamediv>
		<refname>ST_MakeBox3D</refname>

		<refpurpose>Creates a BOX3D defined by the given 3d point
			geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>box3d <function>ST_MakeBox3D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>point3DLowLeftBottom</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>point3DUpRightTop</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Creates a BOX3D defined by the given 2 3D point
			geometries. </para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
SELECT ST_MakeBox3D(ST_MakePoint(-989502.1875, 528439.5625, 10),
	ST_MakePoint(-987121.375 ,529933.1875, 10)) As abb3d

--bb3d--
--------
BOX3D(-989502.1875 528439.5625 10,-987121.375 529933.1875 10)
	</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_MakePoint" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_SRID" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MakeLine">
		<refnamediv>
		<refname>ST_MakeLine</refname>

		<refpurpose>Creates a Linestring from point geometries.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>geometry <function>ST_MakeLine</function></funcdef>
				<paramdef><type>geometry set</type> <parameter>pointfield</parameter></paramdef>
			</funcprototype>

			<funcprototype>
				<funcdef>geometry <function>ST_MakeLine</function></funcdef>
				<paramdef><type>geometry</type> <parameter>point1</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>point2</parameter></paramdef>
			</funcprototype>

			<funcprototype>
				<funcdef>geometry <function>ST_MakeLine</function></funcdef>
				<paramdef><type>geometry[]</type> <parameter>point_array</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
		<title>Description</title>

		<para>ST_MakeLine comes in 3 forms: a spatial aggregate that takes
			rows of point geometries and returns a line string, a function that takes an array of points, and a regular function that takes two point geometries. You
			might want to use a subselect to order points before feeding them
			to  the aggregate version of this function.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		  <para>Availability: 1.4.0 -  ST_MakeLine(geomarray) was introduced. ST_MakeLine aggregate functions was enhanced to handle more points faster.</para>
		</refsection>

		<refsection>
		<title>Examples: Spatial Aggregate version</title>
		<para>This example takes a sequence of GPS points and creates one record for each
			gps travel where the geometry field is a line string composed of the gps points
			in the order of the travel.</para>

		<programlisting>
SELECT gps.gps_track, ST_MakeLine(gps.the_geom) As newgeom
	FROM (SELECT gps_track,gps_time, the_geom
			FROM gps_points ORDER BY gps_track, gps_time) As gps
	GROUP BY gps.gps_track</programlisting>
		</refsection>
		<refsection>
			<title>Examples: Non-Spatial Aggregate version</title>

			<para>First example is a simple one off line string composed of 2 points.  The second formulates
				line strings from 2 points a user draws.  The third is a one-off that joins 2 3d points to create a line in 3d space.</para>
			<programlisting>
SELECT ST_AsText(ST_MakeLine(ST_MakePoint(1,2), ST_MakePoint(3,4)));
	  st_astext
---------------------
 LINESTRING(1 2,3 4)

SELECT userpoints.id, ST_MakeLine(startpoint, endpoint) As drawn_line
	FROM userpoints ;

SELECT ST_AsEWKT(ST_MakeLine(ST_MakePoint(1,2,3), ST_MakePoint(3,4,5)));
		st_asewkt
-------------------------
 LINESTRING(1 2 3,3 4 5)
			</programlisting>
		</refsection>

		<refsection>
			<title>Examples: Using Array version</title>

			<programlisting>
SELECT ST_MakeLine(ARRAY(SELECT ST_Centroid(the_geom) FROM visit_locations ORDER BY visit_time));

--Making a 3d line with 3 3-d points
SELECT ST_AsEWKT(ST_MakeLine(ARRAY[ST_MakePoint(1,2,3),
				ST_MakePoint(3,4,5), ST_MakePoint(6,6,6)]));
		st_asewkt
-------------------------
LINESTRING(1 2 3,3 4 5,6 6 6)
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_MakePoint" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_MakePolygon">
		<refnamediv>
		<refname>ST_MakePolygon</refname>

		<refpurpose>Creates a Polygon formed by the given shell. Input
			geometries must be closed LINESTRINGS.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePolygon</function></funcdef>
			<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePolygon</function></funcdef>
			<paramdef><type>geometry</type> <parameter>outerlinestring</parameter></paramdef>
			<paramdef><type>geometry[]</type> <parameter>interiorlinestrings</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a Polygon formed by the given shell. Input
				geometries must be closed LINESTRINGS. Comes in 2 variants.</para>
			<para>Variant 1: takes one closed linestring.</para>
			<para>Variant 2:  Creates a Polygon formed by the given shell and array of
			holes. You can construct a geometry array using ST_Accum or the PostgreSQL ARRAY[] and
			ARRAY() constructs. Input geometries must be closed LINESTRINGS.</para>
			<note>
				<para>This function will not accept a MULTILINESTRING.  Use <xref linkend="ST_LineMerge" /> or <xref linkend="ST_Dump" /> to generate line strings.</para>
			</note>

			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		</refsection>

		<refsection>
		<title>Examples: Single closed LINESTRING</title>
		 <programlisting>
--2d line
SELECT ST_MakePolygon(ST_GeomFromText('LINESTRING(75.15 29.53,77 29,77.6 29.5, 75.15 29.53)'));
--If linestring is not closed
--you can add the start point to close it
SELECT ST_MakePolygon(ST_AddPoint(foo.open_line, ST_StartPoint(foo.open_line)))
FROM (
SELECT ST_GeomFromText('LINESTRING(75.15 29.53,77 29,77.6 29.5)') As open_line) As foo;

--3d closed line
SELECT ST_MakePolygon(ST_GeomFromText('LINESTRING(75.15 29.53 1,77 29 1,77.6 29.5 1, 75.15 29.53 1)'));

st_asewkt
-----------
POLYGON((75.15 29.53 1,77 29 1,77.6 29.5 1,75.15 29.53 1))

--measured line --
SELECT ST_MakePolygon(ST_GeomFromText('LINESTRINGM(75.15 29.53 1,77 29 1,77.6 29.5 2, 75.15 29.53 2)'));

st_asewkt
----------
POLYGONM((75.15 29.53 1,77 29 1,77.6 29.5 2,75.15 29.53 2))
			  </programlisting>
		</refsection>
		<refsection>
			<title>Examples: Outter shell with inner shells</title>

			<para>Build a donut with an ant hole</para>
		   <programlisting>
SELECT ST_MakePolygon(
		ST_ExteriorRing(ST_Buffer(foo.line,10)),
	ARRAY[ST_Translate(foo.line,1,1),
		ST_ExteriorRing(ST_Buffer(ST_MakePoint(20,20),1)) ]
	)
FROM
	(SELECT ST_ExteriorRing(ST_Buffer(ST_MakePoint(10,10),10,10))
		As line )
		As foo;
		</programlisting>
		<para>Build province boundaries with holes
		representing lakes in the province from a set of
		province polygons/multipolygons and water line strings
		this is an example of using PostGIS ST_Accum
		<note><para>The use of CASE because feeding a null array into
		ST_MakePolygon results in NULL</para></note>
		<note><para>the use of left join to guarantee we get all provinces back even if they have no lakes</para></note></para>
		<programlisting>
	SELECT p.gid, p.province_name,
		CASE WHEN
			ST_Accum(w.the_geom) IS NULL THEN p.the_geom
		ELSE  ST_MakePolygon(ST_LineMerge(ST_Boundary(p.the_geom)), ST_Accum(w.the_geom)) END
	FROM
		provinces p LEFT JOIN waterlines w
			ON (ST_Within(w.the_geom, p.the_geom) AND ST_IsClosed(w.the_geom))
	GROUP BY p.gid, p.province_name, p.the_geom;

	--Same example above but utilizing a correlated subquery
	--and PostgreSQL built-in ARRAY() function that converts a row set to an array

	SELECT p.gid,  p.province_name, CASE WHEN
		EXISTS(SELECT w.the_geom
			FROM waterlines w
			WHERE ST_Within(w.the_geom, p.the_geom)
			AND ST_IsClosed(w.the_geom))
		THEN
		ST_MakePolygon(ST_LineMerge(ST_Boundary(p.the_geom)),
			ARRAY(SELECT w.the_geom
				FROM waterlines w
				WHERE ST_Within(w.the_geom, p.the_geom)
				AND ST_IsClosed(w.the_geom)))
		ELSE p.the_geom END As the_geom
	FROM
		provinces p;
			  </programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Accum" />, <xref linkend="ST_AddPoint" />, <xref linkend="ST_GeometryType" />, <xref linkend="ST_IsClosed" />, <xref linkend="ST_LineMerge" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_MakePoint">
		<refnamediv>
		<refname>ST_MakePoint</refname>

		<refpurpose>Creates a 2D,3DZ or 4D point geometry.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePoint</function></funcdef>
			<paramdef><type>double precision</type> <parameter>x</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>y</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePoint</function></funcdef>
			<paramdef><type>double precision</type> <parameter>x</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>y</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>z</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePoint</function></funcdef>
			<paramdef><type>double precision</type> <parameter>x</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>y</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>z</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>m</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a 2D,3DZ or 4D point geometry (geometry with measure).
			<varname>ST_MakePoint</varname> while not being OGC compliant is
			generally faster and more precise than <xref linkend="ST_GeomFromText" />
			and <xref linkend="ST_PointFromText" />.  It is also easier to use if
			you have raw coordinates rather than WKT.</para>

			<note><para>Note x is longitude and y is latitude</para></note>

			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
		</refsection>

		<refsection>
		<title>Examples</title>
		 <programlisting>--Return point with unknown SRID
SELECT ST_MakePoint(-71.1043443253471, 42.3150676015829);

--Return point marked as WGS 84 long lat
SELECT ST_SetSRID(ST_MakePoint(-71.1043443253471, 42.3150676015829),4326);

--Return a 3D point (e.g. has altitude)
SELECT ST_MakePoint(1, 2,1.5);

--Get z of point
SELECT ST_Z(ST_MakePoint(1, 2,1.5));
result
-------
1.5</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromText" />, <xref linkend="ST_PointFromText" />, <xref linkend="ST_SetSRID" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_MakePointM">
		<refnamediv>
		<refname>ST_MakePointM</refname>

		<refpurpose>Creates a point geometry with an x y and m coordinate.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_MakePointM</function></funcdef>
				<paramdef><type>float</type> <parameter>x</parameter></paramdef>
				<paramdef><type>float</type> <parameter>y</parameter></paramdef>
				<paramdef><type>float</type> <parameter>m</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a point with x, y and measure coordinates. </para>
			<note><para>Note x is longitude and y is latitude.</para></note>
		</refsection>

		<refsection>
		<title>Examples</title>
			<para>We use ST_AsEWKT in these examples to show the text representation instead of ST_AsText because ST_AsText does not
			support returning M.</para>
		 <programlisting>
--Return EWKT representation of point with unknown SRID
SELECT ST_AsEWKT(ST_MakePointM(-71.1043443253471, 42.3150676015829, 10));

--result
				   st_asewkt
-----------------------------------------------
 POINTM(-71.1043443253471 42.3150676015829 10)

--Return EWKT representation of point with measure marked as WGS 84 long lat
SELECT ST_AsEWKT(ST_SetSRID(ST_MakePointM(-71.1043443253471, 42.3150676015829,10),4326));

						st_asewkt
---------------------------------------------------------
SRID=4326;POINTM(-71.1043443253471 42.3150676015829 10)

--Return a 3d point (e.g. has altitude)
SELECT ST_MakePoint(1, 2,1.5);

--Get m of point
SELECT ST_M(ST_MakePointM(-71.1043443253471, 42.3150676015829,10));
result
-------
10
			  </programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_MakePoint" />, <xref linkend="ST_SetSRID" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_MLineFromText">
	  <refnamediv>
		<refname>ST_MLineFromText</refname>

		<refpurpose>Return a specified ST_MultiLineString value from WKT representation.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MLineFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_MLineFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		 <para>Makes a Geometry from  Well-Known-Text (WKT) with the given SRID. If SRID is
			not give, it defaults to -1.</para>

		 <para>OGC SPEC 3.2.6.2 - option SRID is from the conformance
			suite</para>

		 <para>Returns null if the WKT is not a MULTILINESTRING</para>

		 <note>
			<para>If you are absolutely sure all your WKT geometries are points, don't use this function.
				It is slower than ST_GeomFromText since it adds an additional validation step.
			</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL. OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 9.4.4</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_MLineFromText('MULTILINESTRING((1 2, 3 4), (4 5, 6 7))');</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromText" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MPointFromText">
	  <refnamediv>
		<refname>ST_MPointFromText</refname>

		<refpurpose>Makes a Geometry from WKT with the given SRID. If SRID is
			not give, it defaults to -1.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MPointFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_MPointFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		 <para>Makes a Geometry from WKT with the given SRID. If SRID is
			not give, it defaults to -1.</para>

		 <para>OGC SPEC 3.2.6.2 - option SRID is from the conformance
			suite</para>

		 <para>Returns null if the WKT is not a MULTIPOINT</para>

		 <note>
			<para>If you are absolutely sure all your WKT geometries are points, don't use this function.
				It is slower than ST_GeomFromText since it adds an additional validation step.
			</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL. OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 9.2.4</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_MPointFromText('MULTIPOINT(1 2, 3 4)');
SELECT ST_MPointFromText('MULTIPOINT(-70.9590 42.1180, -70.9611 42.1223)', 4326);</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromText" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MPolyFromText">
	  <refnamediv>
		<refname>ST_MPolyFromText</refname>

		<refpurpose>Makes a MultiPolygon Geometry from WKT with the given SRID. If SRID is
			not give, it defaults to -1.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MPolyFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_MPolyFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		 <para>Makes a MultiPolygon from WKT with the given SRID. If SRID is
			not give, it defaults to -1.</para>

		 <para>OGC SPEC 3.2.6.2 - option SRID is from the conformance suite</para>


		 <para>Throws an error if the WKT is not a MULTIPOLYGON</para>

		 <note>
			<para>If you are absolutely sure all your WKT geometries are multipolygons, don't use this function.
				It is slower than ST_GeomFromText since it adds an additional validation step.
			</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL. OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 9.6.4</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_MPolyFromText('MULTIPOLYGON(((0 0 1,20 0 1,20 20 1,0 20 1,0 0 1),(5 5 3,5 7 3,7 7 3,7 5 3,5 5 3)))');
SELECt ST_MPolyFromText('MULTIPOLYGON(((-70.916 42.1002,-70.9468 42.0946,-70.9765 42.0872,-70.9754 42.0875,-70.9749 42.0879,-70.9752 42.0881,-70.9754 42.0891,-70.9758 42.0894,-70.9759 42.0897,-70.9759 42.0899,-70.9754 42.0902,-70.9756 42.0906,-70.9753 42.0907,-70.9753 42.0917,-70.9757 42.0924,-70.9755 42.0928,-70.9755 42.0942,-70.9751 42.0948,-70.9755 42.0953,-70.9751 42.0958,-70.9751 42.0962,-70.9759 42.0983,-70.9767 42.0987,-70.9768 42.0991,-70.9771 42.0997,-70.9771 42.1003,-70.9768 42.1005,-70.977 42.1011,-70.9766 42.1019,-70.9768 42.1026,-70.9769 42.1033,-70.9775 42.1042,-70.9773 42.1043,-70.9776 42.1043,-70.9778 42.1048,-70.9773 42.1058,-70.9774 42.1061,-70.9779 42.1065,-70.9782 42.1078,-70.9788 42.1085,-70.9798 42.1087,-70.9806 42.109,-70.9807 42.1093,-70.9806 42.1099,-70.9809 42.1109,-70.9808 42.1112,-70.9798 42.1116,-70.9792 42.1127,-70.979 42.1129,-70.9787 42.1134,-70.979 42.1139,-70.9791 42.1141,-70.9987 42.1116,-71.0022 42.1273,
	-70.9408 42.1513,-70.9315 42.1165,-70.916 42.1002)))',4326);
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromText" />, <xref linkend="ST_SRID" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Point">
	  <refnamediv>
		<refname>ST_Point</refname>

		<refpurpose>Returns an ST_Point with the given coordinate values. OGC alias for ST_MakePoint.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Point</function></funcdef>
			<paramdef><type>float </type> <parameter>x_lon</parameter></paramdef>
			<paramdef><type>float </type> <parameter>y_lat</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns an ST_Point with the given coordinate values. MM compliant alias for ST_MakePoint that takes just an x and y.</para>


		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 6.1.2</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_SetSRID(ST_Point(-71.1043443253471, 42.3150676015829),4326)</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_MakePoint" />, <xref linkend="ST_SetSRID" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_PointFromText">
		  <refnamediv>
			<refname>ST_PointFromText</refname>
			<refpurpose>Makes a point Geometry from WKT with the given SRID. If SRID is
			not given, it defaults to unknown.</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_PointFromText</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>geometry <function>ST_PointFromText</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Constructs a PostGIS ST_Geometry point object from the OGC Well-Known text representation. If SRID is
			not give, it defaults to unknown (currently -1).  If geometry is not a WKT point representation, returns null.
			If completely invalid WKT, then throws an error.</para>

			<!-- optionally mention that this function uses indexes if appropriate -->
			<note>
				<para>There are 2 variants of ST_PointFromText function, the first takes no SRID and returns a geometry
					with no defined spatial reference system.  The second takes a spatial reference id as the second argument
					and returns an ST_Geometry that includes this srid as part of its meta-data.  The srid must be defined
					in the spatial_ref_sys table.</para>
			</note>

			<note>
				<para>If you are absolutely sure all your WKT geometries are points, don't use this function.
					It is slower than ST_GeomFromText since it adds an additional validation step.  If you are building points from long lat coordinates and care more about performance and accuracy than OGC compliance, use <xref linkend="ST_MakePoint" /> or OGC compliant alias <xref linkend="ST_Point" />.   </para>
			</note>

			<!-- Optionally mention OpenGIS compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL.
			OGC SPEC 3.2.6.2 - option SRID is from the conformance suite.</ulink></para>
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:SQL-MM 3: 6.1.8</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
	<programlisting>
SELECT ST_PointFromText('POINT(-71.064544 42.28787)');
SELECT ST_PointFromText('POINT(-71.064544 42.28787)', 4326);
	</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromText" />, <xref linkend="ST_MakePoint" />, <xref linkend="ST_Point" />, <xref linkend="ST_SRID" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_PointFromWKB">
	  <refnamediv>
		<refname>ST_PointFromWKB</refname>

		<refpurpose>Makes a geometry from WKB with the given SRID</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeomFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>geom</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_GeomFromWKB</function></funcdef>
			<paramdef><type>bytea </type> <parameter>geom</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>The <varname>ST_PointFromWKB</varname> function, takes a well-known binary
			representation of geometry and a Spatial Reference System ID (<varname>SRID</varname>)
			and creates an instance of the appropriate geometry type - in this case, a
			<varname>POINT</varname> geometry. This function plays the role of the Geometry
			Factory in SQL.</para>

		<para>If an SRID is not specified, it defaults to -1.  <varname>NULL</varname> is
		returned if the input <varname>bytea</varname> does not represent a
		<varname>POINT</varname> geometry.</para>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject>This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL. 3.2.7.2</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
			</inlinemediaobject>This method implements the SQL/MM specification: SQL-MM 3: 6.1.9
		</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject>This function supports 3D</para>

		<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject>This method supports Circular Strings and Curves</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT
  ST_AsText(
	ST_PointFromWKB(
	  ST_AsEWKB('POINT(2 5)'::geometry)
	)
  );
 st_astext
------------
 POINT(2 5)
(1 row)

SELECT
  ST_AsText(
	ST_PointFromWKB(
	  ST_AsEWKB('LINESTRING(2 5, 2 6)'::geometry)
	)
  );
 st_astext
-----------

(1 row)</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromWKB" />, <xref linkend="ST_LineFromWKB" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Polygon">
	  <refnamediv>
		<refname>ST_Polygon</refname>

		<refpurpose>Returns a polygon built from the specified linestring and SRID.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Polygon</function></funcdef>
			<paramdef><type>geometry </type> <parameter>aLineString</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a polygon built from the specified linestring and SRID.</para>

		<!-- optionally mention that this function uses indexes if appropriate -->
		<note>
		  <para>ST_Polygon is similar to first version oST_MakePolygon except it also sets the spatial ref sys (SRID) of the polygon. Will not work with MULTILINESTRINGS
			so use LineMerge to merge multilines.  Also does not create polygons with holes.  Use ST_MakePolygon for that.</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 8.3.2</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--a 2d polygon
SELECT ST_Polygon(ST_GeomFromText('LINESTRING(75.15 29.53,77 29,77.6 29.5, 75.15 29.53)'), 4326);

--result--
POLYGON((75.15 29.53,77 29,77.6 29.5,75.15 29.53))
--a 3d polygon
SELECT ST_AsEWKT(ST_Polygon(ST_GeomFromEWKT('LINESTRING(75.15 29.53 1,77 29 1,77.6 29.5 1, 75.15 29.53 1)'), 4326));

result
------
SRID=4326;POLYGON((75.15 29.53 1,77 29 1,77.6 29.5 1,75.15 29.53 1))
			</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para> <xref linkend="ST_AsEWKT" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_LineMerge" />, <xref linkend="ST_MakePolygon" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_PolygonFromText">
	  <refnamediv>
		<refname>ST_PolygonFromText</refname>

		<refpurpose>Makes a Geometry from WKT with the given SRID. If SRID is
			not give, it defaults to -1.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_PolygonFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>geometry <function>ST_PolygonFromText</function></funcdef>
			<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Makes a Geometry from WKT with the given SRID. If SRID is
			not give, it defaults to -1.  Returns null if WKT is not a polygon.</para>


		<para>OGC SPEC 3.2.6.2 - option SRID is from the conformance
			suite</para>

		<note><para>If you are absolutely sure all your WKT geometries are polygons, don't use this function.
					It is slower than ST_GeomFromText since it adds an additional validation step. </para></note>
		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL. OGC SPEC 3.2.6.2</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 8.3.6</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_PolygonFromText('POLYGON((-71.1776585052917 42.3902909739571,-71.1776820268866 42.3903701743239,
-71.1776063012595 42.3903825660754,-71.1775826583081 42.3903033653531,-71.1776585052917 42.3902909739571))');
st_polygonfromtext
------------------
010300000001000000050000006...


SELECT ST_PolygonFromText('POINT(1 2)') IS NULL as point_is_notpoly;

point_is_not_poly
----------
t
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromText" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_WKBToSQL">
		  <refnamediv>
			<refname>ST_WKBToSQL</refname>
			<refpurpose>Return a specified ST_Geometry value from Well-Known Binary representation (WKB).  This is an alias name for ST_GeomFromWKB that takes no srid</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_WKBToSQL</function></funcdef>
				<paramdef><type>bytea </type> <parameter>WKB</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>
		  <refsection>
			<title>Description</title>
			<!-- Optionally mention OpenGIS compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.36</para>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromWKB" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_WKTToSQL">
		  <refnamediv>
			<refname>ST_WKTToSQL</refname>
			<refpurpose>Return a specified ST_Geometry value from Well-Known Text representation (WKT).  This is an alias name for ST_GeomFromText</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_WKTToSQL</function></funcdef>
				<paramdef><type>text </type> <parameter>WKT</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>
		  <refsection>
			<title>Description</title>
			<!-- Optionally mention OpenGIS compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 5.1.34</para>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromText" /></para>
		  </refsection>
	</refentry>
  </sect1>

  <sect1 id="Geometry_Accessors">
	<title>Geometry Accessors</title>

	<refentry id="GeometryType">
	  <refnamediv>
		<refname>GeometryType</refname>

		<refpurpose>Returns the type of the geometry as a string. Eg:
			'LINESTRING', 'POLYGON', 'MULTIPOINT', etc.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>GeometryType</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the type of the geometry as a string. Eg:
		'LINESTRING', 'POLYGON', 'MULTIPOINT', etc.</para>

		<para>OGC SPEC s2.1.1.1 - Returns the name of the instantiable
		subtype of Geometry of which this Geometry instance is a member.
		The name of the instantiable subtype of Geometry is returned as a
		string.</para>

		<note>
		  <para>This function also indicates if the geometry is measured,
		  by returning a string of the form 'POINTM'.</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT GeometryType(ST_GeomFromText('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)'));
 geometrytype
--------------
 LINESTRING
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_GeometryType" /></para>
	  </refsection>
	</refentry>
	<refentry id="ST_Boundary">
	  <refnamediv>
		<refname>ST_Boundary</refname>

		<refpurpose>Returns the closure of the combinatorial boundary of this
			Geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Boundary</function></funcdef>

			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the closure of the combinatorial boundary of this
			Geometry. The combinatorial boundary is defined as described in
			section 3.12.3.2 of the OGC SPEC. Because the result of this
			function is a closure, and hence topologically closed, the
			resulting boundary can be represented using representational
			geometry primitives as discussed in the OGC SPEC, section
			3.12.2.</para>
		<para>Performed by the GEOS module</para>
		<important>
		  <para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		</important>

		<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL.</ulink> OGC SPEC s2.1.1.1</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.14</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		 <programlisting>SELECT ST_AsText(ST_Boundary(ST_GeomFromText('LINESTRING(1 1,0 0, -1 1)')));
st_astext
-----------
MULTIPOINT(1 1,-1 1)

SELECT ST_AsText(ST_Boundary(ST_GeomFromText('POLYGON((1 1,0 0, -1 1, 1 1))')));
st_astext
----------
LINESTRING(1 1,0 0,-1 1,1 1)

--Using a 3d polygon
SELECT ST_AsEWKT(ST_Boundary(ST_GeomFromEWKT('POLYGON((1 1 1,0 0 1, -1 1 1, 1 1 1))')));

st_asewkt
-----------------------------------
LINESTRING(1 1 1,0 0 1,-1 1 1,1 1 1)

--Using a 3d multilinestring
SELECT ST_AsEWKT(ST_Boundary(ST_GeomFromEWKT('MULTILINESTRING((1 1 1,0 0 0.5, -1 1 1),(1 1 0.5,0 0 0.5, -1 1 0.5, 1 1 0.5) )')));

st_asewkt
----------
MULTIPOINT(-1 1 1,1 1 0.75)
</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_ExteriorRing" />, <xref linkend="ST_MakePolygon" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_CoordDim">
	  <refnamediv>
		<refname>ST_CoordDim</refname>

		<refpurpose><para>Return the coordinate dimension of the ST_Geometry value.</para></refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_CoordDim</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the coordinate dimension of the ST_Geometry value.</para>

		<para>This is the MM compliant alias name for <xref linkend="ST_NDims" /></para>


		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.3</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_CoordDim('CIRCULARSTRING(1 2 3, 1 3 4, 5 6 7, 8 9 10, 11 12 13)');
			---result--
				3

				SELECT ST_CoordDim(ST_Point(1,2));
			--result--
				2

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_NDims" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Dimension">
	  <refnamediv>
		<refname>ST_Dimension</refname>

		<refpurpose>The inherent dimension of this Geometry object, which must
			be less than or equal to the coordinate dimension. </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_Dimension</function></funcdef>

			<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>The inherent dimension of this Geometry object, which must
			be less than or equal to the coordinate dimension. OGC SPEC
			s2.1.1.1 - returns 0 for <varname>POINT</varname>, 1 for <varname>LINESTRING</varname>, 2 for <varname>POLYGON</varname>, and
			the largest dimension of the components of a
			<varname>GEOMETRYCOLLECTION</varname>.</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.2</para>


	  </refsection>

	  <refsection>
		<title>Examples</title>

		 <programlisting>SELECT ST_Dimension('GEOMETRYCOLLECTION(LINESTRING(1 1,0 0),POINT(0 0))');
ST_Dimension
-----------
1
</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_NDims" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_EndPoint">
	  <refnamediv>
		<refname>ST_EndPoint</refname>

		<refpurpose>Returns the last point of a <varname>LINESTRING</varname>
		geometry as a <varname>POINT</varname>.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_EndPoint</function></funcdef>

			<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the last point of a <varname>LINESTRING</varname> geometry
		as a <varname>POINT</varname> or <varname>NULL</varname> if the input
		parameter is not a <varname>LINESTRING</varname>.</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 7.1.4</para>

		<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>postgis=# SELECT ST_AsText(ST_EndPoint('LINESTRING(1 1, 2 2, 3 3)'::geometry));
 st_astext
------------
 POINT(3 3)
(1 row)

postgis=# SELECT ST_EndPoint('POINT(1 1)'::geometry) IS NULL AS is_null;
  is_null
----------
 t
(1 row)

--3d endpoint
SELECT ST_AsEWKT(ST_EndPoint('LINESTRING(1 1 2, 1 2 3, 0 0 5)'));
  st_asewkt
--------------
 POINT(0 0 5)
(1 row)
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_PointN" />, <xref
		linkend="ST_StartPoint" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Envelope">
		  <refnamediv>
			<refname>ST_Envelope</refname>

			<refpurpose>Returns a geometry representing the bounding box of the
			supplied geometry.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Envelope</function></funcdef>

				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the float4 minimum bounding box for the supplied geometry, as a geometry.
			The polygon is defined by the corner points of the bounding box
			((<varname>MINX</varname>, <varname>MINY</varname>),
			(<varname>MINX</varname>, <varname>MAXY</varname>),
			(<varname>MAXX</varname>, <varname>MAXY</varname>),
			(<varname>MAXX</varname>, <varname>MINY</varname>),
			(<varname>MINX</varname>, <varname>MINY</varname>)). (PostGIS will add a
			<varname>ZMIN</varname>/<varname>ZMAX</varname> coordinate as
			well).</para>

			<para>Degenerate cases (vertical lines, points) will return a geometry of
			lower dimension than <varname>POLYGON</varname>, ie.
			<varname>POINT</varname> or <varname>LINESTRING</varname>.</para>

			<caution>
			  <para>In PostGIS, the bounding box of a geometry is represented internally using
			  <varname>float4</varname>s instead of <varname>float8</varname>s that are used
			  to store geometries.  The bounding box coordinates are floored, guarenteeing
			  that the geometry is contained entirely within its bounds.  This has the
			  advantage that a geometry's bounding box is half the size as the minimum
			  bounding rectangle, which means significantly faster indexes and general performance.
			  But it also means that the bounding box is NOT the same as the minimum bounding
			  rectangle that bounds the geometry.</para>
			</caution>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL.</ulink></para>
			<para><inlinemediaobject>
        <imageobject>
          <imagedata fileref="images/check.png" />
        </imageobject>
      </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.15</para>
	</refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>
SELECT ST_AsText(ST_Envelope('POINT(1 3)'::geometry));
 st_astext
------------
 POINT(1 3)
(1 row)


SELECT ST_AsText(ST_Envelope('LINESTRING(0 0, 1 3)'::geometry));
		   st_astext
--------------------------------
 POLYGON((0 0,0 3,1 3,1 0,0 0))
(1 row)


SELECT ST_AsText(ST_Envelope('POLYGON((0 0, 0 1, 1.0000001 1, 1.0000001 0, 0 0))'::geometry));
						  st_astext
--------------------------------------------------------------
 POLYGON((0 0,0 1,1.00000011920929 1,1.00000011920929 0,0 0))
(1 row)
SELECT ST_AsText(ST_Envelope('POLYGON((0 0, 0 1, 1.0000000001 1, 1.0000000001 0, 0 0))'::geometry));
						  st_astext
--------------------------------------------------------------
 POLYGON((0 0,0 1,1.00000011920929 1,1.00000011920929 0,0 0))
(1 row)
	
SELECT ST_Box3D(geom), ST_Box2D(geom), ST_AsText(ST_Envelope(geom)) As envelopewkt
	FROM (SELECT 'POLYGON((0 0, 0 1000012333334.34545678, 1.0000001 1, 1.0000001 0, 0 0))'::geometry As geom) As foo;

box3d
-----------------------------------------
BOX3D(0 0 0,1.0000001 1000012333334.35 0)

box2d
------------------------------------------
BOX(0 0,1.00000011920929 1000012382208)

envelopewkt
-------------------------------------------------------------------
POLYGON((0 0,0 1000012382208,1.00000011920929 1000012382208,1.00000011920929 0,0 0))
	</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Box2D" />, <xref linkend="ST_Box3D" /></para>
	  </refsection>
	</refentry>


	<refentry id="ST_ExteriorRing">
	  <refnamediv>
		<refname>ST_ExteriorRing</refname>

		<refpurpose>Returns a line string representing the exterior ring of the <varname>POLYGON</varname> geometry. Return
				NULL if the geometry is not a polygon.  Will not work with MULTIPOLYGON</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ExteriorRing</function></funcdef>

			<paramdef><type>geometry </type> <parameter>a_polygon</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a line string representing the exterior ring of the <varname>POLYGON</varname> geometry. Return
				NULL if the geometry is not a polygon.</para>

		<note><para>Only works with POLYGON geometry types</para></note>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink> OGC SFSQL 1.1 -
		2.1.5.1</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 8.2.3, 8.3.3</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
<programlisting>
--If you have a table of polygons
SELECT gid, ST_ExteriorRing(the_geom) AS ering
FROM sometable;

--If you have a table of MULTIPOLYGONs
--and want to return a MULTILINESTRING composed of the exterior rings of each polygon
SELECT gid, ST_Collect(ST_ExteriorRing(the_geom)) AS erings
	FROM (SELECT gid, (ST_Dump(the_geom)).geom As the_geom
			FROM sometable) As foo
GROUP BY gid;

--3d Example
SELECT ST_AsEWKT(
	ST_ExteriorRing(
	ST_GeomFromEWKT('POLYGON((0 0 1, 1 1 1, 1 2 1, 1 1 1, 0 0 1))')
	)
);

st_asewkt
---------
LINESTRING(0 0 1,1 1 1,1 2 1,1 1 1,0 0 1)
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Boundary" />, <xref linkend="ST_NumInteriorRings" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_GeometryN">
	  <refnamediv>
		<refname>ST_GeometryN</refname>

		<refpurpose>Return the 1-based Nth geometry if the geometry is a
			GEOMETRYCOLLECTION, MULTIPOINT, MULTILINESTRING, MULTICURVE or MULTIPOLYGON.
			Otherwise, return NULL.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeometryN</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>n</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the 1-based Nth geometry if the geometry is a
			GEOMETRYCOLLECTION, MULTIPOINT, MULTILINESTRING, MULTICURVE or MULTIPOLYGON.
			Otherwise, return NULL.</para>

		<note>
		  <para>Index is 1-based as for OGC specs since version 0.8.0.
		  Previous versions implemented this as 0-based instead.</para>
		</note>

		<note>
		  <para>If you want to extract all geometries, of a geometry, ST_Dump is more efficient and will also work for singular geoms.</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 9.1.5</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject>This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Extracting a subset of points from a 3d multipoint
SELECT n, ST_AsEWKT(ST_GeometryN(the_geom, n)) As geomewkt
FROM (
VALUES (ST_GeomFromEWKT('MULTIPOINT(1 2 7, 3 4 7, 5 6 7, 8 9 10)') ),
( ST_GeomFromEWKT('MULTICURVE(CIRCULARSTRING(2.5 2.5,4.5 2.5, 3.5 3.5), (10 11, 12 11))') )
	)As foo(the_geom)
	CROSS JOIN generate_series(1,100) n
WHERE n &lt;= ST_NumGeometries(the_geom);

 n |               geomewkt
---+-----------------------------------------
 1 | POINT(1 2 7)
 2 | POINT(3 4 7)
 3 | POINT(5 6 7)
 4 | POINT(8 9 10)
 1 | CIRCULARSTRING(2.5 2.5,4.5 2.5,3.5 3.5)
 2 | LINESTRING(10 11,12 11)


--Extracting all geometries (useful when you want to assign an id)
SELECT gid, n, ST_GeometryN(the_geom, n)
FROM sometable CROSS JOIN generate_series(1,100) n
WHERE n &lt;= ST_NumGeometries(the_geom);


</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Dump" />, <xref linkend="ST_NumGeometries" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_GeometryType">
		<refnamediv>
			<refname>ST_GeometryType</refname>
			<refpurpose>Return the geometry type of the ST_Geometry value.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>ST_GeometryType</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>

			<para>Returns the type of the geometry as a string. EG: 'ST_Linestring', 'ST_Polygon','ST_MultiPolygon' etc. This function differs from GeometryType(geometry) in the case of the string and ST in front that is returned, as well as the fact that it will not indicate whether the geometry is measured.</para>

			 <!-- Optionally mention SQL/MM compliancy if appropriate -->
				<para><inlinemediaobject>
					<imageobject>
					  <imagedata fileref="images/check.png" />
					</imageobject>
				  </inlinemediaobject> This method implements the SQL/MM specification:
				SQL-MM 3: 5.1.4</para>

		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_GeometryType(ST_GeomFromText('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)'));
			--result
			ST_LineString
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>

			<para><xref linkend="GeometryType" /></para>
		</refsection>
	</refentry>



	<refentry id="ST_InteriorRingN">
	  <refnamediv>
		<refname>ST_InteriorRingN</refname>

		<refpurpose>Return the Nth interior linestring ring of the polygon geometry.
			Return NULL if the geometry is not a polygon or the given N is out
			of range.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_InteriorRingN</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_polygon</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>n</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the Nth interior linestring ring of the polygon geometry.
			Return NULL if the geometry is not a polygon or the given N is out
			of range.  index starts at 1.</para>

		<!-- optionally mention that this function uses indexes if appropriate -->
		<note>
		  <para>This will not work for MULTIPOLYGONs.  Use in conjunction with ST_Dump for MULTIPOLYGONS</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 8.2.6, 8.3.5</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
SELECT ST_AsText(ST_InteriorRingN(the_geom, 1)) As the_geom
FROM (SELECT ST_BuildArea(
		ST_Collect(ST_Buffer(ST_Point(1,2), 20,3),
			ST_Buffer(ST_Point(1, 2), 10,3))) As the_geom
		)  as foo
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_BuildArea" />, <xref linkend="ST_Collect" />, <xref linkend="ST_Dump" />, <xref linkend="ST_NumInteriorRing" />, <xref linkend="ST_NumInteriorRings" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_IsClosed">
	  <refnamediv>
		<refname>ST_IsClosed</refname>

		<refpurpose>Returns <varname>TRUE</varname> if the
		<varname>LINESTRING</varname>'s start and end points are coincident.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_IsClosed</function></funcdef>

			<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns <varname>TRUE</varname> if the <varname>LINESTRING</varname>'s
		start and end points are coincident.</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 7.1.5, 9.3.3</para>

		<note>
		  <para>SQL-MM defines the result of
		  <function>ST_IsClosed(<varname>NULL</varname>)</function> to be 0, while
		  PostGIS returns <varname>NULL</varname>.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>postgis=# SELECT ST_IsClosed('LINESTRING(0 0, 1 1)'::geometry);
 st_isclosed
-------------
 f
(1 row)

postgis=# SELECT ST_IsClosed('LINESTRING(0 0, 0 1, 1 1, 0 0)'::geometry);
 st_isclosed
-------------
 t
(1 row)

postgis=# SELECT ST_IsClosed('MULTILINESTRING((0 0, 0 1, 1 1, 0 0),(0 0, 1 1))'::geometry);
 st_isclosed
-------------
 f
(1 row)

postgis=# SELECT ST_IsClosed('POINT(0 0)'::geometry);
 st_isclosed
-------------
 t
(1 row)

postgis=# SELECT ST_IsClosed('MULTIPOINT((0 0), (1 1))'::geometry);
 st_isclosed
-------------
 t
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_IsRing" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_IsEmpty">
	  <refnamediv>
		<refname>ST_IsEmpty</refname>

		<refpurpose>Returns true if this Geometry is an empty geometry . If
				true, then this Geometry represents the empty point set - i.e.
				GEOMETRYCOLLECTION(EMPTY).</refpurpose>

	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_IsEmpty</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns true if this Geometry is an empty geometry . If
				true, then this Geometry represents an empty geometry collection, polygon, point etc.</para>
		<note>
			<para>SQL-MM defines the result of ST_IsEmpty(NULL) to be 0, while
			PostGIS returns NULL.</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink> OGC SPEC s2.1.1.1</para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.7</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
SELECT ST_IsEmpty('GEOMETRYCOLLECTION(EMPTY)');
 st_isempty
------------
 t
(1 row)

 SELECT ST_IsEmpty(ST_GeomFromText('POLYGON EMPTY'));
 st_isempty
------------
 t
(1 row)

SELECT ST_IsEmpty(ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))'));

 st_isempty
------------
 f
(1 row)

 SELECT ST_IsEmpty(ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))')) = false;
 ?column?
----------
 t
(1 row)

 SELECT ST_IsEmpty(ST_GeomFromText('CIRCULARSTRING EMPTY'));
  st_isempty
------------
 t
(1 row)


		</programlisting>
	  </refsection>

	</refentry>

  <refentry id="ST_IsRing">
	<refnamediv>
	  <refname>ST_IsRing</refname>

	  <refpurpose>Returns <varname>TRUE</varname> if this
	  <varname>LINESTRING</varname> is both closed and simple.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
		<funcprototype>
		  <funcdef>boolean <function>ST_IsRing</function></funcdef>

		  <paramdef><type>geometry </type> <parameter>g</parameter></paramdef>
		</funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsection>
	  <title>Description</title>

	  <para>Returns <varname>TRUE</varname> if this
	  <varname>LINESTRING</varname> is both <xref linkend="ST_IsClosed" />
	  (<function>ST_StartPoint(<parameter>g</parameter>)</function>
	  <function>~=</function>
	  <function>ST_Endpoint(<parameter>g</parameter>)</function>) and <xref
	  linkend="ST_IsSimple" /> (does not self intersect).</para>

	  <para><inlinemediaobject>
		  <imageobject>
			<imagedata fileref="images/check.png" />
		  </imageobject>
		</inlinemediaobject> This method implements the <ulink
	  url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
	  Implementation Specification for SQL.</ulink> OGC SFSQL 1.1 -
	  2.1.5.1</para>

	  <para><inlinemediaobject>
		  <imageobject>
			<imagedata fileref="images/check.png" />
		  </imageobject>
		</inlinemediaobject> This method implements the SQL/MM specification:
	  SQL-MM 3: 7.1.6</para>

	  <note>
		<para>SQL-MM defines the result of
		<function>ST_IsRing(<varname>NULL</varname>)</function> to be 0, while
		PostGIS returns <varname>NULL</varname>.</para>
	  </note>
	</refsection>

	<refsection>
	  <title>Examples</title>

	  <programlisting>SELECT ST_IsRing(the_geom), ST_IsClosed(the_geom), ST_IsSimple(the_geom)
FROM (SELECT 'LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry AS the_geom) AS foo;
 st_isring | st_isclosed | st_issimple
-----------+-------------+-------------
 t         | t           | t
(1 row)

SELECT ST_IsRing(the_geom), ST_IsClosed(the_geom), ST_IsSimple(the_geom)
FROM (SELECT 'LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry AS the_geom) AS foo;
 st_isring | st_isclosed | st_issimple
-----------+-------------+-------------
 f         | t           | f
(1 row)</programlisting>
	</refsection>

	<refsection>
	  <title>See Also</title>

	  <para><xref linkend="ST_IsClosed" />, <xref linkend="ST_IsSimple" />, <xref linkend="ST_StartPoint" />,
	  <xref linkend="ST_EndPoint" /></para>
	</refsection>
  </refentry>


  <refentry id="ST_IsSimple">
	  <refnamediv>
		<refname>ST_IsSimple</refname>

		<refpurpose>Returns (TRUE) if this Geometry has no anomalous geometric
				points, such as self intersection or self tangency.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_IsSimple</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns true if this Geometry has no anomalous geometric
				points, such as self intersection or self tangency. For more
			information on the OGC's definition of geometry simplicity and validity, refer
			to <link linkend="OGC_Validity">"Ensuring OpenGIS compliancy of geometries"</link></para>

		<note>
			<para>SQL-MM defines the result of ST_IsSimple(NULL) to be 0,
			while PostGIS returns NULL.</para>
		</note>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink> OGC SPEC s2.1.1.1</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.8</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting> SELECT ST_IsSimple(ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))'));
 st_issimple
-------------
 t
(1 row)

 SELECT ST_IsSimple(ST_GeomFromText('LINESTRING(1 1,2 2,2 3.5,1 3,1 2,2 1)'));
 st_issimple
-------------
 f
(1 row)</programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_IsValid" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_IsValid">
	  <refnamediv>
		<refname>ST_IsValid</refname>

		<refpurpose>Returns <varname>true</varname> if the
		<varname>ST_Geometry</varname> is well formed.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_IsValid</function></funcdef>

			<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Test if an ST_Geometry value is well formed.  For geometries that are invalid,
			the PostgreSQL NOTICE will provide details of why it is not valid.  For more
			information on the OGC's definition of geometry simplicity and validity, refer
			to <link linkend="OGC_Validity">"Ensuring OpenGIS compliancy of geometries"</link></para>
		<note>
			<para>SQL-MM defines the result of ST_IsValid(NULL) to be 0, while
			PostGIS returns NULL.</para>
		</note>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the concept of validity expressed in the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.9</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_IsValid(ST_GeomFromText('LINESTRING(0 0, 1 1)')) As good_line,
	ST_IsValid(ST_GeomFromText('POLYGON((0 0, 1 1, 1 2, 1 1, 0 0))')) As bad_poly
--results
NOTICE:  Self-intersection at or near point 0 0
 good_line | bad_poly
-----------+----------
 t         | f
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_IsSimple" />, <xref linkend="ST_IsValidReason" />, <xref linkend="ST_Summary" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_IsValidReason">
	  <refnamediv>
		<refname>ST_IsValidReason</refname>

		<refpurpose>Returns text stating if a geometry is valid or not and if not valid, a reason why.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>ST_IsValidReason</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns text stating if a geometry is valid or not an if not valid, a reason why.</para>

		<para>Useful in combination with ST_IsValid to generate a detailed report of invalid geometries and reasons.</para>
		<para>Availability: 1.4 - requires GEOS &gt;= 3.1.0.</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--First 3 Rejects from a successful quintuplet experiment
SELECT gid, ST_IsValidReason(the_geom) as validity_info
FROM
(SELECT ST_MakePolygon(ST_ExteriorRing(e.buff), ST_Accum(f.line)) As the_geom, gid
FROM (SELECT ST_Buffer(ST_MakePoint(x1*10,y1), z1) As buff, x1*10 + y1*100 + z1*1000 As gid
	FROM generate_series(-4,6) x1
	CROSS JOIN generate_series(2,5) y1
	CROSS JOIN generate_series(1,8) z1
	WHERE x1 &gt; y1*0.5 AND z1 &lt; x1*y1) As e
	INNER JOIN (SELECT ST_Translate(ST_ExteriorRing(ST_Buffer(ST_MakePoint(x1*10,y1), z1)),y1*1, z1*2) As line
	FROM generate_series(-3,6) x1
	CROSS JOIN generate_series(2,5) y1
	CROSS JOIN generate_series(1,10) z1
	WHERE x1 &gt; y1*0.75 AND z1 &lt; x1*y1) As f
ON (ST_Area(e.buff) &gt; 78 AND ST_Contains(e.buff, f.line))
GROUP BY gid, e.buff) As quintuplet_experiment
WHERE ST_IsValid(the_geom) = false
ORDER BY gid
LIMIT 3;

 gid  |      validity_info
------+--------------------------
 5330 | Self-intersection [32 5]
 5340 | Self-intersection [42 5]
 5350 | Self-intersection [52 5]

 --simple example
SELECT ST_IsValidReason('LINESTRING(220227 150406,2220227 150407,222020 150410)');

 st_isvalidreason
------------------
 Valid Geometry

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_IsValid" />, <xref linkend="ST_Summary" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_M">
	  <refnamediv>
		<refname>ST_M</refname>

		<refpurpose>Return the M coordinate of the point, or NULL if not
			available. Input must be a point.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_M</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the M coordinate of the point, or NULL if not
			available. Input must be a point.</para>

		<note>
			  <para>This is not (yet) part of the OGC spec, but is listed here
			  to complete the point coordinate extractor function list.</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3 New standard: ?</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_M(ST_GeomFromEWKT('POINT(1 2 3 4)'));
 st_m
------
	4
(1 row)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_X" />, <xref linkend="ST_Y" />, <xref linkend="ST_Z" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_NDims">
		<refnamediv>
			<refname>ST_NDims</refname>
			<refpurpose>Returns coordinate dimension of the geometry as a small int.
			Values are: 2,3 or 4.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_NDims</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns the coordinate dimension of the geometry.  PostGIS supports 2 -  (x,y) ,
			3 -  (x,y,z) or 2D with measure - x,y,m, and 4 - 3D with measure space x,y,z,m</para>

			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_NDims(ST_GeomFromText('POINT(1 1)')) As d2point,
	ST_NDims(ST_GeomFromEWKT('POINT(1 1 2)')) As d3point,
	ST_NDims(ST_GeomFromEWKT('POINTM(1 1 0.5)')) As d2pointm;

	 d2point | d3point | d2pointm
---------+---------+----------
	   2 |       3 |        3
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_CoordDim" />, <xref linkend="ST_Dimension" />, <xref linkend="ST_GeomFromEWKT" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_NPoints">
		<refnamediv>
			<refname>ST_NPoints</refname>
			<refpurpose>Return the number of points (vertexes) in a geometry.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_NPoints</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Return the number of points in a geometry.  Works for all geometries.</para>
			<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>
						<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		  <!-- Optionally mention Circular String Support -->
		 <para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>


		</refsection>

		<refsection>
			<title>Examples</title>

<programlisting>SELECT ST_NPoints(ST_GeomFromText('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)'));
--result
4

--Polygon in 3D space
SELECT ST_NPoints(ST_GeomFromEWKT('LINESTRING(77.29 29.07 1,77.42 29.26 0,77.27 29.31 -1,77.29 29.07 3)'))
--result
4</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_NumPoints" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_NRings">
	  <refnamediv>
		<refname>ST_NRings</refname>
		<refpurpose>If the geometry is a polygon or multi-polygon returns the number of rings.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_NRings</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>If the geometry is a polygon or multi-polygon returns the number of rings.  Unlike NumInteriorRings, it counts
		the outer rings as well.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

	<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_NRings(the_geom) As Nrings, ST_NumInteriorRings(the_geom) As ninterrings
					FROM (SELECT ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))') As the_geom) As foo;
	 nrings | ninterrings
--------+-------------
	  1 |           0
(1 row)
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_NumInteriorRings" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_NumGeometries">
		<refnamediv>
			<refname>ST_NumGeometries</refname>
			<refpurpose>If geometry is a GEOMETRYCOLLECTION (or MULTI*) return the
			number of geometries, otherwise return NULL.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_NumGeometries</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_multi_or_geomcollection</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns the number of Geometries. If geometry is a GEOMETRYCOLLECTION (or MULTI*) return the
			number of geometries, otherwise return NULL.</para>

				<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 9.1.4</para>

		</refsection>

		<refsection>
			<title>Examples</title>

<programlisting>
--Although ST_NumGeometries will return null when passed a single, you can wrap in ST_Multi to force 1 or more for all geoms
SELECT ST_NumGeometries(ST_Multi(ST_GeomFromText('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)')));
--result
1

--Geometry Collection Example - multis count as one geom in a collection
SELECT ST_NumGeometries(ST_GeomFromEWKT('GEOMETRYCOLLECTION(MULTIPOINT(-2 3 , -2 2),
LINESTRING(5 5 ,10 10),
POLYGON((-7 4.2,-7.1 5,-7.1 4.3,-7 4.2)))'));
--result
3
</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_GeometryN" />, <xref linkend="ST_Multi" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_NumInteriorRings">
	  <refnamediv>
		<refname>ST_NumInteriorRings</refname>
		<refpurpose>Return the number of interior rings of the first polygon in
			the geometry. This will work with both POLYGON and MULTIPOLYGON types but only looks at the first polygon.
			Return NULL if there is no polygon in the
			geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_NumInteriorRings</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_polygon</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the number of interior rings of the first polygon in
			the geometry. This will work with both POLYGON and MULTIPOLYGON types but only looks at the first polygon.
			Return NULL if there is no polygon in the
			geometry.</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 8.2.5</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

			<programlisting>
--If you have a regular polygon
SELECT gid, field1, field2, ST_NumInteriorRings(the_geom) AS numholes
FROM sometable;

--If you have multipolygons
--And you want to know the total number of interior rings in the MULTIPOLYGON
SELECT gid, field1, field2, SUM(ST_NumInteriorRings(the_geom)) AS numholes
FROM (SELECT gid, field1, field2, (ST_Dump(the_geom)).geom As the_geom
	FROM sometable) As foo
GROUP BY gid, field1,field2;
			</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_NumInteriorRing" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_NumInteriorRing">
	  <refnamediv>
		<refname>ST_NumInteriorRing</refname>
		<refpurpose>Return the number of interior rings of the first polygon in
			the geometry. Synonym to ST_NumInteriorRings. </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_NumInteriorRing</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_polygon</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the number of interior rings of the first polygon in
			the geometry. Synonym to ST_NumInteriorRings. The OpenGIS specs are
			ambiguous about the exact function naming, so we provide both
			spellings.</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 8.2.5</para>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_NumInteriorRings" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_NumPoints">
	  <refnamediv>
		<refname>ST_NumPoints</refname>
		<refpurpose>Return the number of points in an ST_LineString or
		  ST_CircularString value.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_NumPoints</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the number of points in an ST_LineString or
		  ST_CircularString value. Prior to 1.4 only works with Linestrings as the specs state.  From 1.4 forward this is an alias for ST_NPoints which returns number of vertexes for
		  not just line strings.
		  Consider using ST_NPoints instead which is multi-purpose
		  and works with many geometry types.</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 7.2.4</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_NumPoints(ST_GeomFromText('LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)'));
		--result
		4
		</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_NPoints" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_PointN">
	  <refnamediv>
		<refname>ST_PointN</refname>

		<refpurpose>Return the Nth point in the first linestring or circular linestring in the
			geometry. Return NULL if there is no linestring in the
			geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_PointN</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>n</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the Nth point in the first linestring or circular linestring in the
			geometry. Return NULL if there is no linestring in the
			geometry.</para>

		<note>
			  <para>Index is 1-based as for OGC specs since version 0.8.0.
			  Previous versions implemented this as 0-based instead.</para>
		</note>

		<note>
			  <para>If you want to get the nth point of each line string in a multilinestring, use in conjunction
			  with ST_Dump</para>
		</note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 7.2.5, 7.3.5</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		  <!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>-- Extract all POINTs from a LINESTRING
SELECT ST_AsText(
   ST_PointN(
	  column1,
	  generate_series(1, ST_NPoints(column1))
   ))
FROM ( VALUES ('LINESTRING(0 0, 1 1, 2 2)'::geometry) ) AS foo;

 st_astext
------------
 POINT(0 0)
 POINT(1 1)
 POINT(2 2)
(3 rows)

--Example circular string
SELECT ST_AsText(ST_PointN(ST_GeomFromText('CIRCULARSTRING(1 2, 3 2, 1 2)'),2));

st_astext
----------
POINT(3 2)
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_NPoints" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_SRID">
	  <refnamediv>
		<refname>ST_SRID</refname>
		<refpurpose>Returns the spatial reference identifier for the ST_Geometry as defined in spatial_ref_sys table.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_SRID</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the spatial reference identifier for the ST_Geometry as defined in <xref linkend="spatial_ref_sys">spatial_ref_sys</xref> table. </para>
		<para><note><para>spatial_ref_sys
		table is a table that catalogs all spatial reference systems known to PostGIS and is used for transformations from one spatial
			reference system to another.  So verifying you have the right spatial reference system identifier is important if you plan to ever transform your geometries.</para></note></para>
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink>
		OGC SPEC s2.1.1.1</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.5</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_SRID(ST_GeomFromText('POINT(-71.1043 42.315)',4326));
		--result
		4326
		</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="spatial_ref_sys" />,<xref linkend="ST_GeomFromText" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_Transform" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_StartPoint">
	<refnamediv>
	  <refname>ST_StartPoint</refname>

	  <refpurpose>Returns the first point of a <varname>LINESTRING</varname>
	  geometry as a <varname>POINT</varname>.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
		<funcprototype>
		  <funcdef>geometry <function>ST_StartPoint</function></funcdef>

		  <paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		</funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsection>
	  <title>Description</title>

	  <para>Returns the first point of a <varname>LINESTRING</varname> geometry
	  as a <varname>POINT</varname> or <varname>NULL</varname> if the input
	  parameter is not a <varname>LINESTRING</varname>.</para>

	  <para><inlinemediaobject>
		  <imageobject>
			<imagedata fileref="images/check.png" />
		  </imageobject>
		</inlinemediaobject> This method implements the SQL/MM specification:
	  SQL-MM 3: 7.1.3</para>

		<!-- Optionally mention 3d support -->
		<para>
			<inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
			</inlinemediaobject> This function supports 3d and will not drop the z-index.
		</para>
	</refsection>

	<refsection>
	  <title>Examples</title>

	  <programlisting>SELECT ST_AsText(ST_StartPoint('LINESTRING(0 1, 0 2)'::geometry));
 st_astext
------------
 POINT(0 1)
(1 row)

SELECT ST_StartPoint('POINT(0 1)'::geometry) IS NULL AS is_null;
  is_null
----------
 t
(1 row)

--3d line
SELECT ST_AsEWKT(ST_StartPoint('LINESTRING(0 1 1, 0 2 2)'::geometry));
 st_asewkt
------------
 POINT(0 1 1)
(1 row)

</programlisting>
	</refsection>

	<refsection>
	  <title>See Also</title>

	  <para><xref linkend="ST_EndPoint" />, <xref linkend="ST_PointN" /></para>
	</refsection>
  </refentry>
	<refentry id="ST_Summary">
	  <refnamediv>
		<refname>ST_Summary</refname>

		<refpurpose>Returns a text summary of the contents of the
		<varname>ST_Geometry</varname>.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>ST_Summary</function></funcdef>

			<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a text summary of the contents of the geometry.</para>
		<!-- Optionally mention 3d support -->
		<para>
			<inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
			</inlinemediaobject> This function supports 3d and will not drop the z-index.
		</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)')) As good_line,
	ST_Summary(ST_GeomFromText('POLYGON((0 0, 1 1, 1 2, 1 1, 0 0))')) As bad_poly
--results
	  good_line       |        bad_poly
----------------------+-------------------------
					  |
Line[B] with 2 points : Polygon[B] with 1 rings
					  :    ring 0 has 5 points
					  :

--3d polygon
SELECT ST_Summary(ST_GeomFromEWKT('LINESTRING(0 0 1, 1 1 1)')) As good_line,
	ST_Summary(ST_GeomFromEWKT('POLYGON((0 0 1, 1 1 2, 1 2 3, 1 1 1, 0 0 1))')) As poly

--results
	  good_line       |        poly
----------------------+-------------------------
					  |
Line[ZB] with 2 points : Polygon[ZB] with 1 rings
					  :    ring 0 has 5 points
					  :

</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_IsValid" />, <xref linkend="ST_IsValidReason" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_X">
	  <refnamediv>
		<refname>ST_X</refname>

		<refpurpose>Return the X coordinate of the point, or NULL if not
			available. Input must be a point.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_X</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the X coordinate of the point, or NULL if not
			available. Input must be a point.</para>

		<note><para>If you want to get the max min x values of any geometry look at ST_XMin, ST_XMax functions.</para></note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3 standard: SQL-MM 3: 6.1.3</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_X(ST_GeomFromEWKT('POINT(1 2 3 4)'));
 st_x
------
	1
(1 row)

SELECT ST_Y(ST_Centroid(ST_GeomFromEWKT('LINESTRING(1 2 3 4, 1 1 1 1)')));
 st_y
------
  1.5
(1 row)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Centroid" />, <xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_M" />, <xref linkend="ST_XMax" />, <xref linkend="ST_XMin" />, <xref linkend="ST_Y" />, <xref linkend="ST_Z" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Y">
	  <refnamediv>
		<refname>ST_Y</refname>

		<refpurpose>Return the Y coordinate of the point, or NULL if not
			available. Input must be a point.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Y</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the Y coordinate of the point, or NULL if not
			available. Input must be a point.</para>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3 standard: SQL-MM 3: 6.1.4</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_Y(ST_GeomFromEWKT('POINT(1 2 3 4)'));
 st_y
------
	2
(1 row)

SELECT ST_Y(ST_Centroid(ST_GeomFromEWKT('LINESTRING(1 2 3 4, 1 1 1 1)')));
 st_y
------
  1.5
(1 row)


		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Centroid" />, <xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_M" />, <xref linkend="ST_X" />, <xref linkend="ST_YMax" />, <xref linkend="ST_YMin" />, <xref linkend="ST_Z" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Z">
	  <refnamediv>
		<refname>ST_Z</refname>

		<refpurpose>Return the Z coordinate of the point, or NULL if not
			available. Input must be a point.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Z</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the Z coordinate of the point, or NULL if not
			available. Input must be a point.</para>



		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3 standard New Spec: ?</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_Z(ST_GeomFromEWKT('POINT(1 2 3 4)'));
 st_z
------
	3
(1 row)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_M" />, <xref linkend="ST_X" />, <xref linkend="ST_Y" />, <xref linkend="ST_ZMax" />, <xref linkend="ST_ZMin" /> </para>
	  </refsection>
	</refentry>

	<refentry id="ST_Zmflag">
	  <refnamediv>
		<refname>ST_Zmflag</refname>

		<refpurpose>Returns ZM (dimension semantic) flag of the geometries as a
			small int. Values are: 0=2d, 1=3dm, 2=3dz, 3=4d.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>smallint <function>ST_Zmflag</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns ZM (dimension semantic) flag of the geometries as a
			small int. Values are: 0=2d, 1=3dm, 2=3dz, 3=4d.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

	<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRING(1 2, 3 4)'));
 st_zmflag
-----------
		 0

SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGM(1 2 3, 3 4 3)'));
 st_zmflag
-----------
		 1

SELECT ST_Zmflag(ST_GeomFromEWKT('CIRCULARSTRING(1 2 3, 3 4 3, 5 6 3)'));
 st_zmflag
-----------
		 2
SELECT ST_Zmflag(ST_GeomFromEWKT('POINT(1 2 3 4)'));
 st_zmflag
-----------
		 3
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_CoordDim" />, <xref linkend="ST_NDims" />, <xref linkend="ST_Dimension" /></para>
	  </refsection>
	</refentry>


  </sect1>

  <sect1 id="Geometry_Editors">
	  <title>Geometry Editors</title>

		<refentry id="ST_AddPoint">
		  <refnamediv>
			<refname>ST_AddPoint</refname>
			<refpurpose>Adds a point to a LineString before point &lt;position&gt;
				(0-based index).</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_AddPoint</function></funcdef>
				<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>point</parameter></paramdef>
			  </funcprototype>
			 </funcsynopsis>
			 <funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_AddPoint</function></funcdef>
				<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>point</parameter></paramdef>
				<paramdef><type>integer</type> <parameter>position</parameter></paramdef>
			  </funcprototype>
			 </funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Adds a point to a LineString before point &lt;position&gt;
				(0-based index). Third parameter can be omitted or set to -1 for
				appending.</para>
			<para>Availability: 1.1.0</para>
			<!-- Optionally mention 3d support -->
			<para>
				<inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
				</inlinemediaobject> This function supports 3d and will not drop the z-index.
			</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<programlisting>
		--guarantee all linestrings in a table are closed
		--by adding the start point of each linestring to the end of the line string
		--only for those that are not closed
		UPDATE sometable
		SET the_geom = ST_AddPoint(the_geom, ST_StartPoint(the_geom))
		FROM sometable
		WHERE ST_IsClosed(the_geom) = false;

		--Adding point to a 3-d line
		SELECT ST_AsEWKT(ST_AddPoint(ST_GeomFromEWKT('LINESTRING(0 0 1, 1 1 1)'), ST_MakePoint(1, 2, 3)));

		--result
		st_asewkt
		----------
		LINESTRING(0 0 1,1 1 1,1 2 3)
			</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_RemovePoint"/>, <xref linkend="ST_SetPoint" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_Affine">
	  <refnamediv>
		<refname>ST_Affine</refname>

		<refpurpose>Applies a 3d affine transformation to the geometry to do things like translate, rotate, scale in one step.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Affine</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>a</parameter></paramdef>
			<paramdef><type>float </type> <parameter>b</parameter></paramdef>
			<paramdef><type>float </type> <parameter>c</parameter></paramdef>
			<paramdef><type>float </type> <parameter>d</parameter></paramdef>
			<paramdef><type>float </type> <parameter>e</parameter></paramdef>
			<paramdef><type>float </type> <parameter>f</parameter></paramdef>
			<paramdef><type>float </type> <parameter>g</parameter></paramdef>
			<paramdef><type>float </type> <parameter>h</parameter></paramdef>
			<paramdef><type>float </type> <parameter>i</parameter></paramdef>
			<paramdef><type>float </type> <parameter>xoff</parameter></paramdef>
			<paramdef><type>float </type> <parameter>yoff</parameter></paramdef>
			<paramdef><type>float </type> <parameter>zoff</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Affine</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>a</parameter></paramdef>
			<paramdef><type>float </type> <parameter>b</parameter></paramdef>
			<paramdef><type>float </type> <parameter>d</parameter></paramdef>
			<paramdef><type>float </type> <parameter>e</parameter></paramdef>>
			<paramdef><type>float </type> <parameter>xoff</parameter></paramdef>
			<paramdef><type>float </type> <parameter>yoff</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Applies a 3d affine transformation to the geometry to do things like translate, rotate, scale in one step.</para>
		<para>
		Version 1: The
			call <programlisting>ST_Affine(geom, a, b, c, d, e, f, g, h, i, xoff, yoff, zoff) </programlisting>
			represents the transformation matrix <programlisting>/ a  b  c  xoff \
| d  e  f  yoff |
| g  h  i  zoff |
\ 0  0  0     1 /</programlisting> and the vertices are transformed as
			follows: <programlisting>x' = a*x + b*y + c*z + xoff
y' = d*x + e*y + f*z + yoff
z' = g*x + h*y + i*z + zoff</programlisting> All of the translate / scale
			functions below are expressed via such an affine
			transformation.</para>
		<para>Version 2: Applies a 2d affine transformation to the geometry. The
			call <programlisting>ST_Affine(geom, a, b, d, e, xoff, yoff)</programlisting>
			represents the transformation matrix <programlisting>/  a  b  0  xoff  \       /  a  b  xoff  \
|  d  e  0  yoff  | rsp.  |  d  e  yoff  |
|  0  0  1     0  |       \  0  0     1  /
\  0  0  0     1  /</programlisting> and the vertices are transformed as
			follows: <programlisting>x' = a*x + b*y + xoff
y' = d*x + e*y + yoff
z' = z </programlisting> This method is a subcase of the 3D method
			above.</para>

		<para>Availability: 1.1.2. Name changed from Affine to ST_Affine in 1.2.2</para>
		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a 3d line 180 degrees about the z axis.  Note this is long-hand for doing ST_RotateZ();
 SELECT ST_AsEWKT(ST_Affine(the_geom,  cos(pi()), -sin(pi()), 0,  sin(pi()), cos(pi()), 0,  0, 0, 1,  0, 0, 0)) As using_affine,
	 ST_AsEWKT(ST_RotateZ(the_geom, pi())) As using_rotatez
	FROM (SELECT ST_GeomFromEWKT('LINESTRING(1 2 3, 1 4 3)') As the_geom) As foo;
		using_affine         |        using_rotatez
-----------------------------+-----------------------------
 LINESTRING(-1 -2 3,-1 -4 3) | LINESTRING(-1 -2 3,-1 -4 3)
(1 row)

--Rotate a 3d line 180 degrees in both the x and z axis
SELECT ST_AsEWKT(ST_Affine(the_geom, cos(pi()), -sin(pi()), 0, sin(pi()), cos(pi()), -sin(pi()), 0, sin(pi()), cos(pi()), 0, 0, 0))
	FROM (SELECT ST_GeomFromEWKT('LINESTRING(1 2 3, 1 4 3)') As the_geom) As foo;
		   st_asewkt
-------------------------------
 LINESTRING(-1 -2 -3,-1 -4 -3)
(1 row)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Rotate" />, <xref linkend="ST_Scale" />, <xref linkend="ST_Translate" />, <xref linkend="ST_TransScale" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_2D">
	  <refnamediv>
		<refname>ST_Force_2D</refname>

		<refpurpose>Forces the geometries into a "2-dimensional mode" so that
		all output representations will only have the X and Y coordinates.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force_2D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into a "2-dimensional mode" so that
		all output representations will only have the X and Y coordinates.
		This is useful for force OGC-compliant output (since OGC only
		specifies 2-D geometries).</para>


	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsEWKT(ST_Force_2D(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
		st_asewkt
-------------------------------------
CIRCULARSTRING(1 1,2 3,4 5,6 7,5 6)

SELECT  ST_AsEWKT(ST_Force_2D('POLYGON((0 0 2,0 5 2,5 0 2,0 0 2),(1 1 2,3 1 2,1 3 2,1 1 2))'));

				  st_asewkt
----------------------------------------------
 POLYGON((0 0,0 5,5 0,0 0),(1 1,3 1,1 3,1 1))

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Force_3D"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_3D">
	  <refnamediv>
		<refname>ST_Force_3D</refname>

		<refpurpose>Forces the geometries into XYZ mode.  This is an alias for ST_Force_3DZ.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force_3D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYZ mode.  This is an alias for ST_Force_3DZ. If a geometry has no Z component, then a 0 Z coordinate is tacked on.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
		--Nothing happens to an already 3D geometry
		SELECT ST_AsEWKT(ST_Force_3D(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
				   st_asewkt
-----------------------------------------------
 CIRCULARSTRING(1 1 2,2 3 2,4 5 2,6 7 2,5 6 2)


SELECT  ST_AsEWKT(ST_Force_3D('POLYGON((0 0,0 5,5 0,0 0),(1 1,3 1,1 3,1 1))'));

						 st_asewkt
--------------------------------------------------------------
 POLYGON((0 0 0,0 5 0,5 0 0,0 0 0),(1 1 0,3 1 0,1 3 0,1 1 0))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>, <xref linkend="ST_Force_2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3DZ"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_3DZ">
	  <refnamediv>
		<refname>ST_Force_3DZ</refname>

		<refpurpose>Forces the geometries into XYZ mode.  This is a synonym for ST_Force_3D.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force_3DZ</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYZ mode.  This is a synonym for ST_Force_3DZ. If a geometry has no Z component, then a 0 Z coordinate is tacked on.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Nothing happens to an already 3D geometry
SELECT ST_AsEWKT(ST_Force_3DZ(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
				   st_asewkt
-----------------------------------------------
 CIRCULARSTRING(1 1 2,2 3 2,4 5 2,6 7 2,5 6 2)


SELECT  ST_AsEWKT(ST_Force_3DZ('POLYGON((0 0,0 5,5 0,0 0),(1 1,3 1,1 3,1 1))'));

						 st_asewkt
--------------------------------------------------------------
 POLYGON((0 0 0,0 5 0,5 0 0,0 0 0),(1 1 0,3 1 0,1 3 0,1 1 0))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>, <xref linkend="ST_Force_2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_3DM">
	  <refnamediv>
		<refname>ST_Force_3DM</refname>

		<refpurpose>Forces the geometries into XYM mode.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force_3DM</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYM mode.  If a geometry has no M component, then a 0 M coordinate is tacked on.  If it has a Z component, then Z is removed</para>


	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Nothing happens to an already 3D geometry
SELECT ST_AsEWKT(ST_Force_3DM(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
				   st_asewkt
------------------------------------------------
 CIRCULARSTRINGM(1 1 0,2 3 0,4 5 0,6 7 0,5 6 0)


SELECT  ST_AsEWKT(ST_Force_3DM('POLYGON((0 0 1,0 5 1,5 0 1,0 0 1),(1 1 1,3 1 1,1 3 1,1 1 1))'));

						  st_asewkt
---------------------------------------------------------------
 POLYGONM((0 0 0,0 5 0,5 0 0,0 0 0),(1 1 0,3 1 0,1 3 0,1 1 0))

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>,  <xref linkend="ST_Force_2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/>, <xref linkend="ST_GeomFromEWKT"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_4D">
	  <refnamediv>
		<refname>ST_Force_4D</refname>

		<refpurpose>Forces the geometries into XYZM mode.  </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force_4D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYZM mode.  0 is tacked on for missing Z and M dimensions. </para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Nothing happens to an already 3D geometry
SELECT ST_AsEWKT(ST_Force_4D(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
						st_asewkt
---------------------------------------------------------
 CIRCULARSTRING(1 1 2 0,2 3 2 0,4 5 2 0,6 7 2 0,5 6 2 0)



SELECT  ST_AsEWKT(ST_Force_4D('MULTILINESTRINGM((0 0 1,0 5 2,5 0 3,0 0 4),(1 1 1,3 1 1,1 3 1,1 1 1))'));

									  st_asewkt
--------------------------------------------------------------------------------------
 MULTILINESTRING((0 0 0 1,0 5 0 2,5 0 0 3,0 0 0 4),(1 1 0 1,3 1 0 1,1 3 0 1,1 1 0 1))

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>, <xref linkend="ST_Force_2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_Collection">
	  <refnamediv>
		<refname>ST_Force_Collection</refname>

		<refpurpose>Converts the geometry into a GEOMETRYCOLLECTION.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force_Collection</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converts the geometry into a GEOMETRYCOLLECTION. This is
			useful for simplifying the WKB representation.</para>

		<para>Availability: 1.2.2, prior to 1.3.4 this function will crash with Curves.  This is fixed in 1.3.4+</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>

SELECT  ST_AsEWKT(ST_Force_Collection('POLYGON((0 0 1,0 5 1,5 0 1,0 0 1),(1 1 1,3 1 1,1 3 1,1 1 1))'));

								   st_asewkt
----------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(POLYGON((0 0 1,0 5 1,5 0 1,0 0 1),(1 1 1,3 1 1,1 3 1,1 1 1)))


  SELECT ST_AsText(ST_Force_Collection('CIRCULARSTRING(220227 150406,2220227 150407,220227 150406)'));
								   st_astext
--------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(CIRCULARSTRING(220227 150406,2220227 150407,220227 150406))
(1 row)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>,  <xref linkend="ST_Force_2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/>, <xref linkend="ST_GeomFromEWKT"/></para>
	  </refsection>
	</refentry>


	<refentry id="ST_ForceRHR">
		<refnamediv>
			<refname>ST_ForceRHR</refname>

			<refpurpose>Forces the orientation of the vertices in a polygon to follow the
				Right-Hand-Rule.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>boolean
						<function>ST_ForceRHR</function></funcdef>
						<paramdef><type>geometry</type> <parameter>g</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Forces the orientation of the vertices in a polygon to follow the
				Right-Hand-Rule. In GIS terminology, this means that the area that is bounded by the
				polygon is to the right of the boundary. In particular, the exterior ring is
				orientated in a clockwise direction and the interior rings in a counter-clockwise
				direction.</para>

			<para><inlinemediaobject>
				<imageobject>
					<imagedata fileref="images/check.png"/>
				</imageobject>
				</inlinemediaobject>This function supports 3d in that it will not drop the
				z-index.</para>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsEWKT(
  ST_ForceRHR(
	'POLYGON((0 0 2, 5 0 2, 0 5 2, 0 0 2),(1 1 2, 1 3 2, 3 1 2, 1 1 2))'
  )
);
						  st_asewkt
--------------------------------------------------------------
 POLYGON((0 0 2,0 5 2,5 0 2,0 0 2),(1 1 2,3 1 2,1 3 2,1 1 2))
(1 row)</programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_BuildArea"/>,
				<xref linkend="ST_Polygonize"/>,
				<xref linkend="ST_Reverse"/></para>
		</refsection>
	</refentry>

	<refentry id="ST_LineMerge">
		<refnamediv>
			<refname>ST_LineMerge</refname>

			<refpurpose>Returns a (set of) LineString(s) formed by sewing together
			a MULTILINESTRING.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_LineMerge</function></funcdef>
				<paramdef><type>geometry </type> <parameter>amultilinestring</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns a (set of) LineString(s) formed by sewing together
			the constituent line work of a MULTILINESTRING. </para>
			<note><para>Only use with MULTILINESTRING/LINESTRINGs. If you feed a polygon or geometry collection into this function, it
			will return an empty GEOMETRYCOLLECTION</para></note>

			<para>Availability: 1.1.0</para>
			<note><para>requires GEOS &gt;= 2.1.0</para></note>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_LineMerge(
ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45 -33,-46 -32))')
		)
);
st_astext
--------------------------------------------------------------------------------------------------
LINESTRING(-29 -27,-30 -29.7,-36 -31,-45 -33,-46 -32)
(1 row)

--If can't be merged - original MULTILINESTRING is returned
SELECT ST_AsText(ST_LineMerge(
ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45.2 -33.2,-46 -32))')
)
);
st_astext
----------------
MULTILINESTRING((-45.2 -33.2,-46 -32),(-29 -27,-30 -29.7,-36 -31,-45 -33))
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Segmentize" />, <xref linkend="ST_Line_Substring" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_Multi">
		<refnamediv>
			<refname>ST_Multi</refname>

			<refpurpose>Returns the geometry as a MULTI* geometry. If the geometry
				is already a MULTI*, it is returned unchanged.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Multi</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns the geometry as a MULTI* geometry. If the geometry
				is already a MULTI*, it is returned unchanged.</para>

		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_Multi(ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,
			743265 2967450,743265.625 2967416,743238 2967416))')));
			st_astext
			--------------------------------------------------------------------------------------------------
			MULTIPOLYGON(((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,
			743238 2967416)))
			(1 row)
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsText" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_RemovePoint">
	  <refnamediv>
		<refname>ST_RemovePoint</refname>
		<refpurpose>Removes point from a linestring. Offset is 0-based.</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RemovePoint</function></funcdef>
			<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
			<paramdef><type>integer</type> <parameter>offset</parameter></paramdef>
		  </funcprototype>
		 </funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Removes point from a linestring.  Useful for turning a closed ring into an open line string</para>
		<para>Availability: 1.1.0</para>
		<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
			</inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>
--guarantee no LINESTRINGS are closed
--by removing the end point.  The below assumes the_geom is of type LINESTRING
UPDATE sometable
	SET the_geom = ST_RemovePoint(the_geom, ST_NPoints(the_geom) - 1)
	FROM sometable
	WHERE ST_IsClosed(the_geom) = true;
		</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_AddPoint"/>, <xref linkend="ST_NPoints"/>, <xref linkend="ST_NumPoints"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Reverse">
	  <refnamediv>
		<refname>ST_Reverse</refname>
		<refpurpose>Returns the geometry with vertex order reversed.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Reverse</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		 </funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Can be used on any geometry and reverses the order of the vertexes.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>
SELECT ST_AsText(the_geom) as line, ST_AsText(ST_Reverse(the_geom)) As reverseline
FROM
(SELECT ST_MakeLine(ST_MakePoint(1,2),
		ST_MakePoint(1,10)) As the_geom) as foo;
--result
		line         |     reverseline
---------------------+----------------------
LINESTRING(1 2,1 10) | LINESTRING(1 10,1 2)
</programlisting>
	  </refsection>
	</refentry>

	<refentry id="ST_Rotate">
	  <refnamediv>
		<refname>ST_Rotate</refname>

		<refpurpose>This is a synonym for ST_RotateZ</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Rotate</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotZRadians</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>This is a synonym for ST_RotateZ..  Rotates geometry rotZRadians about the Z-axis.</para>

		<para>Availability: 1.1.2. Name changed from Rotate to ST_Rotate in 1.2.2</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

			<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting></programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateX" />, <xref linkend="ST_RotateY" />, <xref linkend="ST_RotateZ" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_RotateX">
	  <refnamediv>
		<refname>ST_RotateX</refname>

		<refpurpose>Rotate a geometry rotRadians about the X axis.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RotateX</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Rotate a geometry geomA - rotRadians about the X axis.</para>

		<note><para><code>ST_RotateX(geomA,  rotRadians)</code>
			is short-hand for <code>ST_Affine(geomA, 1, 0, 0, 0, cos(rotRadians), -sin(rotRadians), 0, sin(rotRadians), cos(rotRadians), 0, 0, 0)</code>.</para></note>

		<para>Availability: 1.1.2. Name changed from RotateX to ST_RotateX in 1.2.2</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a line 90 degrees along x-axis
SELECT ST_AsEWKT(ST_RotateX(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), pi()/2));
		 st_asewkt
---------------------------
 LINESTRING(1 -3 2,1 -1 1)
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateY" />, <xref linkend="ST_RotateZ" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_RotateY">
	  <refnamediv>
		<refname>ST_RotateY</refname>

		<refpurpose>Rotate a geometry rotRadians about the Y axis.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RotateY</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Rotate a geometry geomA - rotRadians about the y axis.</para>

		<note><para><code>ST_RotateY(geomA,  rotRadians)</code>
			is short-hand for <code>ST_Affine(geomA,  cos(rotRadians), 0, sin(rotRadians),  0, 1, 0,  -sin(rotRadians), 0, cos(rotRadians), 0,  0, 0)</code>.</para></note>

		<para>Availability: 1.1.2. Name changed from RotateY to ST_RotateY in 1.2.2</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a line 90 degrees along y-axis
 SELECT ST_AsEWKT(ST_RotateY(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), pi()/2));
		 st_asewkt
---------------------------
 LINESTRING(3 2 -1,1 1 -1)
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateX" />, <xref linkend="ST_RotateZ" />, <ulink
	  url="/support/wiki/index.php?plpgsqlfunctions">Rotate around Point, Create Ellipse functions</ulink></para>
	  </refsection>
	</refentry>

	<refentry id="ST_RotateZ">
	  <refnamediv>
		<refname>ST_RotateZ</refname>

		<refpurpose>Rotate a geometry rotRadians about the Z axis.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RotateZ</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Rotate a geometry geomA - rotRadians about the Z axis.</para>

		<note><para><code>ST_RotateZ(geomA,  rotRadians)</code>
			is short-hand for <code>SELECT ST_Affine(geomA,  cos(rotRadians), -sin(rotRadians), 0,  sin(rotRadians), cos(rotRadians), 0,  0, 0, 1,  0, 0, 0)</code>.</para></note>

		<para>Availability: 1.1.2. Name changed from RotateZ to ST_RotateZ in 1.2.2</para>
		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a line 90 degrees along z-axis
SELECT ST_AsEWKT(ST_RotateZ(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), pi()/2));
		 st_asewkt
---------------------------
 LINESTRING(-2 1 3,-1 1 1)

 --Rotate a curved circle around z-axis
SELECT ST_AsEWKT(ST_RotateZ(the_geom, pi()/2))
FROM (SELECT ST_LineToCurve(ST_Buffer(ST_GeomFromText('POINT(234 567)'), 3)) As the_geom) As foo;

													   st_asewkt
----------------------------------------------------------------------------------------------------------------------------
 CURVEPOLYGON(CIRCULARSTRING(-567 237,-564.87867965644 236.12132034356,-564 234,-569.12132034356 231.87867965644,-567 237))

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateX" />, <xref linkend="ST_RotateY" />, <ulink
	  url="/support/wiki/index.php?plpgsqlfunctions">Rotate around Point, Create Ellipse functions</ulink></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Scale">
	  <refnamediv>
		<refname>ST_Scale</refname>

		<refpurpose>Scales the geometry to a new size by multiplying the
			ordinates with the parameters. Ie: ST_Scale(geom, Xfactor, Yfactor,
			Zfactor).
			</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Scale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>XFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>YFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>ZFactor</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Scale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>XFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>YFactor</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Scales the geometry to a new size by multiplying the
			ordinates with the parameters. Ie: ST_Scale(geom, Xfactor, Yfactor,
			Zfactor).</para>

		<note><para><code>ST_Scale(geomA,  XFactor, YFactor, ZFactor)</code>
			is short-hand for <code>ST_Affine(geomA,  XFactor, 0, 0,  0, YFactor, 0,  0, 0, ZFactor,  0, 0, 0)</code>.</para></note>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>


		<para>Availability: 1.1.0.</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>--Version 1: scale X, Y, Z
SELECT ST_AsEWKT(ST_Scale(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), 0.5, 0.75, 0.8));
			  st_asewkt
--------------------------------------
 LINESTRING(0.5 1.5 2.4,0.5 0.75 0.8)

--Version 2: Scale X Y
 SELECT ST_AsEWKT(ST_Scale(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), 0.5, 0.75));
			st_asewkt
----------------------------------
 LINESTRING(0.5 1.5 3,0.5 0.75 1)


</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_TransScale" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Segmentize">
		<refnamediv>
			<refname>ST_Segmentize</refname>

			<refpurpose>Return a modified geometry having no segment longer than the
			given distance.  Distance computation is performed in 2d
			only.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Segmentize</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
				<paramdef><type>float </type> <parameter>max_length</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns a modified geometry having no segment longer than the
			given distance. Distance computation is performed in 2d
			only. </para>
			<para>Availability: 1.2.2</para>
			<note><para>This will only increase segments.  It will not lengthen segments shorter than
			max length</para></note>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_Segmentize(
ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45 -33,-46 -32))')
		,5)
);
st_astext
--------------------------------------------------------------------------------------------------
MULTILINESTRING((-29 -27,-30 -29.7,-34.886615700134 -30.758766735029,-36 -31,
-40.8809353009198 -32.0846522890933,-45 -33),
(-45 -33,-46 -32))
(1 row)

SELECT ST_AsText(ST_Segmentize(ST_GeomFromText('POLYGON((-29 28, -30 40, -29 28))'),10));
st_astext
-----------------------
POLYGON((-29 28,-29.8304547985374 37.9654575824488,-30 40,-29.1695452014626 30.0345424175512,-29 28))
(1 row)

			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Line_Substring" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_SetPoint">
		  <refnamediv>
			<refname>ST_SetPoint</refname>
			<refpurpose>Replace point N of linestring with given point. Index is
			0-based.</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			 <funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_SetPoint</function></funcdef>
				<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
				<paramdef><type>integer</type> <parameter>zerobasedposition</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>point</parameter></paramdef>
			  </funcprototype>
			 </funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Replace point N of linestring with given point. Index is
			0-based.
				This is especially useful in triggers when trying to maintain relationship of joints when one vertex moves.</para>
			<para>Availability: 1.1.0</para>

			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
			</inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<programlisting>
--Change first point in line string from -1 3 to -1 1
SELECT ST_AsText(ST_SetPoint('LINESTRING(-1 2,-1 3)', 0, 'POINT(-1 1)'));
	   st_astext
-----------------------
 LINESTRING(-1 1,-1 3)

---Change last point in a line string (lets play with 3d linestring this time)
SELECT ST_AsEWKT(ST_SetPoint(foo.the_geom, ST_NumPoints(foo.the_geom) - 1, ST_GeomFromEWKT('POINT(-1 1 3)')))
FROM (SELECT ST_GeomFromEWKT('LINESTRING(-1 2 3,-1 3 4, 5 6 7)') As the_geom) As foo;
	   st_asewkt
-----------------------
LINESTRING(-1 2 3,-1 3 4,-1 1 3)
			</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AddPoint"/>,<xref linkend="ST_NPoints"/>, <xref linkend="ST_NumPoints"/>, <xref linkend="ST_RemovePoint"/></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SetSRID">
	  <refnamediv>
		<refname>ST_SetSRID</refname>

		<refpurpose>Sets the SRID on a geometry to a particular integer
		value.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SetSRID</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>geom</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Sets the SRID on a geometry to a particular integer value.
		Useful in constructing bounding boxes for queries.</para>

		<note>
		  <para>This function does not transform the geometry is any way -
		  it simply sets the projection the geometry that it's currently in.
		  Use <xref linkend="ST_Transform"/> if you want to transform the
		  geometry into a new projection.</para>
		</note>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the
		  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		  Features Implementation Specification for SQL.</ulink>
		</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="spatial_ref_sys" />, <xref linkend="ST_SRID"/>, <xref linkend="ST_Transform"/>, <xref linkend="UpdateGeometrySRID"/></para>
	  </refsection>

	</refentry>

	<refentry id="ST_SnapToGrid">
	  <refnamediv>
		<refname>ST_SnapToGrid</refname>

		<refpurpose>Snap all points of the input geometry to the grid defined by
			its origin and cell size. Remove consecutive points falling on the
			same cell, eventually returning NULL if output points are not
			enough to define a geometry of the given type. Collapsed
			geometries in a collection are stripped from it. Useful for reducing precision.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>originX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>originY</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeY</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeY</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>size</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>pointOrigin</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeY</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeZ</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeM</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Variant 1,2,3: Snap all points of the input geometry to the grid defined by
			its origin and cell size. Remove consecutive points falling on the
			same cell, eventually returning NULL if output points are not
			enough to define a geometry of the given type. Collapsed
			geometries in a collection are stripped from it.
		</para>

		<para>Variant 4:  Introduced 1.1.0 - Snap all points of the input geometry to the grid defined by
			its origin (the second argument, must be a point) and cell sizes.
			Specify 0 as size for any dimension you don't want to snap to a
			grid.</para>

		<note>
		  <para>The returned geometry might loose its simplicity (see
		  <xref linkend="ST_IsSimple" />).</para>
		</note>

		<note>
		  <para>Before release 1.1.0 this function always returned a 2d
		  geometry. Starting at 1.1.0 the returned geometry will have same
		  dimensionality as the input one with higher dimension values
		  untouched. Use the version taking a second geometry argument to
		  define all grid dimensions.</para>
		</note>

		<para>Availability: 1.0.0RC1</para>
		<para>Availability: 1.1.0 - Z and M support</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Snap your geometries to a precision grid of 10^-3
UPDATE mytable
   SET the_geom = ST_SnapToGrid(the_geom, 0.001);

SELECT ST_AsText(ST_SnapToGrid(
			ST_GeomFromText('LINESTRING(1.1115678 2.123, 4.111111 3.2374897, 4.11112 3.23748667)'),
			0.001)
		);
			  st_astext
-------------------------------------
 LINESTRING(1.112 2.123,4.111 3.237)
 --Snap a 4d geometry
SELECT ST_AsEWKT(ST_SnapToGrid(
	ST_GeomFromEWKT('LINESTRING(-1.1115678 2.123 2.3456 1.11111,
		4.111111 3.2374897 3.1234 1.1111, -1.11111112 2.123 2.3456 1.1111112)'),
 ST_GeomFromEWKT('POINT(1.12 2.22 3.2 4.4444)'),
 0.1, 0.1, 0.1, 0.01) );
								  st_asewkt
------------------------------------------------------------------------------
 LINESTRING(-1.08 2.12 2.3 1.1144,4.12 3.22 3.1 1.1144,-1.08 2.12 2.3 1.1144)


--With a 4d geometry - the ST_SnapToGrid(geom,size) only touches x and y coords but keeps m and z the same
SELECT ST_AsEWKT(ST_SnapToGrid(ST_GeomFromEWKT('LINESTRING(-1.1115678 2.123 3 2.3456,
		4.111111 3.2374897 3.1234 1.1111)'),
	   0.01)      );
						st_asewkt
---------------------------------------------------------
 LINESTRING(-1.11 2.12 3 2.3456,4.11 3.24 3.1234 1.1111)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_Simplify" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Transform">
	  <refnamediv>
		<refname>ST_Transform</refname>

		<refpurpose>Returns a new geometry with its coordinates transformed to
			the SRID referenced by the integer parameter.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Transform</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a new geometry with its coordinates transformed to
			spatial reference system referenced by the SRID integer parameter. The destination SRID
			must exist in the <varname>SPATIAL_REF_SYS</varname> table.</para>
		<para>ST_Transform is often confused with ST_SetSRID().  ST_Transform actually changes the coordinates
		of a geometry from one spatial reference system to another, while ST_SetSRID() simply changes the SRID identifier of
		the geometry</para>

		<note>
		  <para>Requires PostGIS be compiled with Proj support.  Use <xref linkend="PostGIS_Full_Version" /> to confirm you have proj support compiled in.</para>
		</note>

		<note>
		  <para>If using more than one transformation, it is useful to have a functional index on the commonly used
			transformations to take advantage of index usage.</para>
		</note>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.6</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Change Mass state plane US feet geometry to WGS 84 long lat</para>
		<programlisting>
SELECT ST_AsText(ST_Transform(ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,
	743265 2967450,743265.625 2967416,743238 2967416))',2249),4326)) As wgs_geom;

 wgs_geom
---------------------------
 POLYGON((-71.1776848522251 42.3902896512902,-71.1776843766326 42.3903829478009,
-71.1775844305465 42.3903826677917,-71.1775825927231 42.3902893647987,-71.177684
8522251 42.3902896512902));
(1 row)

--3D Circular String example
SELECT ST_AsEWKT(ST_Transform(ST_GeomFromEWKT('SRID=2249;CIRCULARSTRING(743238 2967416 1,743238 2967450 2,743265 2967450 3,743265.625 2967416 3,743238 2967416 4)'),4326));

				 st_asewkt
--------------------------------------------------------------------------------------
 SRID=4326;CIRCULARSTRING(-71.1776848522251 42.3902896512902 1,-71.1776843766326 42.3903829478009 2,
 -71.1775844305465 42.3903826677917 3,
 -71.1775825927231 42.3902893647987 3,-71.1776848522251 42.3902896512902 4)

		</programlisting>
		<para>Example of creating a partial functional index.  For tables where you are not sure all the geometries
			will be filled in, its best to use a partial index that leaves out null geometries which will both conserve space and make your index smaller and more efficient.</para>
		<programlisting>
CREATE INDEX idx_the_geom_26986_parcels
  ON parcels
  USING gist
  (ST_Transform(the_geom, 26986))
  WHERE the_geom IS NOT NULL;
		</programlisting>
	  </refsection>

	  <refsection>
		<title>Configuring transformation behaviour</title>
				<para>Sometimes coordinate transformation involving a grid-shift can fail, for example if PROJ.4 has not been built with grid-shift files or the coordinate does not lie within the range for which the grid shift is defined. By default, PostGIS will throw an error if a grid shift file is not present, but this behaviour can be configured on a per-SRID basis by altering the proj4text value within the spatial_ref_sys table.</para>
				<para>For example, the proj4text parameter +datum=NAD87 is a shorthand form for the following +nadgrids parameter:</para>
				<programlisting>+nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat</programlisting>
				<para>The @ prefix means no error is reported if the files are not present, but if the end of the list is reached with no file having been appropriate (ie. found and overlapping) then an error is issued.</para>
				<para>If, conversely, you wanted to ensure that at least the standard files were present, but that if all files were scanned without a hit a null transformation is applied you could use:</para>
				<programlisting>+nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat,null</programlisting>
				<para>The null grid shift file is a valid grid shift file covering the whole world and applying no shift. So for a complete example, if you wanted to alter PostGIS so that transformations to SRID 4267 that didn't lie within the correct range did not throw an ERROR, you would use the following:</para>
				<programlisting>UPDATE spatial_ref_sys SET proj4text = '+proj=longlat +ellps=clrk66 +nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat,null +no_defs' WHERE srid = 4267;</programlisting>
		  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref linkend="ST_AsText" />, <xref linkend="ST_SetSRID" />, <xref linkend="UpdateGeometrySRID"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Translate">
	  <refnamediv>
		<refname>ST_Translate</refname>

		<refpurpose>Translates the geometry to a new location using the numeric
			parameters as offsets. Ie: ST_Translate(geom, X, Y) or  ST_Translate(geom, X, Y,Z).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Translate</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltax</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltay</parameter></paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>geometry <function>ST_Translate</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltax</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltay</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltaz</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a new geometry whose coordinates are translated delta x,delta y,delta z units. Units are
		based on the units defined in spatial reference (SRID) for this geometry.</para>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<para>Availability: 1.2.2</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Move a point 1 degree longitude</para>
		<programlisting>
	SELECT ST_AsText(ST_Translate(ST_GeomFromText('POINT(-71.01 42.37)',4326),1,0)) As wgs_transgeomtxt;

	wgs_transgeomtxt
	---------------------
	POINT(-70.01 42.37)
		</programlisting>
		<para>Move a linestring 1 degree longitude and 1/2 degree latitude</para>
		<programlisting>SELECT ST_AsText(ST_Translate(ST_GeomFromText('LINESTRING(-71.01 42.37,-71.11 42.38)',4326),1,0.5)) As wgs_transgeomtxt;
		   wgs_transgeomtxt
	---------------------------------------
	LINESTRING(-70.01 42.87,-70.11 42.88)
		</programlisting>
		<para>Move a 3d point</para>
		<programlisting>SELECT ST_AsEWKT(ST_Translate(CAST('POINT(0 0 0)' As geometry), 5, 12,3));
	st_asewkt
	---------
	POINT(5 12 3)
		</programlisting>
		<para>Move a curve and a point</para>
<programlisting>SELECT ST_AsText(ST_Translate(ST_Collect('CURVEPOLYGON(CIRCULARSTRING(4 3,3.12 0.878,1 0,-1.121 5.1213,6 7, 8 9,4 3))','POINT(1 3)'),1,2));
														 st_astext
------------------------------------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(CURVEPOLYGON(CIRCULARSTRING(5 5,4.12 2.878,2 2,-0.121 7.1213,7 9,9 11,5 5)),POINT(2 5))
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Affine" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromText" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_TransScale">
	  <refnamediv>
		<refname>ST_TransScale</refname>

		<refpurpose>Translates the geometry using the deltaX and deltaY args,
			then scales it using the XFactor, YFactor args, working in 2D only.
			</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_TransScale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>deltaX</parameter></paramdef>
			<paramdef><type>float</type> <parameter>deltaY</parameter></paramdef>
			<paramdef><type>float</type> <parameter>XFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>YFactor</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Translates the geometry using the deltaX and deltaY args,
			then scales it using the XFactor, YFactor args, working in 2D only.</para>

		<note><para><code>ST_TransScale(geomA, deltaX, deltaY, XFactor, YFactor)</code>
			is short-hand for <code>ST_Affine(geomA, XFactor, 0, 0, 0, YFactor, 0,
			0, 0, 1, deltaX*XFactor, deltaY*YFactor, 0)</code>.</para></note>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>


		<para>Availability: 1.1.0.</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsEWKT(ST_TransScale(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), 0.5, 1, 1, 2));
		  st_asewkt
-----------------------------
 LINESTRING(1.5 6 3,1.5 4 1)


--Buffer a point to get an approximation of a circle, convert to curve and then translate 1,2 and scale it 3,4
  SELECT ST_AsText(ST_Transscale(ST_LineToCurve(ST_Buffer('POINT(234 567)', 3)),1,2,3,4));
														  st_astext
------------------------------------------------------------------------------------------------------------------------------
 CURVEPOLYGON(CIRCULARSTRING(714 2276,711.363961030679 2267.51471862576,705 2264,698.636038969321 2284.48528137424,714 2276))

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_Translate" /></para>
	  </refsection>
	</refentry>



  </sect1>

  <sect1 id="Geometry_Outputs">
	  <title>Geometry Outputs</title>
		  <refentry id="ST_AsBinary">
		  <refnamediv>
			<refname>ST_AsBinary</refname>
			<refpurpose>Return the Well-Known Binary (WKB) representation of the geometry without SRID meta data.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsBinary</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsBinary</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>text </type><parameter>NDR_or_XDR</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the Well-Known Binary representation of the geometry.  There are 2 variants of the function.  The first
			variant takes no endian encoding paramater and defaults to little endian.  The second variant takes a second argument
			denoting the encoding - using little-endian ('NDR') or big-endian ('XDR') encoding.</para>
			<para>This is useful in binary cursors to pull data out of the
			database without converting it to a string representation.</para>

			<note>
			  <para>The WKB spec does not include the SRID.  To get the OGC WKB with SRID format use ST_AsEWKB</para>
			</note>
			<note>
			  <para>ST_AsBinary is the reverse of <xref linkend="ST_GeomFromWKB" />.  Use <xref linkend="ST_GeomFromWKB" /> to convert to a postgis geometry from ST_AsBinary representation.</para>
			</note>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL. OGC SPEC s2.1.1.1</ulink></para>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.37
			</para>

		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsBinary(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));

		   st_asbinary
--------------------------------
\001\003\000\000\000\001\000\000\000\005
\000\000\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000
\000\000\000\360?\000\000\000\000\000\000
\360?\000\000\000\000\000\000\360?\000\000
\000\000\000\000\360?\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000
(1 row)</programlisting>
			<programlisting>SELECT ST_AsBinary(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326), 'XDR');
		   st_asbinary
--------------------------------
\000\000\000\000\003\000\000\000\001\000\000\000\005\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000
\000?\360\000\000\000\000\000\000?\360\000\000\000\000\000\000?\360\000\000
\000\000\000\000?\360\000\000\000\000\000\000\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000
(1 row)</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsEWKB" />, <xref linkend="ST_AsEWKT" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromEWKB" /></para>
		  </refsection>
	</refentry>
	<refentry id="ST_AsEWKB">
		  <refnamediv>
			<refname>ST_AsEWKB</refname>
			<refpurpose>Return the Well-Known Binary (WKB) representation of the geometry with SRID meta data.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsEWKB</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsEWKB</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>text </type><parameter>NDR_or_XDR</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>
			<para>Returns the Well-Known Binary representation of the geometry with SRID metadata.  There are 2 variants of the function.  The first
			variant takes no endian encoding paramater and defaults to little endian.  The second variant takes a second argument
			denoting the encoding - using little-endian ('NDR') or big-endian ('XDR') encoding.</para>
			<para>This is useful in binary cursors to pull data out of the
			database without converting it to a string representation.</para>
			<note>
			  <para>The WKB spec does not include the SRID.  To get the OGC WKB format use ST_AsBinary</para>
			</note>
			<note>
			  <para>ST_AsEWKB is the reverse of ST_GeomFromEWKB.  Use ST_GeomFromEWKB to convert to a postgis geometry from ST_AsEWKB representation.</para>
			</note>
			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

			<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
			</inlinemediaobject> This method supports Circular Strings and Curves </para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsEWKB(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));

		   st_asewkb
--------------------------------
\001\003\000\000 \346\020\000\000\001\000
\000\000\005\000\000\000\000
\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000
\000\000\360?\000\000\000\000\000\000\360?
\000\000\000\000\000\000\360?\000\000\000\000\000
\000\360?\000\000\000\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000\000\000\000
(1 row)</programlisting>
		<programlisting>
			SELECT ST_AsEWKB(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326), 'XDR');
		   st_asewkb
--------------------------------
\000 \000\000\003\000\000\020\346\000\000\000\001\000\000\000\005\000\000\000\000\
000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000?
\360\000\000\000\000\000\000?\360\000\000\000\000\000\000?\360\000\000\000\000
\000\000?\360\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000
\000\000\000\000\000\000\000\000\000\000\000\000\000
		</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsBinary" />, <xref linkend="ST_AsEWKT" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_SRID" /></para>
		  </refsection>
	</refentry>
	  <refentry id="ST_AsEWKT">
		  <refnamediv>
			<refname>ST_AsEWKT</refname>
			<refpurpose>Return the Well-Known Text (WKT) representation of the geometry with SRID meta data.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>text <function>ST_AsEWKT</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the Well-Known Text representation of the geometry prefixed with the SRID.</para>

			<note>
			  <para>The WKT spec does not include the SRID.  To get the OGC WKT format use ST_AsText</para>
			</note>
			<para><inlinegraphic fileref="images/warning.png" />
				WKT format does not maintain precision so to prevent floating truncation, use ST_AsBinary or ST_AsEWKB format for transport.
			</para>
			<note>
			  <para>ST_AsEWKT is the reverse of <xref linkend="ST_GeomFromEWKT" />.  Use <xref linkend="ST_GeomFromEWKT" /> to convert to a postgis geometry from ST_AsEWKT representation.</para>
			</note>
			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

			<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsEWKT('0103000020E61000000100000005000000000000
			000000000000000000000000000000000000000000000000000000
			F03F000000000000F03F000000000000F03F000000000000F03
			F000000000000000000000000000000000000000000000000'::geometry);

		   st_asewkt
--------------------------------
SRID=4326;POLYGON((0 0,0 1,1 1,1 0,0 0))
(1 row)

SELECT ST_AsEWKT('0108000080030000000000000060E30A4100000000785C0241000000000000F03F0000000018
E20A4100000000485F024100000000000000400000000018
E20A4100000000305C02410000000000000840')

--st_asewkt---
CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)
</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsBinary" /><xref linkend="ST_AsEWKB" /><xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromEWKT" /></para>
		  </refsection>
	</refentry>
	<refentry id="ST_AsGeoJSON">
	  <refnamediv>
		<refname>ST_AsGeoJSON</refname>

		<refpurpose>Return the geometry as a GeoJSON element.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>max_decimal_digits</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>max_decimal_digits</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>options</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>max_decimal_digits</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>max_decimal_digits</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>options</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		  <para>Return the geometry as a Geometry Javascript Object Notation (GeoJSON) element. (Cf <ulink
			url="http://geojson.org/geojson-spec.html">GeoJSON
			specifications 1.0</ulink>). 2D and 3D Geometries are both
			supported. GeoJSON only support SFS 1.1 geometry type (no curve
			support for example).</para>

			<para>The version parameter, if specified, must be 1.</para>

			<para>The third argument may be used to reduce the maximum number
			of decimal places used in output (defaults to 15).</para>

			<para>The last 'options' argument could be used to add Bbox or Crs
			in GeoJSON output:
			  <itemizedlist>
				<listitem>
				  <para>0: means no option (default value)</para>
				</listitem>

				<listitem>
				  <para>1: GeoJSON Bbox</para>
				</listitem>

				<listitem>
				  <para>2: GeoJSON Short CRS (e.g EPSG:4326)</para>
				</listitem>

				<listitem>
				  <para>4: GeoJSON Long CRS (e.g urn:ogc:def:crs:EPSG:4326)</para>
				</listitem>
			  </itemizedlist>
			</para>
			<para>Version 1: ST_AsGeoJSON(geom) / precision=15 version=1 options=0</para>
			<para>Version 2: ST_AsGeoJSON(geom, precision) / version=1 options=0</para>
			<para>Version 3: ST_AsGeoJSON(geom, precision, options) / version=1</para>
			<para>Version 4: ST_AsGeoJSON(version, geom) / precision=15 options=0</para>
			<para>Version 5: ST_AsGeoJSON(version, geom, precision) /options=0</para>
			<para>Version 6: ST_AsGeoJSON(version, geom, precision,options)</para>

			<para>Availability: 1.3.4</para>
			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>GeoJSON format is generally more efficient than other formats for use in ajax mapping.
			One popular javascript client that supports this is Open Layers.
			Example of its use is   <ulink
			url="http://openlayers.org/dev/examples/vector-formats.html">OpenLayers GeoJSON Example</ulink>
		</para>
		<programlisting>SELECT ST_AsGeoJSON(the_geom) from fe_edges limit 1;
					   st_asgeojson
-----------------------------------------------------------------------------------------------------------

{"type":"MultiLineString","coordinates":[[[-89.734634999999997,31.492072000000000],
[-89.734955999999997,31.492237999999997]]]}
(1 row)
--3d point
SELECT ST_AsGeoJSON('LINESTRING(1 2 3, 4 5 6)');

st_asgeojson
-----------------------------------------------------------------------------------------
 {"type":"LineString","coordinates":[[1,2,3],[4,5,6]]}

</programlisting>
	  </refsection>
	</refentry>
	<refentry id="ST_AsGML">
	  <refnamediv>
		<refname>ST_AsGML</refname>
		<refpurpose>Return the geometry as a GML version 2 or 3 element.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>precision</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>precision</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>precision</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>options</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the geometry as a Geography Markup Language (GML) element. The version parameter,
			if specified, may be either 2 or 3. If no version parameter is
			specified then the default is assumed to be 2. The third argument
			may be used to reduce the maximum number of decimal places
			used in output (defaults to 15).</para>
		<para>GML 2 refer to 2.1.2 version, GML 3 to 3.1.1 version</para>
		<para>The last 'options' argument is a bitfield. It could be used to define CRS output type
					in GML output, and to declare data as lat/lon:
						  <itemizedlist>
								<listitem>
								  <para>0: GML Short CRS (e.g EPSG:4326), default value</para>
								</listitem>

								<listitem>
								  <para>1: GML Long CRS (e.g urn:ogc:def:crs:EPSG:4326)</para>
								</listitem>

								<listitem>
								  <para>16: Declare that datas are lat/lon (e.g srid=4326). Default is to assume that data are planars. This option is usefull for GML 3.1.1 output only, related to axis order.</para>
								</listitem>
						  </itemizedlist>
						</para>

		<!-- TODO: Itemize defaults for each function -->

		<note>
		  <para>Availability: 1.3.2</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting><![CDATA[SELECT ST_AsGML(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));
		st_asgml
		--------
		<gml:Polygon srsName="EPSG:4326"><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>0,0 0,1 1,1 1,0 0,0</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon>]]>
			</programlisting>
		<programlisting><![CDATA[SELECT ST_AsGML(3, ST_GeomFromText('POINT(5.234234233242 6.34534534534)',4326), 5, 17);
			st_asgml
			--------
		<gml:Point srsName="urn:ogc:def:crs:EPSG:4326"><gml:pos>6.34535 5.23423</gml:pos></gml:Point>]]>
			</programlisting>

	  </refsection>
	</refentry>


	<refentry id="ST_AsHEXEWKB">
	  <refnamediv>
		<refname>ST_AsHEXEWKB</refname>

		<refpurpose>Returns a Geometry in HEXEWKB format (as text) using either
			little-endian (NDR) or big-endian (XDR) encoding.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>ST_AsHEXEWKB</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>text </type> <parameter>NDRorXDR</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>ST_AsHEXEWKB</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a Geometry in HEXEWKB format (as text) using either
			little-endian (NDR) or big-endian (XDR) encoding.  If no encoding is specified, then NDR is used.</para>

		<note>
		  <para>Availability: 1.2.2</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
			</inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_AsHEXEWKB(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));
		which gives same answer as

		SELECT ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326)::text;

		st_ashexewkb
		--------
		0103000020E6100000010000000500
		00000000000000000000000000000000
		00000000000000000000000000000000F03F
		000000000000F03F000000000000F03F000000000000F03
		F000000000000000000000000000000000000000000000000</programlisting>
	  </refsection>
	</refentry>

	<refentry id="ST_AsKML">
	  <refnamediv>
		<refname>ST_AsKML</refname>

		<refpurpose>Return the geometry as a KML element. Several variants. Default version=2, default precision=15</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_AsKML</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsKML</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>precision</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsKML</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>geom1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsKML</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>geom1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>precision</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the geometry as a Keyhole Markup Language (KML) element. There are several variants of this function.
			maximum number of decimal places used in
			output (defaults to 15) and version default to 2.</para>

		<para>Version 1: ST_AsKML(geom) / version=2 precision=15</para>
		<para>Version 2: ST_AsKML(geom, max_sig_digits) / version=2 </para>
		<para>Version 3: ST_AsKML(version, geom) / precision=15 </para>
		<para>Version 4: ST_AsKML(version, geom, precision) </para>

		<note>
		  <para>Requires PostGIS be compiled with Proj support.  Use <xref linkend="PostGIS_Full_Version" /> to confirm you have proj support compiled in.</para>
		</note>

		<note>
		  <para>Availability: 1.2.2 - later variants that include version param came in 1.3.2</para>
		</note>

		<note>
			<para>AsKML output will not work with geometries that do not have an SRID</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting><![CDATA[SELECT ST_AsKML(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));

		st_askml
		--------
		<Polygon><outerBoundaryIs><LinearRing><coordinates>0,0 0,1 1,1 1,0 0,0</coordinates></LinearRing></outerBoundaryIs></Polygon>

		--3d linestring
		SELECT ST_AsKML('SRID=4326;LINESTRING(1 2 3, 4 5 6)');
		<LineString><coordinates>1,2,3 4,5,6</coordinates></LineString>
		]]>
		</programlisting>
	  </refsection>
	 <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsSVG" />, <xref linkend="ST_AsGML" /></para>
	  </refsection>
	</refentry>
	<refentry id="ST_AsSVG">
	  <refnamediv>
		<refname>ST_AsSVG</refname>

		<refpurpose>Returns a Geometry in SVG path data.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_AsSVG</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsSVG</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>rel</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsSVG</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>rel</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>maxdecimaldigits</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the geometry as Scalar Vector Graphics (SVG) path data. Use 1 as second
			argument to have the path data implemented in terms of relative
			moves, the default (or 0) uses absolute moves. Third argument may
			be used to reduce the maximum number of decimal digits used in
			output (defaults to 15). Point geometries will be rendered as
			cx/cy when 'rel' arg is 0, x/y when 'rel' is 1. Multipoint
			geometries are delimited by commas (","), GeometryCollection
			geometries are delimited by semicolons (";").</para>

		<note>
		  <para>Availability: 1.2.2.  Availability: 1.4.0  Changed in PostGIS 1.4.0 to include L command in absolute path to conform to <ulink
			url="http://www.w3.org/TR/SVG/paths.html#PathDataBNF">http://www.w3.org/TR/SVG/paths.html#PathDataBNF</ulink> </para>
		</note>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_AsSVG(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));

		st_assvg
		--------
		M 0 0 L 0 -1 1 -1 1 0 Z</programlisting>
	  </refsection>
	</refentry>


	<refentry id="ST_GeoHash">
	  <refnamediv>
		<refname>ST_GeoHash</refname>

		<refpurpose>Return a GeoHash representation (geohash.org) of the geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_GeoHash</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_GeoHash</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>precision</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return a GeoHash representation (geohash.org) of the geometry. A GeoHash encodes a point into a text form that is sortable and searchable based on prefixing.  A shorter GeoHash is a less precise representation of a point.  It can also be thought of as a box, that contains the actual point.</para>

		<para>The one-parameter variant of ST_GeoHash returns a GeoHash based on the input geometry type. Points return a GeoHash with 20 characters of precision (about enough to hold the full double precision of the input). Other types return a GeoHash with a variable amount of precision, based on the size of the feature. Larger features are represented with less precision, smaller features with more precision. The idea is that the box implied by the GeoHash will always contain the input feature.</para>

		<para>The two-parameter variant of ST_GeoHash returns a GeoHash with a requested precision. For non-points, the starting point of the calculation is the center of the bounding box of the geometry.</para>

		<para>Availability: 1.4.0</para>

		<note>
			<para>ST_GeoHash will not work with geometries that are not in geographic (lon/lat) coordinates.</para>
		</note>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting><![CDATA[SELECT ST_GeoHash(ST_SetSRID(ST_MakePoint(-126,48),4326));

	 st_geohash
----------------------
 c0w3hf1s70w3hf1s70w3

SELECT ST_GeoHash(ST_SetSRID(ST_MakePoint(-126,48),4326),5);

 st_geohash
------------
 c0w3h
		]]>
		</programlisting>
	  </refsection>
	 <refsection>
		<title>See Also</title>

		<para></para>
	  </refsection>
	</refentry>


	<refentry id="ST_AsText">
		  <refnamediv>
			<refname>ST_AsText</refname>
			<refpurpose>Return the Well-Known Text (WKT) representation of the geometry without SRID metadata.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>text <function>ST_AsText</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the Well-Known Text representation of the geometry.</para>

			<note>
			  <para>The WKT spec does not include the SRID.  To get the SRID as part of the data, use the non-standard
				PostGIS <xref linkend="ST_AsEWKT" /></para>
			</note>
			<para><inlinegraphic fileref="images/warning.png" />
				WKT format does not maintain precision so to prevent floating truncation, use ST_AsBinary or ST_AsEWKB format for transport.
			</para>
			<note>
			  <para>ST_AsText is the reverse of <xref linkend="ST_GeomFromText" />.  Use <xref linkend="ST_GeomFromText" /> to convert to a postgis geometry from ST_AsText representation.</para>
			</note>

			<!-- Optionally mention OpenGIS compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL. OGC SPEC s2.1.1.1</ulink></para>

			 <para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This method implements the SQL/MM specification:
	  SQL-MM 3: 5.1.25</para>

		<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText('01030000000100000005000000000000000000
000000000000000000000000000000000000000000000000
F03F000000000000F03F000000000000F03F000000000000F03
F000000000000000000000000000000000000000000000000');

		   st_astext
--------------------------------
 POLYGON((0 0,0 1,1 1,1 0,0 0))
(1 row)</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_AsBinary" />, <xref linkend="ST_AsEWKB" />, <xref linkend="ST_AsEWKT" />, <xref linkend="ST_GeomFromText" /></para>
		  </refsection>
	</refentry>

  </sect1>

  <sect1 id="Operators">
	<title>Operators</title>
		<refentry id="ST_Geometry_Overlap">
		  <refnamediv>
			<refname>&amp;&amp;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box overlaps B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A && geometry B)" instead of
				"boolean &&( geometry A, geometry B)" -->
				<funcdef>boolean <function>&amp;&amp;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&amp;&amp;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A overlaps the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
				geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 &amp;&amp; tbl2.column2 AS overlaps
FROM ( VALUES
	(1, 'LINESTRING(0 0, 3 3)'::geometry),
	(2, 'LINESTRING(0 1, 0 5)'::geometry)) AS tbl1,
( VALUES
	(3, 'LINESTRING(1 2, 4 6)'::geometry)) AS tbl2;

 column1 | column1 | overlaps
---------+---------+----------
	   1 |       3 | t
	   2 |       3 | f
(2 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
				<xref linkend="ST_Geometry_Overabove" />,
				<xref linkend="ST_Geometry_Overright" />,
				<xref linkend="ST_Geometry_Overbelow" />,
				<xref linkend="ST_Geometry_Overleft" />,
				<xref linkend="ST_Geometry_Contain" />,
				<xref linkend="ST_Geometry_Contained" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Overleft">
		  <refnamediv>
			<refname>&amp;&lt;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box overlaps or is to the left of B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A &< geometry B)" instead of
				"boolean &<( geometry A, geometry B)" -->
				<funcdef>boolean <function>&amp;&lt;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&amp;&lt;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			overlaps or is to the left of the bounding box of geometry B, or more accurately, overlaps or is NOT to the right
			of the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
				geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 &amp;&lt; tbl2.column2 AS overleft
FROM
  ( VALUES
	(1, 'LINESTRING(1 2, 4 6)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING(0 0, 3 3)'::geometry),
	(3, 'LINESTRING(0 1, 0 5)'::geometry),
	(4, 'LINESTRING(6 0, 6 1)'::geometry)) AS tbl2;

 column1 | column1 | overleft
---------+---------+----------
	   1 |       2 | f
	   1 |       3 | f
	   1 |       4 | t
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
				<xref linkend="ST_Geometry_Overlap" />,
				<xref linkend="ST_Geometry_Overabove" />,
				<xref linkend="ST_Geometry_Overright" />,
				<xref linkend="ST_Geometry_Overbelow" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Overbelow">
		  <refnamediv>
			<refname>&amp;&lt;|</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box overlaps or is below B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A &<| geometry B)" instead of
				"boolean &<|( geometry A, geometry B)" -->
				<funcdef>boolean <function>&amp;&lt;|</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&amp;&lt;|</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			overlaps or is below of the bounding box of geometry B, or more accurately, overlaps or is NOT above the bounding
			box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
				geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 &amp;&lt;| tbl2.column2 AS overbelow
FROM
  ( VALUES
	(1, 'LINESTRING(6 0, 6 4)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING(0 0, 3 3)'::geometry),
	(3, 'LINESTRING(0 1, 0 5)'::geometry),
	(4, 'LINESTRING(1 2, 4 6)'::geometry)) AS tbl2;

 column1 | column1 | overbelow
---------+---------+-----------
	   1 |       2 | f
	   1 |       3 | t
	   1 |       4 | t
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
				<xref linkend="ST_Geometry_Overlap" />,
				<xref linkend="ST_Geometry_Overabove" />,
				<xref linkend="ST_Geometry_Overright" />,
				<xref linkend="ST_Geometry_Overleft" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Overright">
		  <refnamediv>
			<refname>&amp;&gt;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A' bounding box overlaps or is to the right of B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A &> geometry B)" instead of
				"boolean &>( geometry A, geometry B)" -->
				<funcdef>boolean <function>&amp;&gt;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&amp;&gt;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			overlaps or is to the right of the bounding box of geometry B, or more accurately, overlaps or is NOT to the left
			of the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
				geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 &amp;&gt; tbl2.column2 AS overright
FROM
  ( VALUES
	(1, 'LINESTRING(1 2, 4 6)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING(0 0, 3 3)'::geometry),
	(3, 'LINESTRING(0 1, 0 5)'::geometry),
	(4, 'LINESTRING(6 0, 6 1)'::geometry)) AS tbl2;

 column1 | column1 | overright
---------+---------+-----------
	   1 |       2 | t
	   1 |       3 | t
	   1 |       4 | f
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
				<xref linkend="ST_Geometry_Overlap" />,
				<xref linkend="ST_Geometry_Overabove" />,
				<xref linkend="ST_Geometry_Overbelow" />,
				<xref linkend="ST_Geometry_Overleft" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Left">
		  <refnamediv>
			<refname>&lt;&lt;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box is strictly to the left of B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A << geometry B)" instead of
				"boolean <<( geometry A, geometry B)" -->
				<funcdef>boolean <function>&lt;&lt;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&lt;&lt;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			is strictly to the left of the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
				geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 &lt;&lt; tbl2.column2 AS left
FROM
  ( VALUES
	(1, 'LINESTRING (1 2, 1 5)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING (0 0, 4 3)'::geometry),
	(3, 'LINESTRING (6 0, 6 5)'::geometry),
	(4, 'LINESTRING (2 2, 5 6)'::geometry)) AS tbl2;

 column1 | column1 | left
---------+---------+------
	   1 |       2 | f
	   1 |       3 | t
	   1 |       4 | t
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Geometry_Right" />, <xref linkend="ST_Geometry_Above" />, <xref linkend="ST_Geometry_Below" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Below">
		  <refnamediv>
			<refname>&lt;&lt;|</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box is strictly below B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A <<| geometry B)" instead of
				"boolean <<|( geometry A, geometry B)" -->
				<funcdef>boolean <function>&lt;&lt;|</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&lt;&lt;|</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			is strictly below the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
				geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 &lt;&lt;| tbl2.column2 AS below
FROM
  ( VALUES
	(1, 'LINESTRING (0 0, 4 3)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING (1 4, 1 7)'::geometry),
	(3, 'LINESTRING (6 1, 6 5)'::geometry),
	(4, 'LINESTRING (2 3, 5 6)'::geometry)) AS tbl2;

 column1 | column1 | below
---------+---------+-------
	   1 |       2 | t
	   1 |       3 | f
	   1 |       4 | f
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Geometry_Left" />, <xref linkend="ST_Geometry_Right" />, <xref linkend="ST_Geometry_Above" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_EQ">
		  <refnamediv>
			<refname>&#61;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box is the same as B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A = geometry B)" instead of
				"boolean =( geometry A, geometry B)" -->
				<funcdef>boolean <function>&#61;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&#61;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			is the same as the bounding box of geometry B.  PostgreSQL uses the =, &lt;, and &gt; operators defined for geometries to
			perform internal orderings and comparison of geometries (ie. in a GROUP BY or ORDER BY clause).</para>

			<warning>
			  <para>This is cause for a lot of confusion. When you compare geometryA =
			  geometryB it will return true even when the geometries are clearly
			  different IF their bounding boxes are the same. To check for true
			  equality use <xref linkend="ST_OrderingEquals" /> or <xref
			  linkend="ST_Equals" /></para>
			</warning>

			<caution><para>This operand will NOT make use of any indexes that may be available on the
				geometries.</para></caution>

		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT 'LINESTRING(0 0, 0 1, 1 0)'::geometry = 'LINESTRING(1 1, 0 0)'::geometry;
 ?column?
----------
 t
(1 row)

SELECT ST_AsText(column1)
FROM ( VALUES
	('LINESTRING(0 0, 1 1)'::geometry),
	('LINESTRING(1 1, 0 0)'::geometry)) AS foo;
	  st_astext
---------------------
 LINESTRING(0 0,1 1)
 LINESTRING(1 1,0 0)
(2 rows)

-- Note: the GROUP BY uses the "=" to compare for geometry equivalency.
SELECT ST_AsText(column1)
FROM ( VALUES
	('LINESTRING(0 0, 1 1)'::geometry),
	('LINESTRING(1 1, 0 0)'::geometry)) AS foo
GROUP BY column1;
	  st_astext
---------------------
 LINESTRING(0 0,1 1)
(1 row)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Equals" />, <xref linkend="ST_OrderingEquals" />, <xref linkend="ST_Geometry_Same" />
			<!--, <xref linkend="ST_Geometry_LT" />, <xref linkend="ST_Geometry_GT" /> --></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Right">
		  <refnamediv>
			<refname>&gt;&gt;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box is strictly to the right of B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A >> geometry B)" instead of
				"boolean >>( geometry A, geometry B)" -->
				<funcdef>boolean <function>&gt;&gt;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>&gt;&gt;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			is strictly to the right of the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
				geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 &gt;&gt; tbl2.column2 AS right
FROM
  ( VALUES
	(1, 'LINESTRING (2 3, 5 6)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING (1 4, 1 7)'::geometry),
	(3, 'LINESTRING (6 1, 6 5)'::geometry),
	(4, 'LINESTRING (0 0, 4 3)'::geometry)) AS tbl2;

 column1 | column1 | right
---------+---------+-------
	   1 |       2 | t
	   1 |       3 | f
	   1 |       4 | f
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Geometry_Left" />, <xref linkend="ST_Geometry_Above" />, <xref linkend="ST_Geometry_Below" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Contained">
		  <refnamediv>
			<refname>@</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box is contained by B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A @ geometry B)" instead of
				"boolean @( geometry A, geometry B)" -->
				<funcdef>boolean <function>~=</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>@</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A is completely
			contained by the bounding box of geometry B.</para>

			<note>
			  <para>This operand will make use of any indexes that may be available on the
			  geometries.</para>
			</note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 @ tbl2.column2 AS contained
FROM
  ( VALUES
	(1, 'LINESTRING (1 1, 3 3)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING (0 0, 4 4)'::geometry),
	(3, 'LINESTRING (2 2, 4 4)'::geometry),
	(4, 'LINESTRING (1 1, 3 3)'::geometry)) AS tbl2;

 column1 | column1 | contained
---------+---------+-----------
	   1 |       2 | t
	   1 |       3 | f
	   1 |       4 | t
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Geometry_Contain" />, <xref linkend="ST_Geometry_Overlap" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Overabove">
		  <refnamediv>
			<refname>|&amp;&gt;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box overlaps or is above B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A |&> geometry B)" instead of
				"boolean |&>( geometry A, geometry B)" -->
				<funcdef>boolean <function>|&amp;&gt;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>|&amp;&gt;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			overlaps or is above the bounding box of geometry B, or more accurately, overlaps or is NOT below
			the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
			  geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 |&amp;&gt; tbl2.column2 AS overabove
FROM
  ( VALUES
	(1, 'LINESTRING(6 0, 6 4)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING(0 0, 3 3)'::geometry),
	(3, 'LINESTRING(0 1, 0 5)'::geometry),
	(4, 'LINESTRING(1 2, 4 6)'::geometry)) AS tbl2;

 column1 | column1 | overabove
---------+---------+-----------
	   1 |       2 | t
	   1 |       3 | f
	   1 |       4 | f
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
				<xref linkend="ST_Geometry_Overlap" />,
				<xref linkend="ST_Geometry_Overright" />,
				<xref linkend="ST_Geometry_Overbelow" />,
				<xref linkend="ST_Geometry_Overleft" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Above">
		  <refnamediv>
			<refname>|&gt;&gt;</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box is strictly above B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A |>> geometry B)" instead of
				"boolean |>>( geometry A, geometry B)" -->
				<funcdef>boolean <function>|&gt;&gt;</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>|&gt;&gt;</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A
			is strictly to the right of the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
			  geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 |&gt;&gt; tbl2.column2 AS above
FROM
  ( VALUES
	(1, 'LINESTRING (1 4, 1 7)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING (0 0, 4 2)'::geometry),
	(3, 'LINESTRING (6 1, 6 5)'::geometry),
	(4, 'LINESTRING (2 3, 5 6)'::geometry)) AS tbl2;

 column1 | column1 | above
---------+---------+-------
	   1 |       2 | t
	   1 |       3 | f
	   1 |       4 | f
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Geometry_Left" />, <xref linkend="ST_Geometry_Right" />, <xref linkend="ST_Geometry_Below" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Contain">
		  <refnamediv>
			<refname>~</refname>

			<refpurpose>Returns <varname>TRUE</varname> if A's bounding box contains B's.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A ~ geometry B)" instead of
				"boolean ~( geometry A, geometry B)" -->
				<funcdef>boolean <function>~</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>~</varname> operator returns <varname>TRUE</varname> if the bounding box of geometry A completely
			contains the bounding box of geometry B.</para>

			<note><para>This operand will make use of any indexes that may be available on the
			  geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 ~ tbl2.column2 AS contains
FROM
  ( VALUES
	(1, 'LINESTRING (0 0, 3 3)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING (0 0, 4 4)'::geometry),
	(3, 'LINESTRING (1 1, 2 2)'::geometry),
	(4, 'LINESTRING (0 0, 3 3)'::geometry)) AS tbl2;

 column1 | column1 | contains
---------+---------+----------
	   1 |       2 | f
	   1 |       3 | t
	   1 |       4 | t
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Geometry_Contained" />, <xref linkend="ST_Geometry_Overlap" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Geometry_Same">
		  <refnamediv>
			<refname>~=</refname>

			<refpurpose>Returns <varname>TRUE</varname> if the geometry A is the same as B.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<!-- TODO: Ideally, it would be nice if this could be reordered to
				"boolean (geometry A ~= geometry B)" instead of
				"boolean ~=( geometry A, geometry B)" -->
				<funcdef>boolean <function>~=</function></funcdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>A</parameter>
				</paramdef>

				<paramdef>
				  <type>geometry </type>

				  <parameter>B</parameter>
				</paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>The <varname>~=</varname> operator returns <varname>TRUE</varname> if geometry A is the same as geometry B.
			It tests actual geometric equality of two features.  So if A and B are the same feature, vertex-by-vertex, the
			operator returns <varname>TRUE</varname>.</para>

			<note><para>This operand will make use of any indexes that may be available on the
			  geometries.</para></note>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT tbl1.column1, tbl2.column1, tbl1.column2 ~= tbl2.column2 AS same
FROM
  ( VALUES
	(1, 'LINESTRING (0 0, 2 2)'::geometry)) AS tbl1,
  ( VALUES
	(2, 'LINESTRING (0 0, 1 1, 2 2)'::geometry),
	(3, 'LINESTRING (2 2, 0 0)'::geometry),
	(4, 'LINESTRING (0 0, 2 2)'::geometry)) AS tbl2;

 column1 | column1 | same
---------+---------+------
	   1 |       2 | f
	   1 |       3 | f
	   1 |       4 | t
(3 rows)</programlisting>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Equals" />, <xref linkend="ST_OrderingEquals" />, <xref linkend="ST_Geometry_EQ" /></para>
		  </refsection>
		</refentry>

	</sect1>


  <sect1 id="Spatial_Relationships_Measurements">
	<title>Spatial Relationships and Measurements</title>
	<refentry id="ST_Area">
		<refnamediv>
		  <refname>ST_Area</refname>

		  <refpurpose>Returns the area of the geometry if it is a polygon or
				multi-polygon.</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
		  <funcsynopsis>
			<funcprototype>
			  <funcdef>float <function>ST_Area</function></funcdef>
				<paramdef><type>geometry </type><parameter>g1</parameter></paramdef>
			</funcprototype>
		  </funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>

			<para>Returns the area of the geometry if it is a polygon or
				multi-polygon. Return the area measurement of an ST_Surface or
		  ST_MultiSurface value. Area is in the units of the spatial reference system.</para>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL.</ulink></para>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 8.1.2, 9.5.3</para>
		</refsection>

		  <refsection>
			<title>Examples</title>
			<para>Return area in square feet for a plot of Massachusetts land. Note this is in square feet because 2249 is
				Mass State Plane Feet</para>
			<programlisting>
SELECT ST_Area(ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,
	743265 2967450,743265.625 2967416,743238 2967416))',2249));
st_area
---------
 928.625
(1 row)

--this returns in square meters
SELECT ST_Area(ST_Transform(ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,
	743265 2967450,743265.625 2967416,743238 2967416))',2249), 26986));
st_area
------------------
 86.2724306061864
			</programlisting>
		  </refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromText" />, <xref linkend="ST_SetSRID" />,<xref linkend="ST_Transform" /></para>
		</refsection>

	</refentry>

	<refentry id="ST_Azimuth">
		<refnamediv>
		  <refname>ST_Azimuth</refname>

		  <refpurpose>Returns the angle in radians from the horizontal of the vector defined by pointA and pointB</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
		  <funcsynopsis>
			<funcprototype>
			  <funcdef>float <function>ST_Azimuth</function></funcdef>
			  <paramdef><type>geometry </type><parameter>pointA</parameter></paramdef>
			  <paramdef><type>geometry </type><parameter>pointB</parameter></paramdef>
			</funcprototype>
		  </funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>

			<para>Returns the azimuth of the segment defined by the given
			Point geometries, or NULL if the two points are coincident. Return
			value is in radians.</para>

			<para>The Azimuth is mathematical concept defined as the angle, in this case measured in radian, between a reference plane
				and a point</para>

			<para>Availability: 1.1.0</para>
			<para>Azimuth is especially useful in conjunction with ST_Translate for shifting an object along its perpendicular axis. See
				 upgis_lineshift <ulink url="http://postgis.refractions.net/support/wiki/index.php?plpgsqlfunctions">Plpgsqlfunctions PostGIS wiki section</ulink> for example of this.</para>
		</refsection>

		<refsection>
		<title>Examples</title>
		<para>--Azimuth in degrees </para>
<programlisting>
SELECT ST_Azimuth(ST_MakePoint(1,2), ST_MakePoint(3,4))/(2*pi())*360 as degAz,
	ST_Azimuth(ST_MakePoint(3,4), ST_MakePoint(1,2))/(2*pi())*360 As degAzrev

degaz	degazrev
------	---------
45		225
</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_MakePoint" />, <xref linkend="ST_Translate" /></para>
		</refsection>

  </refentry>

  <refentry id="ST_Centroid">
	<refnamediv>
	  <refname>ST_Centroid</refname>

	  <refpurpose>Returns the geometric center of a geometry.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
		<funcprototype>
		  <funcdef>geometry <function>ST_Centroid</function></funcdef>

		  <paramdef><type>geometry </type>
		  <parameter>g1</parameter></paramdef>
		</funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsection>
	  <title>Description</title>

	  <para>Computes the geometric center of a geometry, or equivalently,
	  the center of mass of the geometry as a <varname>POINT</varname>. For
	  [<varname>MULTI</varname>]<varname>POINT</varname>s, this is computed
	  as the arithmetric mean of the input coordinates. For
	  [<varname>MULTI</varname>]<varname>LINESTRING</varname>s, this is
	  computed as the weighted length of each line segment. For
	  [<varname>MULTI</varname>]<varname>POLYGON</varname>s, "weight" is
	  thought in terms of area. If an empty geometry is supplied, an empty
	  <varname>GEOMETRYCOLLECTION</varname> is returned. If
	  <varname>NULL</varname> is supplied, <varname>NULL</varname> is
	  returned.</para>

	  <para>The centroid is equal to the centroid of the set of component
	  Geometries of highest dimension (since the lower-dimension geometries
	  contribute zero "weight" to the centroid).</para>

	  <note><para>Computation will be more accurate if performed by the GEOS
	  module (enabled at compile time).</para></note>

	  <para><inlinemediaobject>
		  <imageobject>
			<imagedata fileref="images/check.png" />
		  </imageobject>
		</inlinemediaobject> This method implements the <ulink
	  url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
	  Features Implementation Specification for SQL.</ulink></para>

	  <para><inlinemediaobject>
		  <imageobject>
			<imagedata fileref="images/check.png" />
		  </imageobject>
		</inlinemediaobject> This method implements the SQL/MM
	  specification: SQL-MM 3: 8.1.4, 9.5.5</para>
	</refsection>

	<refsection>
	  <title>Examples</title>

	  <para>In each of the following illustrations, the blue dot represents
	  the centroid of the source geometry.</para>

	  <informaltable>
		<tgroup cols="2">
		  <tbody>
			<row>
			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid01.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>MULTIPOINT</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>

			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid02.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>LINESTRING</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>
			</row>

			<row>
			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid03.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>POLYGON</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>

			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid04.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>GEOMETRYCOLLECTION</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>
			</row>
		  </tbody>
		</tgroup>
	  </informaltable>

	  <programlisting>SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, 0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));
				st_astext
------------------------------------------
 POINT(2.30769230769231 3.30769230769231)
(1 row)</programlisting>
	</refsection>

	<refsection>
	  <title>See Also</title>

	  <para><xref linkend="ST_PointOnSurface" /></para>
	</refsection>
  </refentry>

  <refentry id="ST_Contains">
	  <refnamediv>
		<refname>ST_Contains</refname>

		<refpurpose>Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A. </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Contains</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>geomA</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Geometry A contains Geometry B if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A.
		An important subtlety of this definition is that A does not contain its boundary, but A does contain itself. Contrast that to <xref linkend="ST_ContainsProperly" /> where geometry
		A does not Contain Properly itself.</para>

		<para>Returns TRUE if geometry B is completely inside geometry A. For this function to make
		sense, the source geometries must both be of the same coordinate projection,
		having the same SRID.  ST_Contains is the inverse of ST_Within.  So ST_Contains(A,B) implies ST_Within(B,A) except in the case of
		invalid geometries where the result is always false regardless or not defined.</para>

		<para>Performed by the GEOS module</para>

		<important>
		  <para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		</important>

		<important>
		  <para>Do not use this function with invalid geometries. You will get unexpected results.</para>
		</important>

		<para>This function call will automatically include a bounding box
			comparison that will make use of any indexes that are available on
			the geometries. To avoid index use, use the function
			_ST_Contains.</para>

		<para>NOTE: this is the "allowable" version that returns a
			boolean, not an integer.</para>

		<para>
		  <inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This method implements the
	  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
	Implementation Specification for SQL.</ulink>
		   OGC SPEC s2.1.1.2 // s2.1.13.3 - same as within(geometry B,
		geometry A)
		</para>

		<para>
			<inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 5.1.31</para>

		<para>There are certain subtleties to ST_Contains and ST_Within that are not intuitively obvious.
			For details check out <ulink url="http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html">Subtleties of OGC Covers, Contains, Within</ulink></para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<para>The <function>ST_Contains</function> predicate returns <varname>TRUE</varname> in all the following illustrations.</para>

		<informaltable>
		  <tgroup cols="2">
			<tbody>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_contains01.png" />
					  </imageobject>

					  <caption><para><varname>LINESTRING</varname> / <varname>MULTIPOINT</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>

				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_contains02.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>POINT</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>
			  </row>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_contains03.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>LINESTRING</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>

				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_contains04.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>POLYGON</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>
			  </row>
			</tbody>
		  </tgroup>
		</informaltable>

		<para>The <function>ST_Contains</function> predicate returns <varname>FALSE</varname> in all the following illustrations.</para>

		<informaltable>
		  <tgroup cols="2">
			<tbody>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_contains05.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>MULTIPOINT</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>

				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_contains06.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>LINESTRING</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>
			  </row>
			</tbody>
		  </tgroup>
		</informaltable>

		  <programlisting>
-- A circle within a circle
SELECT ST_Contains(smallc, bigc) As smallcontainsbig,
	   ST_Contains(bigc,smallc) As bigcontainssmall,
	   ST_Contains(bigc, ST_Union(smallc, bigc)) as bigcontainsunion,
	   ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,
	   ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,
	   ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior
FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,
			 ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;

-- Result
  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | bigcoversexterior | bigcontainsexterior
------------------+------------------+------------------+------------+-------------------+---------------------
 f                | t                | t                | t          | t        | f

-- Example demonstrating difference between contains and contains properly
SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,
   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba
FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),
			 ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),
			 ( ST_Point(1,1) )
	  ) As foo(geomA);

  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba
--------------+------------+----------------+-------------+-----------------
ST_Polygon    | t          | f              | f           | f
ST_LineString | t          | f              | f           | f
ST_Point      | t          | t              | f           | f

 </programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Boundary" />, <xref linkend="ST_ContainsProperly" />, <xref linkend="ST_Covers" />,<xref linkend="ST_CoveredBy" />, <xref linkend="ST_Equals"/>,<xref linkend="ST_Within"/></para>
	  </refsection>
 </refentry>

 <refentry id="ST_ContainsProperly">
	  <refnamediv>
		<refname>ST_ContainsProperly</refname>

		<refpurpose>Returns true if B intersects the interior of A but not the boundary (or exterior). A does not contain properly itself, but does contain itself.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_ContainsProperly</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>geomA</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns true if B intersects the interior of A but not the boundary (or exterior).</para>

		<para>A does not contain properly itself, but does contain itself.</para>
		<para>Every point of the other geometry is a point of this geometry's interior. The DE-9IM Intersection Matrix for the two geometries matches
   [T**FF*FF*] used in <xref linkend="ST_Relate" /></para>

		<note>
		  <para>From JTS docs slightly reworded: The advantage to using this predicate over <xref linkend="ST_Contains" /> and <xref linkend="ST_Intersects" /> is that it can be computed
	  efficiently, with no need to compute topology at individual points.</para>
		<para>
			 An example use case for this predicate is computing the intersections
	 of a set of geometries with a large polygonal geometry.
	Since intersection is a fairly slow operation, it can be more efficient
	 to use containsProperly to filter out test geometries which lie
	wholly inside the area.  In these cases the intersection is
	known a priori to be exactly the original test geometry.
	 </para>
		</note>

		<para>Availability: 1.4.0 - requires GEOS &gt;= 3.1.0.</para>

		<important>
		  <para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		</important>

		<important>
		  <para>Do not use this function with invalid geometries. You will get unexpected results.</para>
		</important>

		<para>This function call will automatically include a bounding box
			comparison that will make use of any indexes that are available on
			the geometries. To avoid index use, use the function
			_ST_ContainsProperly.</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
		  <programlisting>
	--a circle within a circle
	SELECT ST_ContainsProperly(smallc, bigc) As smallcontainspropbig,
	ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,
	ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as bigcontainspropunion,
	ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,
	ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,
	ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior
	FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,
	ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;
	--Result
  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | bigisunion | bigcoversexterior | bigcontainsexterior
------------------+------------------+------------------+------------+-------------------+---------------------
 f                     | t                    | f                    | t          | t                 | f

 --example demonstrating difference between contains and contains properly
 SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,
 ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba
 FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),
		  ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),
		  ( ST_Point(1,1) )
	) As foo(geomA);

  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba
--------------+------------+----------------+-------------+-----------------
ST_Polygon    | t          | f              | f           | f
ST_LineString | t          | f              | f           | f
ST_Point      | t          | t              | f           | f
 </programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_GeometryType" />, <xref linkend="ST_Boundary" />, <xref linkend="ST_Contains" />, <xref linkend="ST_Covers" />,<xref linkend="ST_CoveredBy" />, <xref linkend="ST_Equals"/>,<xref linkend="ST_Relate" />,<xref linkend="ST_Within"/></para>
	  </refsection>
 </refentry>

  <refentry id="ST_Covers">
	  <refnamediv>
		<refname>ST_Covers</refname>

		<refpurpose>Returns 1 (TRUE) if no point in Geometry B is outside
			Geometry A</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Covers</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>geomA</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		  <para>Returns 1 (TRUE) if no point in Geometry B is outside
			Geometry A</para>

		<para>Performed by the GEOS module</para>

		<important>
		  <para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		</important>

		<important>
		  <para>Do not use this function with invalid geometries. You will get unexpected results.</para>
		</important>

		<para>This function call will automatically include a bounding box
			comparison that will make use of any indexes that are available on
			the geometries. To avoid index use, use the function
			_ST_Covers.</para>

		<para>Availability: 1.2.2 - requires GEOS &gt;= 3.0</para>

		<para>NOTE: this is the "allowable" version that returns a
			boolean, not an integer.</para>

		<para>Not an OGC standard, but Oracle has it too.</para>
		<para>There are certain subtleties to ST_Contains and ST_Within that are not intuitively obvious.
			For details check out <ulink url="http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html">Subtleties of OGC Covers, Contains, Within</ulink></para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		  <programlisting>
	--a circle covering a circle
SELECT ST_Covers(smallc,smallc) As smallinsmall,
	ST_Covers(smallc, bigc) As smallcoversbig,
	ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,
	ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior
FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,
	ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;
	--Result
 smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior
--------------+----------------+-------------------+---------------------
 t            | f              | t                 | f
(1 row)	</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Contains"/>, <xref linkend="ST_CoveredBy" />, <xref linkend="ST_Within"/></para>
	  </refsection>
 </refentry>

  <refentry id="ST_CoveredBy">
	  <refnamediv>
		<refname>ST_CoveredBy</refname>

		<refpurpose>Returns 1 (TRUE) if no point in Geometry A is outside
			Geometry B</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_CoveredBy</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>geomA</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		  <para>Returns 1 (TRUE) if no point in Geometry A is outside
			Geometry B</para>

		<para>Performed by the GEOS module</para>

		<important>
		  <para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		</important>

		<important>
		  <para>Do not use this function with invalid geometries. You will get unexpected results.</para>
		</important>
		<para>Availability: 1.2.2 - requires GEOS &gt;= 3.0</para>
		<para>This function call will automatically include a bounding box
			comparison that will make use of any indexes that are available on
			the geometries. To avoid index use, use the function
			_ST_CoveredBy.</para>

		<para>NOTE: this is the "allowable" version that returns a
			boolean, not an integer.</para>

		<para>Not an OGC standard, but Oracle has it too.</para>
		<para>There are certain subtleties to ST_Contains and ST_Within that are not intuitively obvious.
			For details check out <ulink url="http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html">Subtleties of OGC Covers, Contains, Within</ulink></para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		  <programlisting>
	--a circle coveredby a circle
SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,
	ST_CoveredBy(smallc, bigc) As smallcoveredbybig,
	ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As exteriorcoveredbybig,
	ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig
FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,
	ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;
	--Result
 smallinsmall | smallcoveredbybig | exteriorcoveredbybig | exeriorwithinbig
--------------+-------------------+----------------------+------------------
 t            | t                 | t                    | f
(1 row)	</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Contains"/>, <xref linkend="ST_Covers" />, <xref linkend="ST_ExteriorRing"/>, <xref linkend="ST_Within"/></para>
	  </refsection>
 </refentry>

  <refentry id="ST_Crosses">
	<refnamediv>
	  <refname>ST_Crosses</refname>

	  <refpurpose>Returns <varname>TRUE</varname> if the supplied geometries have some, but not all,
	  interior points in common.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
		<funcprototype>
		  <funcdef>boolean <function>ST_Crosses</function></funcdef>

		  <paramdef><type>geometry </type><parameter>g1</parameter></paramdef>

		  <paramdef><type>geometry </type><parameter>g2</parameter></paramdef>
		</funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsection>
	  <title>Description</title>

	  <para><function>ST_Crosses</function> takes two geometry objects and
	  returns <varname>TRUE</varname> if their intersection "spatially cross", that is, the
	  geometries have some, but not all interior points in common. The
	  intersection of the interiors of the geometries must not be the empty
	  set and must have a dimensionality less than the the maximum dimension
	  of the two input geometries. Additionally, the intersection of the two
	  geometries must not equal either of the source geometries. Otherwise, it
	  returns <varname>FALSE</varname>.</para>

	  <para>In mathematical terms, this is expressed as:</para>

	  <remark>TODO: Insert appropriate MathML markup here or use a gif.
	  Simple HTML markup does not work well in both IE and Firefox.</remark>

	  <informalfigure>
		<mediaobject>
		  <imageobject>
			<imagedata fileref="images/st_crosses-math.gif" />
		  </imageobject>
		</mediaobject>
	  </informalfigure>

	  <para>The DE-9IM Intersection Matrix for the two geometries is:</para>

	  <itemizedlist>
		<listitem>
		  <para><markup>T*T******</markup> (for Point/Line, Point/Area, and
		  Line/Area situations)</para>
		</listitem>

		<listitem>
		  <para><markup>T*****T**</markup> (for Line/Point, Area/Point, and
		  Area/Line situations)</para>
		</listitem>

		<listitem>
		  <para><markup>0********</markup> (for Line/Line situations)</para>
		</listitem>
	  </itemizedlist>

	  <para>For any other combination of dimensions this predicate returns
	  false.</para>

	  <para>The OpenGIS Simple Features Specification defines this predicate
		only for Point/Line, Point/Area, Line/Line, and Line/Area situations.
		JTS / GEOS extends the definition to apply to Line/Point, Area/Point and
		Area/Line situations as well. This makes the relation
		symmetric.</para>

	  <important>
		<para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
	  </important>

	<note>
	  <para>This function call will automatically include a bounding box
	  comparison that will make use of any indexes that are available on the
	  geometries.</para>
	</note>

	<para>
	  <inlinegraphic fileref="images/check.png" />
	  This method implements the
	  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
	  Features Implementation Specification for SQL: 1.1: s2.1.13.3</ulink>
	</para>

	<para>
	  <inlinegraphic fileref="images/check.png" />
	  This method implements the SQL/MM specification: SQL-MM 3: 5.1.29
	</para>
	</refsection>

	<refsection>
	  <title>Examples</title>

	  <para>The following illustrations all return <varname>TRUE</varname>.</para>

	  <informaltable>
		<tgroup cols="2">
		  <tbody>
			<row>
			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_crosses01.png" />
					</imageobject>

					<caption><para><varname>MULTIPOINT</varname> / <varname>LINESTRING</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>

			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_crosses02.png" />
					</imageobject>

					<caption><para><varname>MULTIPOINT</varname> / <varname>POLYGON</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>
			</row>

			<row>
			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_crosses03.png" />
					</imageobject>

					<caption><para><varname>LINESTRING</varname> / <varname>POLYGON</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>

			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_crosses04.png" />
					</imageobject>

					<caption><para><varname>LINESTRING</varname> / <varname>LINESTRING</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>
			</row>
		  </tbody>
		</tgroup>
	  </informaltable>

	  <para>Consider a situation where a user has two tables: a table of roads
	  and a table of highways.</para>

	  <informaltable>
		<tgroup cols="2">
		  <tbody>
			<row>
			  <entry><para> <informalexample>
				  <programlisting>CREATE TABLE roads (
  id serial NOT NULL,
  the_geom geometry,
  CONSTRAINT roads_pkey PRIMARY KEY (road_id)
);</programlisting>
				</informalexample> </para></entry>

			  <entry><para> <informalexample>
				  <programlisting>CREATE TABLE highways (
  id serial NOT NULL,
  the_gem geometry,
  CONSTRAINT roads_pkey PRIMARY KEY (road_id)
);</programlisting>
				</informalexample> </para></entry>
			</row>
		  </tbody>
		</tgroup>
	  </informaltable>

	  <para>To determine a list of roads that cross a highway, use a query
	  similiar to:</para>

	  <para><informalexample>
		  <programlisting>SELECT roads.id
FROM roads, highways
WHERE ST_Crosses(roads.the_geom, highways.the_geom);</programlisting>
		</informalexample></para>
	</refsection>
  </refentry>

  <refentry id="ST_LineCrossingDirection">
	<refnamediv>
	  <refname>ST_LineCrossingDirection</refname>

	  <refpurpose>Given 2 linestrings, returns a number between -3 and 3 denoting what kind of crossing behavior. 0 is no crossing.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
		<funcprototype>
		  <funcdef>integer <function>ST_LineCrossingDirection</function></funcdef>
		  <paramdef><type>geometry </type> <parameter>linestringA</parameter></paramdef>
		  <paramdef><type>geometry </type> <parameter>linestringB</parameter></paramdef>
		</funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsection>
	  <title>Description</title>

	  <para>Given 2 linestrings, returns a number between -3 and 3 denoting what kind of crossing behavior. 0 is no crossing.  This is only supported for <varname>LINESTRING</varname></para>
	  <para>Definition of integer constants is as follows:
		   <itemizedlist>
				<listitem>
				  <para> 0: LINE NO CROSS</para>
				</listitem>
				<listitem>
				  <para>-1: LINE CROSS LEFT</para>
				</listitem>
				<listitem>
				  <para> 1: LINE CROSS RIGHT</para>
				</listitem>
				<listitem>
				  <para>-2: LINE MULTICROSS END LEFT</para>
				</listitem>
				<listitem>
					<para> 2: LINE MULTICROSS END RIGHT</para>
				</listitem>
				<listitem>
				  <para>-3: LINE MULTICROSS END SAME FIRST LEFT</para>
				</listitem>
				<listitem>
				  <para> 3: LINE MULTICROSS END SAME FIRST RIGHT</para>
				</listitem>
			</itemizedlist>
	  </para>
	  <para>Availability: 1.4</para>
	  <note><para>Version 1.4.0 was buggy and produced unpredictable results.  This is fixed in version 1.4.1.</para></note>
	  <!-- optionally mention that this function uses indexes if appropriate -->

	</refsection>


	<refsection>
	  <title>Examples</title>
  <!-- TODO: We really badly need diagrams here and more examples -->
		<informaltable>
		  <tgroup cols="2">
			<tbody>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_linecrossingdirection01.png" />
					  </imageobject>
					  <caption><para>Line 1 (green), Line 2 ball is start point,
					triangle are end points. Query below. </para></caption>
					</mediaobject>
				  </informalfigure>
				  <programlisting>
SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,
	  ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1
FROM (
SELECT
 ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,
 ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As line2
	) As foo;

 l1_cross_l2 | l2_cross_l1
-------------+-------------
           3 |          -3
				</programlisting>
			</para>
		</entry>

		<entry>
			<para><informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_linecrossingdirection02.png" />
				  </imageobject>
				  <caption><para>Line 1 (green), Line 2 (blue) ball is start point,
						triangle are end points. Query below.</para></caption>
				</mediaobject>
			  </informalfigure>
			  <programlisting>
SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,
	  ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1
FROM (
 SELECT
  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,
  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As line2
) As foo;

 l1_cross_l2 | l2_cross_l1
-------------+-------------
           2 |          -2
				</programlisting>
			</para>
		</entry>
	  </row>
	  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_linecrossingdirection03.png" />
					  </imageobject>
					  <caption><para>Line 1 (green), Line 2 (blue) ball is start point,
					triangle are end points. Query below. </para></caption>
					</mediaobject>
				  </informalfigure>
				  <programlisting>
SELECT
	ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,
	ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1
FROM (
 SELECT
  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,
  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As line2
  ) As foo;

 l1_cross_l2 | l2_cross_l1
-------------+-------------
          -1 |          1
				</programlisting>
			</para>
		</entry>

		<entry>
			<para><informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_linecrossingdirection04.png" />
				  </imageobject>
				  <caption><para>Line 1 (green), Line 2 (blue) ball is start point,
						triangle are end points. Query below.</para></caption>
				</mediaobject>
			  </informalfigure>
			  <programlisting>
SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,
	  ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1
FROM (SELECT
	ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,
	ST_GeomFromText('LINESTRING(2.99 90.16,71 74,20 140,171 154)') As line2
	) As foo;

 l1_cross_l2 | l2_cross_l1
-------------+-------------
          -2 |          2
				</programlisting>
			</para>
		</entry>
	  </row>
	  </tbody>
	</tgroup>
</informaltable>

<programlisting>
SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.the_geom, s2.the_geom)
	FROM streets s1 CROSS JOIN streets s2 ON (s1.gid != s2.gid AND s1.the_geom &amp;&amp; s2.the_geom )
WHERE ST_CrossingDirection(s1.the_geom, s2.the_geom) > 0;
</programlisting>
	</refsection>

	<!-- Optionally add a "See Also" section -->
	<refsection>
	  <title>See Also</title>

	  <para><xref linkend="ST_Crosses" /></para>
	</refsection>
  </refentry>

  <refentry id="ST_Disjoint">
		<refnamediv>
			<refname>ST_Disjoint</refname>

			<refpurpose>Returns TRUE if the Geometries do not "spatially
			intersect" - if they do not share any space together.
			</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>boolean <function>ST_Disjoint</function></funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>A</parameter>
					</paramdef>
					<paramdef>
						<type>geometry</type>
						<parameter>B</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>
			<para>Overlaps, Touches, Within all imply geometries are not spatially disjoint.  If any of the aforementioned
				returns true, then the geometries are not spatially disjoint.
				Disjoint implies false for spatial intersection.</para>

			<important>
				<para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
			</important>

			<para>Performed by the GEOS module</para>
			<note>
			  <para>This function call does not use indexes</para>

			</note>
			<note>
			  <para>NOTE: this is the "allowable" version that returns a
			boolean, not an integer.</para>
			</note>
			<para>
			  <inlinegraphic fileref="images/check.png" />
			  This method implements the
			  <ulink url="http://www.opengeospatial.org/standards/sfs">OGC SPEC s2.1.1.2 //s2.1.13.3 - a.Relate(b,
			'FF*FF****')</ulink>
			</para>
				<!-- Optionally mention SQL/MM compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.26</para>
		</refsection>
		<refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry);
 st_disjoint
---------------
 t
(1 row)
SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry);
 st_disjoint
---------------
 f
(1 row)
		</programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Intersects"/>ST_Intersects</para>
		</refsection>
	</refentry>

	<refentry id="ST_Distance">
	  <refnamediv>
		<refname>ST_Distance</refname>

		<refpurpose>Returns the 2-dimensional cartesian minimum distance between two geometries in
		projected units.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Distance</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>g1</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>g2</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the 2-dimensional minimum cartesian distance between two geometries in
		projected units.</para>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the
		  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		  Features Implementation Specification for SQL.</ulink>
		</para>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the SQL/MM specification: SQL-MM 3: 5.1.23
		</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>postgis=# SELECT ST_Distance('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry);
   st_distance
-----------------
 1.4142135623731
(1 row)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_DWithin"/>, <xref linkend="ST_Distance_Sphere"/>, <xref linkend="ST_Distance_Spheroid"/>, <xref linkend="ST_Max_Distance" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Distance_Sphere">
	  <refnamediv>
		<refname>ST_Distance_Sphere</refname>

		<refpurpose>Returns linear distance in meters between two lon/lat
				points. Uses a spherical earth and radius of 6370986 meters.
				Faster than <xref linkend="ST_Distance_Spheroid"/>, but less
				accurate. Only implemented for points.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Distance_Sphere</function></funcdef>
			<paramdef><type>geometry </type> <parameter>pointlonlatA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>pointlonlatB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns linear distance in meters between two lon/lat
				points. Uses a spherical earth and radius of 6370986 meters.
				Faster than <xref linkend="ST_Distance_Spheroid"/>, but less
				accurate. Only implemented for points.</para>
		<note>
			<para>This function currently does not look at the SRID of a point geometry and will always assume its in WGS 80 long lat.</para>
		</note>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT round(CAST(ST_Distance_Sphere(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As dist_meters,
round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),
		ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) As numeric),2) As dist_utm11_meters,
round(CAST(ST_Distance(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 38)', 4326)) As numeric),5) As dist_degrees,
round(CAST(ST_Distance(ST_Transform(the_geom,32611),
		ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) As numeric),2) As min_dist_line_point_meters
FROM
	(SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', 4326) As the_geom) as foo;
	 dist_meters | dist_utm11_meters | dist_degrees | min_dist_line_point_meters
	-------------+-------------------+--------------+----------------------------
		70424.47 |          70438.00 |      0.72900 |                   65871.18

	</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Distance" />, <xref linkend="ST_Distance_Spheroid" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Distance_Spheroid">
	  <refnamediv>
		<refname>ST_Distance_Spheroid</refname>

		<refpurpose>Returns linear distance between two lon/lat points given a
			particular spheroid.
			Currently only implemented for points.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Distance_Spheroid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>pointlonlatA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>pointlonlatB</parameter></paramdef>
			<paramdef><type>spheroid </type> <parameter>measurement_spheroid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns linear distance in meters between two lon/lat
				points given a particular spheroid. See the explanation of spheroids given for
			<xref linkend="ST_Length_Spheroid" />.</para>
		<note>
			<para>This function currently does not look at the SRID of a point geometry to determine spheroid and will always assume points are along the spheroid given.</para>
		</note>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT round(CAST(
		ST_Distance_Spheroid(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 38)',4326), 'SPHEROID["WGS 84",6378137,298.257223563]')
			As numeric),2) As dist_meters_spheroid,
		round(CAST(ST_Distance_Sphere(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As dist_meters_sphere,
round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),
		ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) As numeric),2) As dist_utm11_meters
FROM
	(SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', 4326) As the_geom) as foo;
 dist_meters_spheroid | dist_meters_sphere | dist_utm11_meters
----------------------+--------------------+-------------------
			 70454.92 |           70424.47 |          70438.00

	</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Distance" />, <xref linkend="ST_Distance_Sphere" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_DWithin">
	  <refnamediv>
		<refname>ST_DWithin</refname>

		<refpurpose>Returns true if the geometries are within the specified
		distance of one another</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_DWithin</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>g1</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>g2</parameter></paramdef>

			<paramdef><type>double precision </type>
			<parameter>distance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns true if the geometries are within the specified distance
		of one another. The distance is specified in units defined by the
		spatial reference system of the geometries.  For this function to make
		sense, the source geometries must both be of the same coorindate projection,
		having the same SRID.</para>

		<note>
		  <para>This function call will automatically include a bounding box
		  comparison that will make use of any indexes that are available on
		  the geometries.</para>
		</note>

		<note>
		  <para>Prior to 1.3, ST_Expand was commonly used in conjunction with &amp;&amp; and ST_Distance to
		  achieve the same effect and in pre-1.3.4 this function was basically short-hand for that construct.
		  From 1.3.4, ST_DWithin uses a more short-circuit distance function which should make it more efficient
		  than prior versions for larger buffer regions.</para>
		</note>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the
		  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		  Features Implementation Specification for SQL.</ulink>
		</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		  <programlisting>
--Find the nearest hospital to each school
--that is within 3000 units of the school.
-- We do an ST_DWithin search to utilize indexes to limit our search list
-- that the non-indexable ST_Distance needs to process
--If the units of the spatial reference is meters then units would be meters
SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.the_geom, h.hospital_name
	FROM schools s
		LEFT JOIN hospitals h ON ST_DWithin(s.the_geom, h.the_geom, 3000)
	ORDER BY s.gid, ST_Distance(s.the_geom, h.the_geom);

--The schools with no close hospitals
--Find all schools with no hospital within 3000 units
--away from the school.  Units is in units of spatial ref (e.g. meters, feet, degrees)
SELECT s.gid, s.school_name
	FROM schools s
		LEFT JOIN hospitals h ON ST_DWithin(s.the_geom, h.the_geom, 3000)
	WHERE h.gid IS NULL;
			  </programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Distance"/>, <xref linkend="ST_Expand"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Equals">
	  <refnamediv>
		<refname>ST_Equals</refname>

		<refpurpose>Returns true if the given geometries represent the same geometry. Directionality
			is ignored.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Equals</function></funcdef>
			<paramdef><type>geometry </type> <parameter>A</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns TRUE if the given Geometries are "spatially
			equal". Use this for a 'better' answer than '='.
			Note by spatially equal we mean ST_Within(A,B) = true and ST_Within(B,A) = true and
			also mean ordering of points can be different but
			represent the same geometry structure.  To verify the order of points is consistent, use
			ST_OrderingEquals (it must be noted ST_OrderingEquals is a little more stringent than simply verifying order of
			points are the same).</para>

		<important>
		  <para>This function will return false if either geometry is invalid even if they are binary equal.</para>
		</important>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the
		  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		  Features Implementation Specification for SQL OGC SPEC s2.1.1.2</ulink>
		</para>

		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This method implements the SQL/MM specification:
				SQL-MM 3: 5.1.24
		</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),
		ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));
 st_equals
-----------
 t
(1 row)

SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),
		ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));
 st_equals
-----------
 t
(1 row)
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_IsValid"/>, <xref linkend="ST_OrderingEquals"/>, <xref linkend="ST_Reverse"/>, <xref linkend="ST_Within" /></para>
	  </refsection>

	</refentry>

	<refentry id="ST_HasArc">
	  <refnamediv>
		<refname>ST_HasArc</refname>

		<refpurpose>Returns true if a geometry or geometry collection contains a circular string</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_HasArc</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns true if a geometry or geometry collection contains a circular string</para>

		<para>Availability: 1.2.3?</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

			<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_HasArc(ST_Collect('LINESTRING(1 2, 3 4, 5 6)', 'CIRCULARSTRING(1 1, 2 3, 4 5, 6 7, 5 6)'));
		st_hasarc
		--------
		t
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_CurveToLine" />,<xref linkend="ST_LineToCurve" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Intersects">
		<refnamediv>
			<refname>ST_Intersects</refname>

			<refpurpose>Returns TRUE if the Geometries "spatially
			intersect" - (share any portion of space) and FALSE if they don't (they are Disjoint).
			</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>boolean <function>ST_Intersects</function></funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>A</parameter>
					</paramdef>
					<paramdef>
						<type>geometry</type>
						<parameter>B</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>
			<para>Overlaps, Touches, Within all imply spatial intersection.  If any of the aforementioned
				returns true, then the geometries also spatially intersect.
				Disjoint implies false for spatial intersection.</para>

	  <important>
		<para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
	  </important>

			<para>Performed by the GEOS module</para>
			<note>
			  <para>This function call will automatically include a bounding box
			  comparison that will make use of any indexes that are available on the
			  geometries.</para>

			</note>
			<note>
			  <para>NOTE: this is the "allowable" version that returns a
			boolean, not an integer.</para>
			</note>
			<para>
			  <inlinegraphic fileref="images/check.png" />
			  This method implements the
			  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
			  Features Implementation Specification for SQL</ulink>
			  OGC SPEC s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt;
				Not (ST_Disjoint(g1, g2 ))
			</para>
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject>This method implements the SQL/MM specification:
			SQL-MM 3: 5.1.27</para>
		</refsection>
		<refsection>
		<title>Examples</title>
<programlisting>SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry);
 st_intersects
---------------
 f
(1 row)
SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry);
 st_intersects
---------------
 t
(1 row)
		</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Disjoint"/></para>
		</refsection>
	</refentry>
	<refentry id="ST_Length">
		<refnamediv>
		  <refname>ST_Length</refname>

		  <refpurpose>Returns the 2d length of the geometry if it is a linestring or multilinestring.</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
		  <funcsynopsis>
			<funcprototype>
			  <funcdef>float <function>ST_Length</function></funcdef>
				<paramdef><type>geometry </type><parameter>a_2dlinestring</parameter></paramdef>
			</funcprototype>
		  </funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>

			<para>Returns the 2D length of the geometry if it is a linestring, multilinestring, ST_Curve, ST_MultiCurve.  0 is returned for
				areal geometries.  For areal geometries use ST_Perimeter.  Measurements are in the units of the
				spatial reference system of the geometry.</para>

			<para>Currently this is an alias for ST_Length2D, but this may change to support higher dimensions.</para>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL. OGC SPEC 2.1.5.1</ulink></para>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 7.1.2, 9.3.4</para>
		</refsection>

		  <refsection>
			<title>Examples</title>
			<para>Return length in feet for line string. Note this is in feet because 2249 is
				Mass State Plane Feet</para>
			<programlisting>
SELECT SELECT ST_Length(ST_GeomFromText('LINESTRING(743238 2967416,743238 2967450,743265 2967450,
743265.625 2967416,743238 2967416)',2249));
st_length
---------
 122.630744000095
(1 row)
			</programlisting>
		  </refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Perimeter" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_Length2D">
	  <refnamediv>
		<refname>ST_Length2D</refname>

		<refpurpose>Returns the 2-dimensional length of the geometry if it is a
				linestring or multi-linestring. This is an alias for <varname>ST_Length</varname></refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Length2D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_2dlinestring</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the 2-dimensional length of the geometry if it is a
				linestring or multi-linestring. This is an alias for <varname>ST_Length</varname></para>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Length" />, <xref linkend="ST_Length3D" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Length3D">
	  <refnamediv>
		<refname>ST_Length3D</refname>

		<refpurpose>Returns the 3-dimensional or 2-dimensional length of the geometry if it is a
			linestring or multi-linestring. </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Length3D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_3dlinestring</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the 3-dimensional or 2-dimensional length of the geometry if it is a
			linestring or multi-linestring. For 2-d lines it will just return the 2-d length (same as ST_Length and ST_Length2D)</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<para>Return length in feet for a 3D cable. Note this is in feet because 2249 is
				Mass State Plane Feet</para>
		<programlisting>
SELECT ST_Length3D(ST_GeomFromText('LINESTRING(743238 2967416 1,743238 2967450 1,743265 2967450 3,
743265.625 2967416 3,743238 2967416 3)',2249));
st_length3d
-----------
122.704716741457
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Length" />, <xref linkend="ST_Length2D" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Length_Spheroid">
	  <refnamediv>
		<refname>ST_Length_Spheroid</refname>

		<refpurpose>Calculates the 2D or 3D length of a linestring/multilinestring on an ellipsoid. This
			is useful if the coordinates of the geometry are in
			longitude/latitude and a length is desired without reprojection.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Length_Spheroid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
			<paramdef><type>spheroid </type> <parameter>a_spheroid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Calculates the length of a geometry on an ellipsoid. This
			is useful if the coordinates of the geometry are in
			longitude/latitude and a length is desired without reprojection.
			The ellipsoid is a separate database type and can be constructed
			as follows:</para>

		<literallayout>SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR
		  AXIS&gt;,&lt;INVERSE FLATTENING&gt;]</literallayout>


		<literallayout>SPHEROID["GRS_1980",6378137,298.257222101]</literallayout>
		<note><para>Will return 0 for anything that is not a MULTILINESTRING or LINESTRING</para></note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Length_Spheroid( geometry_column,
			  'SPHEROID["GRS_1980",6378137,298.257222101]' )
			  FROM geometry_table;

SELECT ST_Length_Spheroid( the_geom, sph_m ) As tot_len,
ST_Length_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,
ST_Length_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2
			  FROM (SELECT ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),
	(-71.05957 42.3589 , -71.061 43))') As the_geom,
CAST('SPHEROID["GRS_1980",6378137,298.257222101]' As spheroid) As sph_m)  as foo;
	tot_len      |    len_line1     |    len_line2
------------------+------------------+------------------
 85204.5207562955 | 13986.8725229309 | 71217.6482333646

 --3D
SELECT ST_Length_Spheroid( the_geom, sph_m ) As tot_len,
ST_Length_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,
ST_Length_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2
			  FROM (SELECT ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),
	(-71.05957 42.3589 75, -71.061 43 90))') As the_geom,
CAST('SPHEROID["GRS_1980",6378137,298.257222101]' As spheroid) As sph_m)  as foo;

	 tot_len      |    len_line1    |    len_line2
------------------+-----------------+------------------
 85204.5259107402 | 13986.876097711 | 71217.6498130292

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeometryN" />, <xref linkend="ST_Length" />, <xref linkend="ST_Length3D_Spheroid" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Length2D_Spheroid">
	  <refnamediv>
		<refname>ST_Length2D_Spheroid</refname>

		<refpurpose>Calculates the 2D length of a linestring/multilinestring on an ellipsoid. This
			is useful if the coordinates of the geometry are in
			longitude/latitude and a length is desired without reprojection.  </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Length2D_Spheroid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
			<paramdef><type>spheroid </type> <parameter>a_spheroid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Calculates the 2D length of a geometry on an ellipsoid. This
			is useful if the coordinates of the geometry are in
			longitude/latitude and a length is desired without reprojection.
			The ellipsoid is a separate database type and can be constructed
			as follows:</para>

		<literallayout>SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR
		  AXIS&gt;,&lt;INVERSE FLATTENING&gt;]</literallayout>


		<literallayout>SPHEROID["GRS_1980",6378137,298.257222101]</literallayout>
		<note><para>Will return 0 for anything that is not a MULTILINESTRING or LINESTRING</para></note>
		<note><para>This is much like <xref linkend="ST_Length_Spheroid" /> and <xref linkend="ST_Length3D_Spheroid" /> except it will throw away the Z coordinate in calculations.</para></note>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Length2D_Spheroid( geometry_column,
			  'SPHEROID["GRS_1980",6378137,298.257222101]' )
			  FROM geometry_table;

SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,
ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,
ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2
			  FROM (SELECT ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),
	(-71.05957 42.3589 , -71.061 43))') As the_geom,
CAST('SPHEROID["GRS_1980",6378137,298.257222101]' As spheroid) As sph_m)  as foo;
	tot_len      |    len_line1     |    len_line2
------------------+------------------+------------------
 85204.5207562955 | 13986.8725229309 | 71217.6482333646

 --3D Observe same answer
SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,
ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,
ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2
			  FROM (SELECT ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),
	(-71.05957 42.3589 75, -71.061 43 90))') As the_geom,
CAST('SPHEROID["GRS_1980",6378137,298.257222101]' As spheroid) As sph_m)  as foo;

	tot_len      |    len_line1     |    len_line2
------------------+------------------+------------------
 85204.5207562955 | 13986.8725229309 | 71217.6482333646

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeometryN" />, <xref linkend="ST_Length_Spheroid" />, <xref linkend="ST_Length3D_Spheroid" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Length3D_Spheroid">
	  <refnamediv>
		<refname>ST_Length3D_Spheroid</refname>

		<refpurpose>Calculates the length of a geometry on an ellipsoid,
			taking the elevation into account. This is just an alias for ST_Length_Spheroid. </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Length3D_Spheroid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
			<paramdef><type>spheroid </type> <parameter>a_spheroid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Calculates the length of a geometry on an ellipsoid,
			taking the elevation into account. This is just an alias
			for ST_Length_Spheroid. </para>

		<note><para>Will return 0 for anything that is not a MULTILINESTRING or LINESTRING</para></note>
		<note><para>This functionis just an alias for ST_Length_Spheroid. </para></note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>See ST_Length_Spheroid</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeometryN" />, <xref linkend="ST_Length" />, <xref linkend="ST_Length_Spheroid" /></para>
	  </refsection>
	</refentry>




	<refentry id="ST_Max_Distance">
	  <refnamediv>
		<refname>ST_Max_Distance</refname>

		<refpurpose>Returns the 2-dimensional largest distance between two geometries in
		projected units.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Max_Distance</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>g1</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>g2</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the 2-dimensional maximum cartesian distance between two linestrings in
		projected units.</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>--ALL EXAMPLES current throw NOT YET IMPLEMENTED</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Distance"/></para>
	  </refsection>
	</refentry>


	<refentry id="ST_OrderingEquals">
	  <refnamediv>
		<refname>ST_OrderingEquals</refname>

		<refpurpose>Returns true if the given geometries represent the same geometry
		and points are in the same directional order.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_OrderingEquals</function></funcdef>
			<paramdef><type>geometry </type> <parameter>A</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>ST_OrderingEquals compares two geometries and t (TRUE) if the
		  geometries are equal and the coordinates are in the same order;
		  otherwise it returns f (FALSE).</para>

		<note>
			<para>This function is implemented as per the ArcSDE SQL
		specification rather than SQL-MM.
		http://edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3.htm#ST_OrderingEquals</para>
		</note>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the SQL/MM specification: SQL-MM 3: 5.1.43
		</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),
		ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));
 st_orderingequals
-----------
 f
(1 row)

SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),
		ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));
 st_orderingequals
-----------
 t
(1 row)

SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),
		ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));
 st_orderingequals
-----------
 f
(1 row)
</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Equals"/>, <xref linkend="ST_Reverse"/></para>
		  </refsection>
	</refentry>

	<refentry id="ST_Overlaps">
	  <refnamediv>
		<refname>ST_Overlaps</refname>

		<refpurpose>Returns TRUE if the Geometries share space, are of the same dimension, but are not completely contained by each other.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Overlaps</function></funcdef>
			<paramdef><type>geometry </type> <parameter>A</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns TRUE if the Geometries "spatially
			overlap".  By that we mean they intersect, but one does not completely contain another. </para>

		 <para>Performed by the GEOS module</para>

		<note><para>Do not call with a GeometryCollection as an argument</para></note>

		<para>This function call will automatically include a bounding box
		comparison that will make use of any indexes that are available on
		the geometries. To avoid index use, use the function
		_ST_Overlaps.</para>

		<para>NOTE: this is the "allowable" version that returns a
			boolean, not an integer.</para>

		<para>OGC SPEC s2.1.1.2 // s2.1.13.3</para>

		<para>
		  <inlinegraphic fileref="images/check.png" />
		  This method implements the SQL/MM specification: SQL-MM 3: 5.1.32
		</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>--a point on a line is contained by the line and is of a lower dimension, and therefore does not overlap the line
			nor crosses

SELECT ST_Overlaps(a,b) As a_overlap_b,
	ST_Crosses(a,b) As a_crosses_b,
		ST_Intersects(a, b) As a_intersects_b, ST_Contains(b,a) As b_contains_a
FROM (SELECT ST_GeomFromText('POINT(1 0.5)') As a, ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)
	As foo

a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a
------------+-------------+----------------+--------------
f           | f           | t              | t

--a line that is partly contained by circle, but not fully is defined as intersecting and crossing,
-- but since of different dimension it does not overlap
SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b,
	ST_Intersects(a, b) As a_intersects_b,
	ST_Contains(a,b) As a_contains_b
FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a, ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)
	As foo;

 a_overlap_b | a_crosses_b | a_intersects_b | a_contains_b
-------------+-------------+----------------+--------------
 f           | t           | t              | f

 -- a 2-dimensional bent hot dog (aka puffered line string) that intersects a circle,
 --	but is not fully contained by the circle is defined as overlapping since they are of the same dimension,
--	but it does not cross, because the intersection of the 2 is of the same dimension
--	as the maximum dimension of the 2

SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b, ST_Intersects(a, b) As a_intersects_b,
ST_Contains(b,a) As b_contains_a,
ST_Dimension(a) As dim_a, ST_Dimension(b) as dim_b, ST_Dimension(ST_Intersection(a,b)) As dima_intersection_b
FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a,
	ST_Buffer(ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)'),0.5)  As b)
	As foo;

 a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a | dim_a | dim_b | dima_intersection_b
-------------+-------------+----------------+--------------+-------+-------+---------------------
 t           | f           | t              | f            |     2 |     2 |              2
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Contains"/>, <xref linkend="ST_Crosses"/>, <xref linkend="ST_Dimension"/>, <xref linkend="ST_Intersects"/></para>
	  </refsection>
	</refentry>
	<refentry id="ST_Perimeter">
		<refnamediv>
		  <refname>ST_Perimeter</refname>

		  <refpurpose>Return the length measurement of the boundary of an ST_Surface
		  or ST_MultiSurface value. (Polygon, Multipolygon)</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
		  <funcsynopsis>
			<funcprototype>
			  <funcdef>float <function>ST_Perimeter</function></funcdef>
				<paramdef><type>geometry </type><parameter>g1</parameter></paramdef>
			</funcprototype>
		  </funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>

			<para>Returns the 2D perimeter of the geometry if it is a ST_Surface, ST_MultiSurface (Polygon, Multipolygon).  0 is returned for
				non-areal geometries.  For linestrings use ST_Length.  Measurements are in the units of the
				spatial reference system of the geometry.</para>

			<para>Currently this is an alias for ST_Perimeter2D, but this may change to support higher dimensions.</para>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the <ulink
			url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
			Implementation Specification for SQL. OGC SPEC 2.1.5.1</ulink></para>

			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 8.1.3, 9.5.4</para>
		</refsection>

		  <refsection>
			<title>Examples</title>
			<para>Return perimeter in feet for polygon and multipolygon. Note this is in feet because 2249 is
				Mass State Plane Feet</para>
			<programlisting>
SELECT ST_Perimeter(ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,743265 2967450,
743265.625 2967416,743238 2967416))', 2249));
st_perimeter
---------
 122.630744000095
(1 row)

SELECT ST_Perimeter(ST_GeomFromText('MULTIPOLYGON(((763104.471273676 2949418.44119003,
763104.477769673 2949418.42538203,
763104.189609677 2949418.22343004,763104.471273676 2949418.44119003)),
((763104.471273676 2949418.44119003,763095.804579742 2949436.33850239,
763086.132105649 2949451.46730207,763078.452329651 2949462.11549407,
763075.354136904 2949466.17407812,763064.362142565 2949477.64291974,
763059.953961626 2949481.28983009,762994.637609571 2949532.04103014,
762990.568508415 2949535.06640477,762986.710889563 2949539.61421415,
763117.237897679 2949709.50493431,763235.236617789 2949617.95619822,
763287.718121842 2949562.20592617,763111.553321674 2949423.91664605,
763104.471273676 2949418.44119003)))', 2249));
st_perimeter
---------
 845.227713366825
(1 row)
			</programlisting>
		  </refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Length" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_Perimeter2D">
	  <refnamediv>
		<refname>ST_Perimeter2D</refname>

		<refpurpose>Returns the 2-dimensional perimeter of the geometry, if it
			is a polygon or multi-polygon.  This is currently an alias for ST_Perimeter.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Perimeter2D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the 2-dimensional perimeter of the geometry, if it
			is a polygon or multi-polygon. </para>

		<!-- optionally mention that this function uses indexes if appropriate -->
		<note>
		  <para> This is currently an alias for ST_Perimeter. In future versions ST_Perimeter may return the highest dimension perimeter for a geometry.  This is still under consideration</para>
		</note>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Perimeter" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Perimeter3D">
	  <refnamediv>
		<refname>ST_Perimeter3D</refname>

		<refpurpose>Returns the 3-dimensional perimeter of the geometry, if it
			is a polygon or multi-polygon.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_Perimeter3D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the 3-dimensional perimeter of the geometry, if it
			is a polygon or multi-polygon. If the geometry is 2-dimensional, then the 2-dimensional perimeter is returned.  </para>


		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
		<para>Perimeter of a slightly elevated polygon in the air in Massachusetts state plane feet</para>
		<programlisting>SELECT ST_Perimeter3D(the_geom), ST_Perimeter2d(the_geom), ST_Perimeter(the_geom) FROM
			(SELECT ST_GeomFromEWKT('SRID=2249;POLYGON((743238 2967416 2,743238 2967450 1,
743265.625 2967416 1,743238 2967416 2))') As the_geom) As foo;

  st_perimeter3d  |  st_perimeter2d  |   st_perimeter
------------------+------------------+------------------
 105.465793597674 | 105.432997272188 | 105.432997272188

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_Perimeter" />, <xref linkend="ST_Perimeter2D" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_PointOnSurface">
	  <refnamediv>
		<refname>ST_PointOnSurface</refname>

		<refpurpose>Returns a <varname>POINT</varname> guaranteed to lie on the surface.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_PointOnSurface</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a <varname>POINT</varname> guaranteed to intersect a surface.</para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		Features Implementation Specification for SQL: 3.2.14.2, 3.2.18.2</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM
		specification: SQL-MM 3: 8.1.5, 9.5.6.
		 According to the specs, ST_PointOnSurface works for surface geometries (POLYGONs, MULTIPOLYGONS, CURVED POLYGONS).  So PostGIS seems to be extending what
		 the spec allows here.  Most databases Oracle,DB II, ESRI SDE seem to only support this function for surfaces.  SQL Server 2008 like PostGIS supports for all common geometries.
	</para>

			<!-- Optionally mention 3d support -->
	<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This function supports 3d (only for POINT,MULTIPOINT, LINESTRING, MULTILINESTRING) and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));
 st_astext
------------
 POINT(0 5)
(1 row)

SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));
 st_astext
------------
 POINT(0 5)
(1 row)

SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::geometry));
   st_astext
----------------
 POINT(2.5 2.5)
(1 row)

SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 1, 0 10 2)')));
   st_asewkt
----------------
 POINT(0 0 1)
(1 row)
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Centroid" />, <xref linkend="ST_Point_Inside_Circle" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Relate">
	  <refnamediv>
		<refname>ST_Relate</refname>

		<refpurpose>Returns true if this Geometry is spatially related to
				anotherGeometry, by testing for intersections between the
				Interior, Boundary and Exterior of the two geometries as specified
				by the values in the intersectionMatrixPattern.  If no intersectionMatrixPattern
				is passed in, then returns the maximum intersectionMatrixPattern that relates the 2 geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Relate</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
			<paramdef><type>text </type> <parameter>intersectionMatrixPattern</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>ST_Relate</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Version 1: Takes geomA, geomB, intersectionMatrix and Returns 1 (TRUE) if this Geometry is spatially related to
				anotherGeometry, by testing for intersections between the
				Interior, Boundary and Exterior of the two geometries as specified
				by the values in the <ulink url="http://docs.codehaus.org/display/GEOTDOC/Point+Set+Theory+and+the+DE-9IM+Matrix#PointSetTheoryandtheDE-9IMMatrix-9IntersectionMatrix">intersectionMatrixPattern</ulink>.</para>

		<para>This is especially useful for testing compound checks of intersection, crosses, etc in one step.</para>
		<para>Do not call with a GeometryCollection as an argument</para>

		<note><para>This is the "allowable" version that returns a
		boolean, not an integer.  This is defined in OGC spec</para></note>

		<note><para>This DOES NOT automagically include an index call.  The reason for that
			is some relationships are anti e.g. Disjoint.  If you are
			using a relationship pattern that requires intersection, then include the &amp;&amp;
			index call.</para></note>

		<para>Version 2: Takes geomA and geomB and returns the <ulink url="http://docs.codehaus.org/display/GEOTDOC/Point+Set+Theory+and+the+DE-9IM+Matrix#PointSetTheoryandtheDE-9IMMatrix-9IntersectionMatrix">DE-9IM (dimensionally extended nine-intersection
		matrix)</ulink></para>

		<note><para>Do not call with a GeometryCollection as an argument</para></note>

		<para>not in OGC spec, but implied. see s2.1.13.2</para>

		<para>Both Performed by the GEOS module</para>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink> OGC SPEC s2.1.1.2 // s2.1.13.3</para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.25</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>
		<programlisting>
--Find all compounds that intersect and not touch a poly (interior intersects)
SELECT l.* , b.name As poly_name
FROM polys As b
	INNER JOIN compounds As l
	ON (p.the_geom &amp;&amp; b.the_geom
	AND ST_Relate(l.the_geom, b.the_geom,'T********'));

SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2));
 st_relate
-----------
 0FFFFF212

SELECT ST_Relate(ST_GeometryFromText('LINESTRING(1 2, 3 4)'), ST_GeometryFromText('LINESTRING(5 6, 7 8)'));
 st_relate
-----------
 FF1FF0102


SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '0FFFFF212');
 st_relate
-----------
 t

SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '*FF*FF212');
 st_relate
-----------
 t
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Crosses" />, <xref linkend="ST_Disjoint" />, <xref linkend="ST_Intersects" />, <xref linkend="ST_Touches" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Touches">
	  <refnamediv>
		<refname>ST_Touches</refname>

		<refpurpose>Returns <varname>TRUE</varname> if the geometries have at least one point in common,
		but their interiors do not intersect.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Touches</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>g1</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>g2</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns <varname>TRUE</varname> if the only points in common between
		<parameter>g1</parameter> and <parameter>g2</parameter> lie in the union of the
		boundaries of <parameter>g1</parameter> and <parameter>g2</parameter>.
		The <function>ST_Touches</function> relation applies
		to all Area/Area, Line/Line, Line/Area, Point/Area and Point/Line pairs of relationships,
		but <emphasis>not</emphasis> to the Point/Point pair.</para>

		<para>In mathematical terms, this predicate is expressed as:</para>

		<remark>TODO: Insert appropriate MathML markup here or use a gif.
		Simple HTML markup does not work well in both IE and Firefox.</remark>

		<informalfigure>
		  <mediaobject>
			<imageobject>
			  <imagedata fileref="images/st_touches-math.gif" />
			</imageobject>
		  </mediaobject>
		</informalfigure>

		<para>The allowable DE-9IM Intersection Matrices for the two geometries are:</para>

		<itemizedlist>
		  <listitem>
			<para><markup>FT*******</markup></para>
		  </listitem>

		  <listitem>
			<para><markup>F**T*****</markup></para>
		  </listitem>

		  <listitem>
			<para><markup>F***T****</markup></para>
		  </listitem>
		</itemizedlist>

		<important>
		  <para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		</important>

		<note>
		  <para>This function call will automatically include a bounding box
		  comparison that will make use of any indexes that are available on
		  the geometries.  To avoid using an index, use <function>_ST_Touches</function> instead.</para>
		</note>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
		Features Implementation Specification for SQL: 2.1.1.2, 2.1.13.3</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM
		specification: SQL-MM 3: 5.1.28</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<para>The <function>ST_Touches</function> predicate returns <varname>TRUE</varname> in all the following illustrations.</para>
		<informaltable>
		  <tgroup cols="3">
			<tbody>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_touches01.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>POLYGON</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>

				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_touches02.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>POLYGON</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>

				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_touches03.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>LINESTRING</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>
			  </row>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_touches04.png" />
					  </imageobject>

					  <caption><para><varname>LINESTRING</varname> / <varname>LINESTRING</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>

				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_touches05.png" />
					  </imageobject>

					  <caption><para><varname>LINESTRING</varname> / <varname>LINESTRING</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>

				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_touches06.png" />
					  </imageobject>

					  <caption><para><varname>POLYGON</varname> / <varname>POINT</varname></para></caption>
					</mediaobject>
				  </informalfigure></para></entry>
			  </row>
			</tbody>
		  </tgroup>
		</informaltable>

		<programlisting>SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::geometry);
 st_touches
------------
 f
(1 row)

SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::geometry);
 st_touches
------------
 t
(1 row)</programlisting>
	  </refsection>
	</refentry>

	<refentry id="ST_Within">
	  <refnamediv>
		<refname>ST_Within</refname>

		<refpurpose>Returns true if the geometry A is completely inside geometry B</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Within</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>A</parameter></paramdef>

			<paramdef><type>geometry </type>
			<parameter>B</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns TRUE if geometry A is completely inside geometry B. For this function to make
		sense, the source geometries must both be of the same coordinate projection,
		having the same SRID.  It is a given that if ST_Within(A,B) is true and ST_Within(B,A) is true, then
		the two geometries are considered spatially equal.</para>

		<para>Performed by the GEOS module</para>

		<important>
		  <para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		</important>

		<important>
		  <para>Do not use this function with invalid geometries. You will get unexpected results.</para>
		</important>

		<para>This function call will automatically include a bounding box
			comparison that will make use of any indexes that are available on
			the geometries. To avoid index use, use the function
			_ST_Within.</para>

		<para>NOTE: this is the "allowable" version that returns a
			boolean, not an integer.</para>

		<para>
		  <inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
	  </inlinemediaobject> This method implements the
	  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
	Implementation Specification for SQL.</ulink>
		   OGC SPEC s2.1.1.2 // s2.1.13.3 - a.Relate(b,
			'T*F**F***')
		</para>

		<para>
			<inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification:
			SQL-MM 3: 5.1.30</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		  <programlisting>
--a circle within a circle
SELECT ST_Within(smallc,smallc) As smallinsmall,
	ST_Within(smallc, bigc) As smallinbig,
	ST_Within(bigc,smallc) As biginsmall,
	ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,
	ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,
	ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion
FROM
(
SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,
	ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;
--Result
 smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | bigisunion
--------------+------------+------------+------------+------------+------------
 t            | t          | f          | t          | t          | t
(1 row)
		</programlisting>

		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/st_within01.png" />
		</imageobject>
	  </inlinemediaobject> </para>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Contains"/>, <xref linkend="ST_Equals"/>,<xref linkend="ST_IsValid"/></para>
	  </refsection>
	</refentry>
  </sect1>

	<sect1 id="Geometry_Processing">
		<title>Geometry Processing Functions</title>
		<refentry id="ST_Buffer">
			<refnamediv>
				<refname>ST_Buffer</refname>

				<refpurpose>Returns a geometry that represents all points whose distance
			from this Geometry is less than or equal to distance. Calculations
			are in the Spatial Reference System of this Geometry. The optional
			third parameter sets the number of segments used to approximate a
			quarter circle (defaults to 8).</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<funcsynopsis>
				  <funcprototype>
					<funcdef>geometry <function>ST_Buffer</function></funcdef>
					<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geometry <function>ST_Buffer</function></funcdef>
					<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
				  </funcprototype>

				</funcsynopsis>
			</refsynopsisdiv>

			  <refsection>
				<title>Description</title>

				<para>Returns a geometry that represents all points whose distance
			from this Geometry is less than or equal to distance. Calculations
			are in the Spatial Reference System of this Geometry. The optional
			third parameter sets the number of segments used to approximate a
			quarter circle (defaults to 8).
				</para>
				<para>Units are always measured in units of the spatial reference system.</para>
				<para>The inputs can be POINTS, MULTIPOINTS, LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.</para>
				<note><para>This function ignores the third dimension (z) and will always give a 2-d buffer even when presented with a 3d-geometry.</para></note>

				<para>Performed by the GEOS module.</para>

				<!-- Optionally mention OpenGIS compliancy if appropriate -->
				<para><inlinemediaobject>
					<imageobject>
					  <imagedata fileref="images/check.png" />
					</imageobject>
				  </inlinemediaobject> This method implements the <ulink
				url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
				Implementation Specification for SQL.</ulink>
				OGC SPEC s2.1.1.3</para>

				<!-- Optionally mention SQL/MM compliancy if appropriate -->
				<para><inlinemediaobject>
					<imageobject>
					  <imagedata fileref="images/check.png" />
					</imageobject>
				  </inlinemediaobject> This method implements the SQL/MM specification:
				SQL-MM 3: 5.1.17</para>

				<note><para>People often make the mistake of using this function to try to do radius searches.  Creating a
					buffer to to a radius search is slow and pointless.  Use <xref linkend="ST_DWithin" /> instead.</para></note>
			</refsection>

			  <refsection>
				<title>Examples</title>

				<informaltable>
				  <tgroup cols="2">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer01.png" />
							  </imageobject>
							  <caption><para>Default 8 segments quarter circle (promising)</para></caption>
							</mediaobject>
						  </informalfigure></para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer02.png" />
							  </imageobject>
							  <caption><para>2 segments quarter circle (lame)</para></caption>
							</mediaobject>
						  </informalfigure></para></entry>
					  </row>
					</tbody>
				  </tgroup>
			</informaltable>

<programlisting>--A buffered point approximates a circle
-- A buffered point forcing approximation of (see diagram)
-- 2 points per circle is poly with 8 sides (see diagram)
SELECT ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As promisingcircle_pcount,
ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50, 2)) As lamecircle_pcount;

promisingcircle_pcount | lamecircle_pcount
------------------------+-------------------
			 33 |                9

--A lighter but lamer circle
-- only 2 points per quarter circle is an octagon
--Below is a 100 meter octagon
-- Note coordinates are in NAD 83 long lat which we transform
to Mass state plane meter and then buffer to get measurements in meters;
SELECT ST_AsText(ST_Buffer(
ST_Transform(
ST_SetSRID(ST_MakePoint(-71.063526, 42.35785),4269), 26986)
,100,2)) As octagon;
----------------------
POLYGON((236057.59057465 900908.759918696,236028.301252769 900838.049240578,235
957.59057465 900808.759918696,235886.879896532 900838.049240578,235857.59057465
900908.759918696,235886.879896532 900979.470596815,235957.59057465 901008.759918
696,236028.301252769 900979.470596815,236057.59057465 900908.759918696))

--Buffer is often also used as a poor man's polygon fixer or a sometimes speedier unioner
--Sometimes able to fix invalid polygons - using below
-- using below on anything but a polygon will result in empty geometry
-- and for geometry collections kill anything in the collection that is not a polygon
--Poor man's bad poly fixer
SELECT ST_IsValid(foo.invalidpoly)  as isvalid, ST_IsValid(ST_Buffer(foo.invalidpoly,0.0)) as bufferisvalid,
ST_AsText(ST_Buffer(foo.invalidpoly,0.0)) As newpolytextrep
FROM (SELECT ST_GeomFromText('POLYGON((-1 2, 3 4, 5 6, -1 2, 5 6, -1 2))') as invalidpoly) As foo
NOTICE:  Self-intersection at or near point -1 2
isvalid | bufferisvalid |        newpolytextrep
---------+---------------+------------------------------
f       | t             | POLYGON((-1 2,5 6,3 4,-1 2))

--Poor man's polygon unioner
SELECT ST_AsText(the_geom) as textorig, ST_AsText(ST_Buffer(foo.the_geom,0.0)) As textbuffer
FROM (SELECT ST_Collect('POLYGON((-1 2, 3 4, 5 6, -1 2))', 'POLYGON((-1 2, 2 3, 5 6, -1 2))') As the_geom) as foo;
				 textorig                          |            textbuffer
-----------------------------------------------------------+--------------------
MULTIPOLYGON(((-1 2,3 4,5 6,-1 2)),((-1 2,2 3,5 6,-1 2))) | POLYGON((-1 2,5 6,3 4,2 3,-1 2))


		</programlisting>
			  </refsection>

			  <refsection>
				<title>See Also</title>

				<para><xref linkend="ST_Collect" />, <xref linkend="ST_DWithin" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_Transform" />, <xref linkend="ST_Union" /></para>
			  </refsection>
		</refentry>

		<refentry id="ST_BuildArea">
		  <refnamediv>
			<refname>ST_BuildArea</refname>

			<refpurpose>Creates an areal geometry formed by the constituent linework
			of given geometry</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>boolean <function>ST_BuildArea</function></funcdef>
				<paramdef><type>geometry </type> <parameter>A</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Creates an areal geometry formed by the constituent linework
			of given geometry. The return type can be a Polygon or
			MultiPolygon, depending on input. If the input lineworks do not
			form polygons NULL is returned.  The inputs can be LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.
			</para>
			<para>This function will assume all inner geometries represent holes</para>
			<para>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0.</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<informaltable>
				  <tgroup cols="1">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buildarea01.png" />
							  </imageobject>
							  <caption><para>This will create a donut</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_BuildArea(ST_Collect(smallc,bigc))
FROM (SELECT
	ST_Buffer(
	  ST_GeomFromText('POINT(100 90)'), 25) As smallc,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;
				</programlisting>
						  </para></entry>
					</row>
					<row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buildarea02.png" />
							  </imageobject>
							  <caption><para>This will create a gaping hole inside the circle with prongs sticking out</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_BuildArea(ST_Collect(line,circle))
FROM (SELECT
	ST_Buffer(
		ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)),
				5)  As line,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

--this creates the same gaping hole
--but using linestrings instead of polygons
SELECT ST_BuildArea(
	ST_Collect(ST_ExteriorRing(line),ST_ExteriorRing(circle))
	)
FROM (SELECT ST_Buffer(
	ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190))
		,5)  As line,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

				</programlisting>
						</para></entry>
					  </row>
					</tbody>
				  </tgroup>
			</informaltable>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
			<xref linkend="ST_BdPolyFromText" />,
			<xref linkend="ST_BdMPolyFromText" /> wrappers to
			this function with standard OGC interface</para>
		  </refsection>
	</refentry>
	<refentry id="ST_Collect">
	  <refnamediv>
		<refname>ST_Collect</refname>
		<refpurpose>Return a specified ST_Geometry value from a collection of other geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>geometry <function>ST_Collect</function></funcdef>
				<paramdef><type>geometry set</type> <parameter>g1field</parameter></paramdef>
			</funcprototype>
			<funcprototype>
			<funcdef>geometry <function>ST_Collect</function></funcdef>
				<paramdef><type>geometry</type> <parameter>g1</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>g2</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>geometry <function>ST_Collect</function></funcdef>
				<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para> Output type can be a MULTI* or a
			GEOMETRYCOLLECTION. Comes in 2 variants.  Variant 1 collects 2 geometries. Variant 2 is an aggregate function that takes a set of geometries and collects
			them into a single ST_Geometry.</para>

		<para>Aggregate version: This function returns a GEOMETRYCOLLECTION or a MULTI object
			from a set of geometries. The ST_Collect() function is an "aggregate"
			function in the terminology of PostgreSQL. That means that it
			operates on rows of data, in the same way the SUM() and AVG()
			functions do. For example, "SELECT ST_Collect(GEOM) FROM GEOMTABLE
			GROUP BY ATTRCOLUMN" will return a separate GEOMETRYCOLLECTION for
			each distinct value of ATTRCOLUMN.</para>

		<para>Non-Aggregate version: This function returns a geometry being a collection of two
			input geometries. Output type can be a MULTI* or a
			GEOMETRYCOLLECTION.</para>

		<note><para>ST_Collect and ST_Union are often interchangeable.
			ST_Collect is in general orders of magnitude faster than ST_Union
			because it does not try to dissolve boundaries or validate that a constructed MultiPolgon doesn't
			have overlapping regions. It merely rolls up
			single geometries into MULTI and MULTI or mixed geometry types
			into Geometry Collections. Unfortunately geometry collections are
			not well-supported by GIS tools. To prevent ST_Collect from
			returning a Geometry Collection when collecting MULTI geometries,
			one can use the below trick that utilizes <xref linkend="ST_Dump" /> to expand the
			MULTIs out to singles and then regroup them.</para></note>

		<para>Availability: 1.4.0 -  ST_Collect(geomarray) was introduced. ST_Collect was enhanced to handle more geometries faster.</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		  <!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves,
		  but will never return a MULTICURVE or MULTI as one would expect and PostGIS does not currently support those.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Aggregate example</para>
			<programlisting>Thread ref: http://postgis.refractions.net/pipermail/postgis-users/2008-June/020331.html
SELECT stusps,
	   ST_Multi(ST_Collect(f.the_geom)) as singlegeom
	 FROM (SELECT stusps, (ST_Dump(the_geom)).geom As the_geom
				FROM
				somestatetable ) As f
GROUP BY stusps</programlisting>
		<para>Non-Aggregate example</para>
			<programlisting>Thread ref: http://postgis.refractions.net/pipermail/postgis-users/2008-June/020331.html
SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),
	ST_GeomFromText('POINT(-2 3)') ));

st_astext
----------
MULTIPOINT(1 2,-2 3)

--Collect 2 d points
SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),
		ST_GeomFromText('POINT(1 2)') ) );

st_astext
----------
MULTIPOINT(1 2,1 2)

--Collect 3d points
SELECT ST_AsEWKT(ST_Collect(ST_GeomFromEWKT('POINT(1 2 3)'),
		ST_GeomFromEWKT('POINT(1 2 4)') ) );

		st_asewkt
-------------------------
 MULTIPOINT(1 2 3,1 2 4)

 --Example with curves
SELECT ST_AsText(ST_Collect(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)'),
ST_GeomFromText('CIRCULARSTRING(220227 150406,2220227 150407,220227 150406)')));
																st_astext
------------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(CIRCULARSTRING(220268 150415,220227 150505,220227 150406),
 CIRCULARSTRING(220227 150406,2220227 150407,220227 150406))

--New ST_Collect array construct
SELECT ST_Collect(ARRAY(SELECT the_geom FROM sometable));

SELECT ST_AsText(ST_Collect(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),
			ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As wktcollect;

--wkt collect --
MULTILINESTRING((1 2,3 4),(3 4,4 5))

</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Dump" />, <xref linkend="ST_Union" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_ConvexHull">
	  <refnamediv>
		<refname>ST_ConvexHull</refname>
		<refpurpose>The convex hull of a geometry represents the minimum convex
		geometry that encloses all geometries within the set.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ConvexHull</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>The convex hull of a geometry represents the minimum convex
		geometry that encloses all geometries within the set.</para>

		<para>One can think of the convex hull as the geometry you get by wrapping an elastic
			band around a set of geometries.  This is different from a concave hull (not currently supported)
				which is analogous to shrink-wrapping your geometries.</para>

			<para>It is usually used with MULTI and Geometry Collections.
		Although it is not an aggregate - you can use it in conjunction
		with ST_Collect to get the convex hull of a set of points.
		ST_ConvexHull(ST_Collect(somepointfield)).</para>

		<para>It is often used to
		determine an affected area based on a set of point
		observations.</para>

		<para>Performed by the GEOS module</para>

		<para>
			  <inlinegraphic fileref="images/check.png" />
			  This method implements the
			  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
			  Features Implementation Specification for SQL</ulink>  OGC SPEC s2.1.1.3
		</para>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
		</inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.16</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
	ST_ConvexHull(ST_Collect(d.the_geom)) As the_geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>

<para>
	<informalfigure>
	  <mediaobject>
		<imageobject>
		  <imagedata fileref="images/st_convexhull01.png" />
		</imageobject>
		<caption><para>Convex Hull of a MultiLinestring and a MultiPoint seen together with the MultiLinestring and MultiPoint</para></caption>
	  </mediaobject>
	</informalfigure>
	<programlisting>
SELECT ST_AsText(ST_ConvexHull(
	ST_Collect(
		ST_GeomFromText('MULTILINESTRING((100 190,10 8),(150 10, 20 30))'),
			ST_GeomFromText('MULTIPOINT(50 5, 150 30, 50 10, 10 10)')
			)) );
---st_astext--
POLYGON((50 5,10 8,10 10,100 190,150 30,150 10,50 5))
	</programlisting>
</para>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_CurveToLine">
	  <refnamediv>
		<refname>ST_CurveToLine</refname>

		<refpurpose>Converts a CIRCULARSTRING/CURVEDPOLYGON to a LINESTRING/POLYGON</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_CurveToLine</function></funcdef>
			<paramdef><type>geometry</type> <parameter>curveGeom</parameter></paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>geometry <function>ST_CurveToLine</function></funcdef>
			<paramdef><type>geometry</type> <parameter>curveGeom</parameter></paramdef>
			<paramdef><type>integer</type> <parameter>segments_per_qtr_circle</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converst a CIRCULAR STRING to regular LINESTRING or CURVEPOLYGON to POLYGON. Useful for outputting to devices that can't support CIRCULARSTRING geometry types</para>
		<para>Converts a given geometry to a linear geometry.
		Each curved geometry or segment is converted into a linear approximation using the default value of 32 segments per quarter circle</para>
		<para>Availability: 1.2.2?</para>
		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink></para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 7.1.7 </para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		 <!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)')));

--Result --
 LINESTRING(220268 150415,220269.95064912 150416.539364228,220271.823415575 150418.17258804,220273.613787707 150419.895736857,
 220275.317452352 150421.704659462,220276.930305234 150423.594998003,220278.448460847 150425.562198489,
 220279.868261823 150427.60152176,220281.186287736 150429.708054909,220282.399363347 150431.876723113,
 220283.50456625 150434.10230186,220284.499233914 150436.379429536,220285.380970099 150438.702620341,220286.147650624 150441.066277505,
 220286.797428488 150443.464706771,220287.328738321 150445.892130112,220287.740300149 150448.342699654,
 220288.031122486 150450.810511759,220288.200504713 150453.289621251,220288.248038775 150455.77405574,
 220288.173610157 150458.257830005,220287.977398166 150460.734960415,220287.659875492 150463.199479347,
 220287.221807076 150465.64544956,220286.664248262 150468.066978495,220285.988542259 150470.458232479,220285.196316903 150472.81345077,
 220284.289480732 150475.126959442,220283.270218395 150477.39318505,220282.140985384 150479.606668057,
 220280.90450212 150481.762075989,220279.5637474 150483.85421628,220278.12195122 150485.87804878,
 220276.582586992 150487.828697901,220274.949363179 150489.701464356,220273.226214362 150491.491836488,
 220271.417291757 150493.195501133,220269.526953216 150494.808354014,220267.559752731 150496.326509628,
 220265.520429459 150497.746310603,220263.41389631 150499.064336517,220261.245228106 150500.277412127,
 220259.019649359 150501.38261503,220256.742521683 150502.377282695,220254.419330878 150503.259018879,
 220252.055673714 150504.025699404,220249.657244448 150504.675477269,220247.229821107 150505.206787101,
 220244.779251566 150505.61834893,220242.311439461 150505.909171266,220239.832329968 150506.078553494,
 220237.347895479 150506.126087555,220234.864121215 150506.051658938,220232.386990804 150505.855446946,
 220229.922471872 150505.537924272,220227.47650166 150505.099855856,220225.054972724 150504.542297043,
 220222.663718741 150503.86659104,220220.308500449 150503.074365683,
 220217.994991777 150502.167529512,220215.72876617 150501.148267175,
 220213.515283163 150500.019034164,220211.35987523 150498.7825509,
 220209.267734939 150497.441796181,220207.243902439 150496,
 220205.293253319 150494.460635772,220203.420486864 150492.82741196,220201.630114732 150491.104263143,
 220199.926450087 150489.295340538,220198.313597205 150487.405001997,220196.795441592 150485.437801511,
 220195.375640616 150483.39847824,220194.057614703 150481.291945091,220192.844539092 150479.123276887,220191.739336189 150476.89769814,
 220190.744668525 150474.620570464,220189.86293234 150472.297379659,220189.096251815 150469.933722495,
 220188.446473951 150467.535293229,220187.915164118 150465.107869888,220187.50360229 150462.657300346,
 220187.212779953 150460.189488241,220187.043397726 150457.710378749,220186.995863664 150455.22594426,
 220187.070292282 150452.742169995,220187.266504273 150450.265039585,220187.584026947 150447.800520653,
 220188.022095363 150445.35455044,220188.579654177 150442.933021505,220189.25536018 150440.541767521,
 220190.047585536 150438.18654923,220190.954421707 150435.873040558,220191.973684044 150433.60681495,
 220193.102917055 150431.393331943,220194.339400319 150429.237924011,220195.680155039 150427.14578372,220197.12195122 150425.12195122,
 220198.661315447 150423.171302099,220200.29453926 150421.298535644,220202.017688077 150419.508163512,220203.826610682 150417.804498867,
 220205.716949223 150416.191645986,220207.684149708 150414.673490372,220209.72347298 150413.253689397,220211.830006129 150411.935663483,
 220213.998674333 150410.722587873,220216.22425308 150409.61738497,220218.501380756 150408.622717305,220220.824571561 150407.740981121,
 220223.188228725 150406.974300596,220225.586657991 150406.324522731,220227 150406)

--3d example
SELECT ST_AsEWKT(ST_CurveToLine(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)')));
Output
------
 LINESTRING(220268 150415 1,220269.95064912 150416.539364228 1.0181172856673,
 220271.823415575 150418.17258804 1.03623457133459,220273.613787707 150419.895736857 1.05435185700189,....AD INFINITUM ....
	220225.586657991 150406.324522731 1.32611114201132,220227 150406 3)

--use only 2 segments to approximate quarter circle
SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)'),2));
st_astext
------------------------------
 LINESTRING(220268 150415,220287.740300149 150448.342699654,220278.12195122 150485.87804878,
 220244.779251566 150505.61834893,220207.243902439 150496,220187.50360229 150462.657300346,
 220197.12195122 150425.12195122,220227 150406)


		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_LineToCurve" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Difference">
	  <refnamediv>
		<refname>ST_Difference</refname>

		<refpurpose>Returns a geometry that represents that part of geometry A
			that does not intersect with geometry B.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Difference</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a geometry that represents that part of geometry A
			that does not intersect with geometry B.  One can think of this as GeometryA - ST_Intersection(A,B).  If A is completely contained in B
			then an empty geometry collection is returned.</para>
		<note><para>Note - order matters. B - A will always return a portion of B</para></note>

		<para>Performed by the GEOS module</para>

		<note><para>Do not call with a GeometryCollection as an argument</para></note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink> OGC SPEC s2.1.1.3</para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.20</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.
			However it seems to only consider x y when doing the difference and tacks back on the Z-Index</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
			<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para>
							<informalfigure>
								<mediaobject>
								  <imageobject>
									<imagedata fileref="images/st_symdifference01.png" />
								  </imageobject>
								  <caption><para>The original linestrings shown together. </para></caption>
								</mediaobject>
							</informalfigure>
						</para>
					</entry>

					<entry>
						<para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_difference01.png" />
							  </imageobject>
							  <caption><para>The difference of the two linestrings</para></caption>
							</mediaobject>
						  </informalfigure>
					</para>
				</entry>
				  </row>
		</tbody>
	</tgroup>
</informaltable>
<programlisting>
--Safe for 2d. This is same geometries as what is shown for st_symdifference
SELECT ST_AsText(
	ST_Difference(
			ST_GeomFromText('LINESTRING(50 100, 50 200)'),
			ST_GeomFromText('LINESTRING(50 50, 50 150)')
		)
	);

st_astext
---------
LINESTRING(50 150,50 200)
</programlisting>

<programlisting>

--When used in 3d doesn't quite do the right thing
SELECT ST_AsEWKT(ST_Difference(ST_GeomFromEWKT('MULTIPOINT(-118.58 38.38 5,-118.60 38.329 6,-118.614 38.281 7)'), ST_GeomFromEWKT('POINT(-118.614 38.281 5)')));
st_asewkt
---------
MULTIPOINT(-118.6 38.329 6,-118.58 38.38 5)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_SymDifference" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Dump">
	  <refnamediv>
		<refname>ST_Dump</refname>
		<refpurpose>Returns a set of geometry_dump (geom,path) rows, that make up a geometry g1.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry_dump[]<function>ST_Dump</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>This is a set-returning function (SRF). It returns a set of
			geometry_dump rows, formed by a geometry (geom) and an array of
			integers (path). When the input geometry is a simple type
			(POINT,LINESTRING,POLYGON) a single record will be returned with
			an empty path array and the input geometry as geom. When the input
			geometry is a collection or multi it will return a record for each
			of the collection components, and the path will express the
			position of the component inside the collection.</para>

			<para>ST_Dump is useful for expanding geometries. It is the
			reverse of a GROUP BY in that it creates new rows. For example it
			can be use to expand MULTIPOLYGONS into POLYGONS.</para>

			<para>Availability: PostGIS 1.0.0RC1. Requires PostgreSQL 7.3 or higher.</para>
			<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

			<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
	<programlisting>SELECT sometable.field1, sometable.field1,
	  (ST_Dump(sometable.the_geom)).geom As the_geom
FROM sometable;

--Break a compound curve into its constituent linestrings and circularstrings
SELECT ST_AsEWKT(a.geom), ST_HasArc(a.geom)
  FROM ( SELECT (ST_Dump(p_geom)).geom as geom
		   FROM (SELECT ST_GeomFromEWKT('COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))') as p_geom) as b
	   ) as a;
		  st_asewkt          | st_hasarc
-----------------------------+----------
 CIRCULARSTRING(0 0,1 1,1 0) | t
 LINESTRING(1 0,0 1)         | f
(2 rows)


</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_GeometryN" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_DumpRings">
	  <refnamediv>
		<refname>ST_DumpRings</refname>

		<refpurpose>Returns a set of <varname>geometry_dump</varname> rows, representing
			the exterior and interior rings of a polygon.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry_dump[] <function>ST_DumpRings</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_polygon</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>This is a set-returning function (SRF). It returns a set of
			<varname>geometry_dump</varname> rows, defined as an <varname>integer[]</varname>
			and a <varname>geometry</varname>, aliased "path" and "geom" respectively.
			The "path" field holds the polygon ring index containing a single integer: 0 for the shell, >0 for holes.
			The "geom" field contains the corresponding ring as a polygon.</para>

		<para>Availability: PostGIS 1.1.3. Requires PostgreSQL 7.3 or higher.</para>
		<note><para>This only works for POLYGON geometries. It will not work for MULTIPOLYGONS</para></note>
		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT sometable.field1, sometable.field1,
	  (ST_DumpRings(sometable.the_geom)).geom As the_geom
FROM sometableOfpolys;

SELECT ST_AsEWKT(geom) As the_geom, path
	FROM ST_DumpRings(
		ST_GeomFromEWKT('POLYGON((-8149064 5133092 1,-8149064 5132986 1,-8148996 5132839 1,-8148972 5132767 1,-8148958 5132508 1,-8148941 5132466 1,-8148924 5132394 1,
		-8148903 5132210 1,-8148930 5131967 1,-8148992 5131978 1,-8149237 5132093 1,-8149404 5132211 1,-8149647 5132310 1,-8149757 5132394 1,
		-8150305 5132788 1,-8149064 5133092 1),
		(-8149362 5132394 1,-8149446 5132501 1,-8149548 5132597 1,-8149695 5132675 1,-8149362 5132394 1))')
		)  as foo;
 path |                                            the_geom
----------------------------------------------------------------------------------------------------------------
  {0} | POLYGON((-8149064 5133092 1,-8149064 5132986 1,-8148996 5132839 1,-8148972 5132767 1,-8148958 5132508 1,
	  |          -8148941 5132466 1,-8148924 5132394 1,
	  |          -8148903 5132210 1,-8148930 5131967 1,
	  |          -8148992 5131978 1,-8149237 5132093 1,
	  |          -8149404 5132211 1,-8149647 5132310 1,-8149757 5132394 1,-8150305 5132788 1,-8149064 5133092 1))
  {1} | POLYGON((-8149362 5132394 1,-8149446 5132501 1,
	  |          -8149548 5132597 1,-8149695 5132675 1,-8149362 5132394 1))</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Dump" />, <xref linkend="ST_ExteriorRing" />, <xref linkend="ST_InteriorRingN" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Intersection">
		<refnamediv>
			<refname>ST_Intersection</refname>

			<refpurpose>Returns a geometry that represents the shared portion of geomA and geomB
			</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>geometry <function>ST_Intersection</function></funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geomA</parameter>
					</paramdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geomB</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>
			<para>Returns a geometry that represents the point set
				intersection of the Geometries.</para>

			<para>In other words - that portion of geometry A and geometry B
			that is shared between the two geometries.</para>

			<para>If the geometries do not share any space (are disjoint), then an empty geometry collection
			is returned.</para>
			<para>ST_Intersection in conjunction with ST_Intersects is very useful for clipping geometries such as in bounding box, buffer, region
				queries where you only want to return that portion of a geometry that sits in a country or region of interest.</para>

		  <important>
			<para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		  </important>

		  <para>Performed by the GEOS module</para>


			<para>
			  <inlinegraphic fileref="images/check.png" />
			  This method implements the
			  <ulink url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple
			  Features Implementation Specification for SQL</ulink>  OGC SPEC s2.1.1.3
			</para>

			<!-- Optionally mention SQL/MM compliancy if appropriate -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.18</para>
		</refsection>
		<refsection>
		<title>Examples</title>
<programlisting>SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry));
 st_astext
---------------
GEOMETRYCOLLECTION EMPTY
(1 row)
SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry));
 st_astext
---------------
POINT(0 0)
(1 row)

---Clip all lines (trails) by country (here we assume country geom are POLYGON or MULTIPOLYGONS)
-- NOTE: we are only keeping intersections that result in a LINESTRING or MULTILINESTRING because we don't
-- care about trails that just share a point
-- the dump is needed to expand a geometry collection into individual single MULT* parts
-- the below is fairly generic and will work for polys, etc. by just changing the where clause
SELECT clipped.gid, clipped.f_name, clipped_geom
FROM (SELECT trails.gid, trails.f_name, (ST_Dump(ST_Intersection(country.the_geom, trails.the_geom))).geom As clipped_geom
FROM country
	INNER JOIN trails
	ON ST_Intersects(country.the_geom, trails.the_geom))  As clipped
	WHERE ST_Dimension(clipped.clipped_geom) = 1 ;

--For polys e.g. polygon landmarks, you can also use the sometimes faster hack that buffering anything by 0.0
-- except a polygon results in an empty geometry collection
--(so a geometry collection containing polys, lines and points)
-- buffered by 0.0 would only leave the polygons and dissolve the collection shell
SELECT poly.gid,  ST_Multi(ST_Buffer(
				ST_Intersection(country.the_geom, poly.the_geom),
				0.0)
				) As clipped_geom
FROM country
	INNER JOIN poly
	ON ST_Intersects(country.the_geom, poly.the_geom)
	WHERE Not ST_IsEmpty(ST_Buffer(ST_Intersection(country.the_geom, poly.the_geom),0.0));
		</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Dimension"/>, <xref linkend="ST_Dump"/>, <xref linkend="ST_Intersects"/>, <xref linkend="ST_Multi"/></para>
		</refsection>
	</refentry>

	<refentry id="ST_LineToCurve">
	  <refnamediv>
		<refname>ST_LineToCurve</refname>

		<refpurpose>Converts a LINESTRING/POLYGON to a CIRCULARSTRING, CURVED POLYGON</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LineToCurve</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomANoncircular</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converts plain LINESTRING/POLYGONS to CIRCULAR STRINGs and Curved Polygons.  Note much fewer points are needed to describe the curved equivalent.</para>

		<para>Availability: 1.2.2?</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and Curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
SELECT ST_AsText(ST_LineToCurve(foo.the_geom)) As curvedastext,ST_AsText(foo.the_geom) As non_curvedastext
	FROM (SELECT ST_Buffer('POINT(1 3)'::geometry, 3) As the_geom) As foo;

curvedatext															non_curvedastext
------------------------------------------------------------------|	-----------------------------------------------------------------
CURVEPOLYGON(CIRCULARSTRING(4 3,3.12132034355964 0.878679656440359,	 |	POLYGON((4 3,3.94235584120969 2.41472903395162,3.77163859753386 1.85194970290473
1 0,-1.12132034355965 5.12132034355963,4 3))						 | ,3.49440883690764 1.33328930094119,3.12132034355964 0.878679656440359,
																	|				2.66671069905881 0.505591163092366,2.14805029709527 0.228361402466141,
																	|				1.58527096604839 0.0576441587903094,1 0,
																	|				0.414729033951621 0.0576441587903077,-0.148050297095264 0.228361402466137,
																	|				-0.666710699058802 0.505591163092361,-1.12132034355964 0.878679656440353,
																	|				-1.49440883690763 1.33328930094119,-1.77163859753386 1.85194970290472
																	|				--ETC-- ,3.94235584120969 3.58527096604839,4 3))
--3D example
SELECT ST_AsEWKT(ST_LineToCurve(ST_GeomFromEWKT('LINESTRING(1 2 3, 3 4 8, 5 6 4, 7 8 4, 9 10 4)')));

			 st_asewkt
------------------------------------
 CIRCULARSTRING(1 2 3,5 6 4,9 10 4)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_CurveToLine" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MemUnion">
	  <refnamediv>
		<refname>ST_MemUnion</refname>

		<refpurpose>Same as ST_Union, only memory-friendly (uses less memory
			and more processor time).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MemUnion</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Some useful description here.</para>

		<!-- optionally mention that this function uses indexes if appropriate -->
		<note>
		  <para>Same as ST_Union, only memory-friendly (uses less memory
			and more processor time).  This aggregate function works by unioning the geometries one at a time to previous result as opposed to
			ST_Union aggregate which first creates an array and then unions</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index, but sometimes does strange things with 3d.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>See ST_Union</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Union" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MinimumBoundingCircle">
	  <refnamediv>
		<refname>ST_MinimumBoundingCircle</refname>
		<refpurpose>Returns the smallest circle polygon that can fully contain a geometry. Default
		uses 48 segments per quarter circle.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>num_segs_per_qt_circ</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>Returns the smallest circle polygon that can fully contain a geometry. </para>
			<note><para>The circle is approximated by a polygon with a default of 48 segments per quarter circle.  This number can be increased with little performance penalty to obtain a more accurate result.</para></note>

			<para>It is often used with MULTI and Geometry Collections.
		Although it is not an aggregate - you can use it in conjunction
		with ST_Collect to get the minimum bounding cirlce of a set of geometries.
		ST_MinimumBoundingCircle(ST_Collect(somepointfield)).</para>

		<para>The ratio of the area of a polygon divided by the area of its Minimum Bounding Circle is often referred to as the Roeck test.</para>

		<para>Availability: 1.4.0 - requires GEOS</para>


	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>SELECT d.disease_type,
	ST_MinimumBoundingCircle(ST_Collect(d.the_geom)) As the_geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>
	<informalfigure>
	  <mediaobject>
		<imageobject>
		  <imagedata fileref="images/st_minimumboundingcircle01.png" />
		</imageobject>
		<caption><para>Minimum bounding circle of a point and linestring.  Using 8 segs to approximate a quarter circle</para></caption>
	  </mediaobject>
	</informalfigure>
<programlisting>
SELECT ST_AsText(ST_MinimumBoundingCircle(
		ST_Collect(
			ST_GeomFromEWKT('LINESTRING(55 75,125 150)'),
				ST_Point(20, 80)), 8
				)) As wktmbc;
wktmbc
-----------
POLYGON((135.59714732062 115,134.384753327498 102.690357210921,130.79416296937 90.8537670908995,124.963360620072 79.9451031602111,117.116420743937 70.3835792560632,107.554896839789 62.5366393799277,96.6462329091006 56.70583703063,84.8096427890789 53.115246672502,72.5000000000001 51.9028526793802,60.1903572109213 53.1152466725019,48.3537670908996 56.7058370306299,37.4451031602112 62.5366393799276,27.8835792560632 70.383579256063,20.0366393799278 79.9451031602109,14.20583703063 90.8537670908993,10.615246672502 102.690357210921,9.40285267938019 115,10.6152466725019 127.309642789079,14.2058370306299 139.1462329091,20.0366393799275 150.054896839789,27.883579256063 159.616420743937,
37.4451031602108 167.463360620072,48.3537670908992 173.29416296937,60.190357210921 176.884753327498,
72.4999999999998 178.09714732062,84.8096427890786 176.884753327498,96.6462329091003 173.29416296937,107.554896839789 167.463360620072,
117.116420743937 159.616420743937,124.963360620072 150.054896839789,130.79416296937 139.146232909101,134.384753327498 127.309642789079,135.59714732062 115))
				</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_ConvexHull" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Polygonize">
		<refnamediv>
			<refname>ST_Polygonize</refname>

			<refpurpose>Aggregate. Creates a GeometryCollection containing possible
			polygons formed from the constituent linework of a set of
			geometries.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Polygonize</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a GeometryCollection containing possible
			polygons formed from the constituent linework of a set of
			geometries.</para>

			<note>
				<para>Geometry Collections are often difficult to deal with with third party tools, so use ST_Polygonize in conjunction with  <xref linkend="ST_Dump" /> to dump the polygons
				out into individual polygons.</para>
			</note>
			<para>Availability: 1.0.0RC1 - requires GEOS &gt;= 2.1.0.</para>
		</refsection>

		<refsection>
		<title>Examples: Polygonizing single linestrings</title>
		 <programlisting>
SELECT ST_AsEWKT(ST_Polygonize(the_geom_4269)) As geomtextrep
FROM (SELECT the_geom_4269 FROM ma.suffolk_edges ORDER BY tlid LIMIT 45) As foo;

geomtextrep
-------------------------------------
 SRID=4269;GEOMETRYCOLLECTION(POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,-71.040878 42.285678)),
 POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358,-71.171794 42.354971,-71.170511 42.354855,
 -71.17112 42.354238,-71.17166 42.353675)))
(1 row)

--Use ST_Dump to dump out the polygonize geoms into individual polygons
SELECT ST_AsEWKT((ST_Dump(foofoo.polycoll)).geom) As geomtextrep
FROM (SELECT ST_Polygonize(the_geom_4269) As polycoll
	FROM (SELECT the_geom_4269 FROM ma.suffolk_edges
		ORDER BY tlid LIMIT 45) As foo) As foofoo;

geomtextrep
------------------------
 SRID=4269;POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,
-71.040878 42.285678))
 SRID=4269;POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358
,-71.171794 42.354971,-71.170511 42.354855,-71.17112 42.354238,-71.17166 42.353675))
(2 rows)

			  </programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Dump" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_Shift_Longitude">
	  <refnamediv>
		<refname>ST_Shift_Longitude</refname>

		<refpurpose>Reads every point/vertex in every component of every feature
			in a geometry, and if the longitude coordinate is &lt;0, adds 360
			to it. The result would be a 0-360 version of the data to be
			plotted in a 180 centric map</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Shift_Longitude</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Reads every point/vertex in every component of every feature
			in a geometry, and if the longitude coordinate is &lt;0, adds 360
			to it. The result would be a 0-360 version of the data to be
			plotted in a 180 centric map</para>
		<note><para>This is only useful for data in long lat e.g. 4326 (WGS 84 long lat)</para></note>

		<para><inlinegraphic fileref="images/warning.png" />
			Pre-1.3.4 bug prevented this from working for MULTIPOINT. 1.3.4+ works with MULTIPOINT as well.
		</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>--3d points
SELECT ST_AsEWKT(ST_Shift_Longitude(ST_GeomFromEWKT('SRID=4326;POINT(-118.58 38.38 10)'))) As geomA,
	ST_AsEWKT(ST_Shift_Longitude(ST_GeomFromEWKT('SRID=4326;POINT(241.42 38.38 10)'))) As geomb
geomA							  geomB
----------						  -----------
SRID=4326;POINT(241.42 38.38 10) SRID=4326;POINT(-118.58 38.38 10)

--regular line string
SELECT ST_AsText(ST_Shift_Longitude(ST_GeomFromText('LINESTRING(-118.58 38.38, -118.20 38.45)')))

st_astext
----------
LINESTRING(241.42 38.38,241.8 38.45)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_AsEWKT" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Simplify">
	  <refnamediv>
		<refname>ST_Simplify</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using
				the Douglas-Peuker algorithm.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Simplify</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a "simplified" version of the given geometry using
				the Douglas-Peuker algorithm. Will actually do something only with
				(multi)lines and (multi)polygons but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>

		<note><para>Note that returned geometry might loose its
				simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
		<note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>

		<para>Performed by the GEOS module.</para>
		<para>Availability: 1.2.2</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>A circle simplified too much becomes a triangle, medium an octagon, </para>
				<programlisting>
SELECT ST_Npoints(the_geom) As np_before, ST_NPoints(ST_Simplify(the_geom,0.1)) As np01_notbadcircle, ST_NPoints(ST_Simplify(the_geom,0.5)) As np05_notquitecircle,
ST_NPoints(ST_Simplify(the_geom,1)) As np1_octagon, ST_NPoints(ST_Simplify(the_geom,10)) As np10_triangle,
(ST_Simplify(the_geom,100) is null) As  np100_geometrygoesaway
FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;
-result
 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_triangle | np100_geometrygoesaway
-----------+-------------------+---------------------+-------------+---------------+------------------------
		49 |                33 |                  17 |           9 |             4 | t

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_IsSimple" />, <xref linkend="ST_SimplifyPreserveTopology" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SimplifyPreserveTopology">
	  <refnamediv>
		<refname>ST_SimplifyPreserveTopology</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using
			the Douglas-Peuker algorithm. Will avoid creating derived
			geometries (polygons in particular) that are invalid.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SimplifyPreserveTopology</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a "simplified" version of the given geometry using
			the Douglas-Peuker algorithm. Will avoid creating derived
			geometries (polygons in particular) that are invalid. Will actually do something only with
				(multi)lines and (multi)polygons but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>

		<para>Performed by the GEOS module.</para>
		<note><para>Requires GEOS 3.0.0+</para></note>
		<para>Availability: 1.3.3</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>Same example as Simplify, but we see Preserve Topology prevents oversimplification.  The circle can at most become a square.</para>
				<programlisting>
SELECT ST_Npoints(the_geom) As np_before, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.1)) As np01_notbadcircle, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.5)) As np05_notquitecircle,
ST_NPoints(ST_SimplifyPreserveTopology(the_geom,1)) As np1_octagon, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,10)) As np10_square,
ST_NPoints(ST_SimplifyPreserveTopology(the_geom,100)) As  np100_stillsquare
FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;

--result--
 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_square | np100_stillsquare
-----------+-------------------+---------------------+-------------+---------------+-------------------
		49 |                33 |                  17 |           9 |             5 |                 5
				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Simplify" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SymDifference">
	  <refnamediv>
		<refname>ST_SymDifference</refname>

		<refpurpose>Returns a geometry that represents the portions of A and B
			that do not intersect. It is called a symmetric difference because
			ST_SymDifference(A,B) = ST_SymDifference(B,A).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SymDifference</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a geometry that represents the portions of A and B
			that do not intersect. It is called a symmetric difference because
			ST_SymDifference(A,B) = ST_SymDifference(B,A). One can think of this as ST_Union(geomA,geomB) - ST_Intersection(A,B).
			</para>

		<para>Performed by the GEOS module</para>

		<note><para>Do not call with a GeometryCollection as an argument</para></note>

		<!-- Optionally mention OpenGIS compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL.</ulink> OGC SPEC s2.1.1.3</para>

		<!-- Optionally mention SQL/MM compliancy if appropriate -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification: SQL-MM 3: 5.1.21</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.
			However it seems to only consider x y when doing the difference and tacks back on the Z-Index</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para>
							<informalfigure>
								<mediaobject>
								  <imageobject>
									<imagedata fileref="images/st_symdifference01.png" />
								  </imageobject>
								  <caption><para>The original linestrings shown together</para></caption>
								</mediaobject>
							</informalfigure>
						</para>
					</entry>

					<entry>
						<para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_symdifference02.png" />
							  </imageobject>
							  <caption><para>The symmetric difference of the two linestrings</para></caption>
							</mediaobject>
						  </informalfigure>
					</para>
				</entry>
				  </row>
		</tbody>
	</tgroup>
</informaltable>
<programlisting>
--Safe for 2d - symmetric difference of 2 linestrings
SELECT ST_AsText(
	ST_SymDifference(
		ST_GeomFromText('LINESTRING(50 100, 50 200)'),
		ST_GeomFromText('LINESTRING(50 50, 50 150)')
	)
);

st_astext
---------
MULTILINESTRING((50 150,50 200),(50 50,50 100))
</programlisting>

<programlisting>

--When used in 3d doesn't quite do the right thing
SELECT ST_AsEWKT(ST_SymDifference(ST_GeomFromEWKT('LINESTRING(1 2 1, 1 4 2)'),
	ST_GeomFromEWKT('LINESTRING(1 1 3, 1 3 4)')))

st_astext
------------
MULTILINESTRING((1 3 2.75,1 4 2),(1 1 3,1 2 2.25))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Difference" />, <xref linkend="ST_Intersection" />, <xref linkend="ST_Union" /></para>
	  </refsection>
	</refentry>


<refentry id="ST_Union">
  <refnamediv>
	<refname>ST_Union</refname>
	<refpurpose>Returns a geometry that represents the point set union of
		the Geometries.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
	<funcsynopsis>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry set</type> <parameter>g1field</parameter></paramdef>
	  </funcprototype>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry</type> <parameter>g1</parameter></paramdef>
		<paramdef><type>geometry</type> <parameter>g2</parameter></paramdef>
	  </funcprototype>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></paramdef>
	  </funcprototype>
	</funcsynopsis>
  </refsynopsisdiv>

  <refsection>
	<title>Description</title>
	<para> Output type can be a MULTI* , single geometry, or Geometry Collection. Comes in 2 variants.  Variant 1 unions 2 geometries resulting in a new geomety with no intersecting regions.
		Variant 2 is an aggregate function that takes a set of geometries and unions
		them into a single ST_Geometry resulting in no intersecting regions.</para>

	<para>Aggregate version: This function returns a MULTI geometry or NON-MULTI geometry
		from a set of geometries. The ST_Union() function is an "aggregate"
		function in the terminology of PostgreSQL. That means that it
		operates on rows of data, in the same way the SUM() and AVG()
		functions do.</para>

	<para>Non-Aggregate version: This function returns a geometry being a union of two
		input geometries. Output type can be a MULTI* ,NON-MULTI or
		GEOMETRYCOLLECTION.</para>

	<note><para>ST_Collect and ST_Union are often interchangeable.
		ST_Union is in general orders of magnitude slower than ST_Collect
		because it tries to dissolve boundaries and reorder geometries to ensure that a constructed Multi* doesn't
		have intersecting regions.</para></note>

	<para>Performed by the GEOS module.</para>
	<para>NOTE: this function was formerly called GeomUnion(), which
		was renamed from "Union" because UNION is an SQL reserved
		word.</para>
	<para>Availability: 1.4.0 - ST_Union was enhanced. ST_Union(geomarray) was introduced and also faster aggregate collection in PostgreSQL.  If you are using GEOS 3.1.0+
		ST_Union will use the faster Cascaded Union algorithm described in
		<ulink
		url="http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html">http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html</ulink></para>

	<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the <ulink
		url="http://www.opengeospatial.org/standards/sfs">OpenGIS Simple Features
		Implementation Specification for SQL: OGC SPEC s2.1.1.3</ulink></para>

		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This method implements the SQL/MM specification:
		SQL-MM 3: 5.1.19</para>

		<note><para>Aggregate version is not explicitly defined in OGC SPEC.</para></note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
		<imageobject>
		  <imagedata fileref="images/check.png" />
		</imageobject>
		</inlinemediaobject> This function supports 3d and will not drop the z-index, but sometimes does something goofy with
			the z-index (elevation) when polygons are involved.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Aggregate example</para>
			<programlisting>
SELECT stusps,
	   ST_Multi(ST_Union(f.the_geom)) as singlegeom
	 FROM sometable As f
GROUP BY stusps
			  </programlisting>
		<para>Non-Aggregate example</para>
			<programlisting>
SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),
	ST_GeomFromText('POINT(-2 3)') ) )

st_astext
----------
MULTIPOINT(-2 3,1 2)


SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),
		ST_GeomFromText('POINT(1 2)') ) );
st_astext
----------
POINT(1 2)

--3d example - sort of supports 3d (and with mixed dimensions!)
SELECT ST_AsEWKT(st_union(the_geom))
FROM
(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2,-7.1 4.2,-7.1 4.3,
-7 4.2))') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom
UNION ALL
	SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 5,-7.1 4.2 5,-7.1 4.3 5,-7 4.2 5)));

--3d example not mixing dimensions
SELECT ST_AsEWKT(st_union(the_geom))
FROM
(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,
-7 4.2 2))') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom
UNION ALL
	SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,-7 4.2 2)))

--Examples using new Array construct
SELECT ST_Union(ARRAY(SELECT the_geom FROM sometable));

SELECT ST_AsText(ST_Union(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),
			ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As wktunion;

--wktunion---
MULTILINESTRING((3 4,4 5),(1 2,3 4))

			  </programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" /></para>
	  </refsection>
	</refentry>
</sect1>

  <sect1 id="Linear_Referencing">
	  <title>Linear Referencing</title>
		<refentry id="ST_Line_Interpolate_Point">
		  <refnamediv>
			<refname>ST_Line_Interpolate_Point</refname>

			<refpurpose>Returns a point interpolated along a line. Second argument is a float8 between 0 and 1
			representing fraction of total length of linestring the point has to be located.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Line_Interpolate_Point</function></funcdef>
				<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
				<paramdef><type>float </type> <parameter>a_fraction</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns a point interpolated along a line. First argument
			must be a LINESTRING. Second argument is a float8 between 0 and 1
			representing fraction of total linestring length the point has to be located.</para>

			<para>See <xref linkend="ST_Line_Locate_Point" /> for
			computing the line location nearest to a Point.</para>

			<note>
			  <para>Since release 1.1.1 this function also interpolates M and
			  Z values (when present), while prior releases set them to
			  0.0.</para>
			</note>
			<para>Availability: 0.8.2, Z and M supported added in 1.1.1</para>

			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
		  </refsection>


		  <refsection>
			<title>Examples</title>
			<informalfigure>
			  <mediaobject>
				<imageobject>
				  <imagedata fileref="images/st_line_interpolate_point01.png" />
				</imageobject>
				<caption><para>A linestring with the interpolated point at 20% position (0.20) </para></caption>
			  </mediaobject>
			</informalfigure>
			<programlisting>--Return point 20% along 2d line
SELECT ST_AsEWKT(ST_Line_Interpolate_Point(the_line, 0.20))
	FROM (SELECT ST_GeomFromEWKT('LINESTRING(25 50, 100 125, 150 190)') as the_line) As foo;
   st_asewkt
----------------
 POINT(51.5974135047432 76.5974135047432)

</programlisting>
<programlisting>
--Return point mid-way of 3d line
SELECT ST_AsEWKT(ST_Line_Interpolate_Point(the_line, 0.5))
	FROM (SELECT ST_GeomFromEWKT('LINESTRING(1 2 3, 4 5 6, 6 7 8)') as the_line) As foo;

	st_asewkt
--------------------
 POINT(3.5 4.5 5.5)


--find closest point on a line to a point or other geometry
 SELECT ST_AsText(ST_Line_Interpolate_Point(foo.the_line, ST_Line_Locate_Point(foo.the_line, ST_GeomFromText('POINT(4 3)'))))
FROM (SELECT ST_GeomFromText('LINESTRING(1 2, 4 5, 6 7)') As the_line) As foo;
   st_astext
----------------
 POINT(3 4)

</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_AsText" />,<xref linkend="ST_AsEWKT" />,<xref linkend="ST_Length" />, <xref linkend="ST_Line_Locate_Point" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Line_Locate_Point">
		  <refnamediv>
			<refname>ST_Line_Locate_Point</refname>

			<refpurpose>Returns a float between 0 and 1 representing the location of
			the closest point on LineString to the given Point, as a fraction
			of total 2d line length.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>float <function>ST_Line_Locate_Point</function></funcdef>
				<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			 <para>Returns a float between 0 and 1 representing the location of
			the closest point on LineString to the given Point, as a fraction
			of total <link linkend="ST_Length2D">2d line</link> length.</para>

			<para>You can use the returned location to extract a Point (<xref linkend="ST_Line_Interpolate_Point" />) or
			a substring (<xref linkend="ST_Line_Substring" />).</para>

			<para>This is useful for approximating numbers of addresses</para>

			<para>Availability: 1.1.0</para>

		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>
--Rough approximation of finding the street number of a point along the street
--Note the whole foo thing is just to generate dummy data that looks
--like house centroids and street
--We use ST_DWithin to exclude
--houses too far away from the street to be considered on the street
SELECT ST_AsText(house_loc) As as_text_house_loc,
	startstreet_num +
		CAST( (endstreet_num - startstreet_num)
			* ST_Line_Locate_Point(street_line, house_loc) As integer) As street_num
FROM
(SELECT ST_GeomFromText('LINESTRING(1 2, 3 4)') As street_line,
	ST_MakePoint(x*1.01,y*1.03) As house_loc, 10 As startstreet_num,
		20 As endstreet_num
FROM generate_series(1,3) x CROSS JOIN generate_series(2,4) As y)
As foo
WHERE ST_DWithin(street_line, house_loc, 0.2);

 as_text_house_loc | street_num
-------------------+------------
 POINT(1.01 2.06)  |         10
 POINT(2.02 3.09)  |         15
 POINT(3.03 4.12)  |         20

 --find closest point on a line to a point or other geometry
 SELECT ST_AsText(ST_Line_Interpolate_Point(foo.the_line, ST_Line_Locate_Point(foo.the_line, ST_GeomFromText('POINT(4 3)'))))
FROM (SELECT ST_GeomFromText('LINESTRING(1 2, 4 5, 6 7)') As the_line) As foo;
   st_astext
----------------
 POINT(3 4)

</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_DWithin" />, <xref linkend="ST_Length2D" />, <xref linkend="ST_Line_Interpolate_Point" />, <xref linkend="ST_Line_Substring" /></para>
		  </refsection>
		</refentry>

		<refentry id="ST_Line_Substring">
		  <refnamediv>
			<refname>ST_Line_Substring</refname>

			<refpurpose>Return a linestring being a substring of the input one
			starting and ending at the given fractions of total 2d length.
			Second and third arguments are float8 values between 0 and
			1.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Line_Substring</function></funcdef>
				<paramdef><type>geometry </type> <parameter>a_linestring</parameter></paramdef>
				<paramdef><type>float </type> <parameter>startfraction</parameter></paramdef>
				<paramdef><type>float </type> <parameter>endfraction</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Return a linestring being a substring of the input one
			starting and ending at the given fractions of total 2d length.
			Second and third arguments are float8 values between 0 and
			1. This only works with LINESTRINGs.
			To use with contiguous MULTILINESTRINGs use in conjunction with ST_LineMerge.</para>

			<para>If 'start' and 'end' have the same value this is equivalent
			to <xref linkend="ST_Line_Interpolate_Point" />.</para>

			<para>See <xref linkend="ST_Line_Locate_Point" /> for
			computing the line location nearest to a Point.</para>

			<note>
			  <para>Since release 1.1.1 this function also interpolates M and
			  Z values (when present), while prior releases set them to
			  unspecified values.</para>
			</note>

			<para>Availability: 1.1.0 , Z and M supported added in 1.1.1</para>

			<!-- Optionally mention 3d support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<informalfigure>
			  <mediaobject>
				<imageobject>
				  <imagedata fileref="images/st_line_substring01.png" />
				</imageobject>
				<caption><para>A linestring seen with 1/3 midrange overlaid (0.333, 0.666) </para></caption>
			  </mediaobject>
			</informalfigure>
	<programlisting>
--Return the approximate 1/3 mid-range part of a linestring
SELECT ST_AsText(ST_Line_SubString(ST_GeomFromText('LINESTRING(25 50, 100 125, 150 190)'), 0.333, 0.666));

										   st_astext
------------------------------------------------------------------------------------------------
LINESTRING(69.2846934853974 94.2846934853974,100 125,111.700356260683 140.210463138888)

--The below example simulates a while loop in
--SQL using PostgreSQL generate_series() to cut all
--linestrings in a table to 100 unit segments
-- of which no segment is longer than 100 units
-- units are measured in the SRID units of measurement
-- It also assumes all geometries are LINESTRING or contiguous MULTILINESTRING
--and no geometry is longer than 100 units*10000
--for better performance you can reduce the 10000
--to match max number of segments you expect

SELECT field1, field2, ST_Line_Substring(the_geom, 100.00*n/length,
  CASE
	WHEN 100.00*(n+1) &lt; length THEN 100.00*(n+1)/length
	ELSE 1
  END) As the_geom
FROM
  (SELECT sometable.field1, sometable.field2,
  ST_LineMerge(sometable.the_geom) AS the_geom,
  ST_Length(sometable.the_geom) As length
  FROM sometable
  ) AS t
CROSS JOIN generate_series(0,10000) AS n
WHERE n*100.00/length &lt; 1;
			</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_Length" />, <xref linkend="ST_Line_Interpolate_Point" />, <xref linkend="ST_LineMerge" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_Locate_Along_Measure">
	  <refnamediv>
		<refname>ST_Locate_Along_Measure</refname>

		<refpurpose>Return a derived geometry collection value with elements
			that match the specified measure. Polygonal elements are not
			supported.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Locate_Along_Measure</function></funcdef>
			<paramdef><type>geometry </type> <parameter>ageom_with_measure</parameter></paramdef>
			<paramdef><type>float </type> <parameter>a_measure</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return a derived geometry collection value with elements
		that match the specified measure. Polygonal elements are not
		supported.</para>

		<para>Semantic is specified by: ISO/IEC CD 13249-3:200x(E) - Text
		for Continuation CD Editing Meeting</para>

		<para>Availability: 1.1.0</para>
		<note><para>Use this function only for geometries with an M component</para></note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports M coordinate.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_AsEWKT(the_geom)
		FROM
		(SELECT ST_Locate_Along_Measure(
			ST_GeomFromEWKT('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),
		(1 2 3, 5 4 5))'),3) As the_geom) As foo;

						 st_asewkt
-----------------------------------------------------------
 GEOMETRYCOLLECTIONM(MULTIPOINT(1 2 3,9 4 3),POINT(1 2 3))

--Geometry collections are difficult animals so dump them
--to make them more digestable
SELECT ST_AsEWKT((ST_Dump(the_geom)).geom)
	FROM
	(SELECT ST_Locate_Along_Measure(
			ST_GeomFromEWKT('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),
	(1 2 3, 5 4 5))'),3) As the_geom) As foo;

   st_asewkt
---------------
 POINTM(1 2 3)
 POINTM(9 4 3)
 POINTM(1 2 3)
	</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Dump" />, <xref linkend="ST_Locate_Between_Measures" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Locate_Between_Measures">
	  <refnamediv>
		<refname>ST_Locate_Between_Measures</refname>

		<refpurpose>Return a derived geometry collection value with elements
			that match the specified range of measures inclusively. Polygonal
			elements are not supported.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Locate_Between_Measures</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>measure_start</parameter></paramdef>
			<paramdef><type>float </type> <parameter>measure_end</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		   <para>Return a derived geometry collection value with elements
			that match the specified range of measures inclusively. Polygonal
			elements are not supported.</para>

			<para>Semantic is specified by: ISO/IEC CD 13249-3:200x(E) - Text
			for Continuation CD Editing Meeting</para>

			<para>Availability: 1.1.0</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports M coordinate.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsEWKT(the_geom)
		FROM
		(SELECT ST_Locate_Between_Measures(
			ST_GeomFromEWKT('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),
		(1 2 3, 5 4 5))'),1.5, 3) As the_geom) As foo;

							 st_asewkt
-----------------------------------------------------------------
 GEOMETRYCOLLECTIONM(LINESTRING(1 2 3,3 4 2,9 4 3),POINT(1 2 3))

--Geometry collections are difficult animals so dump them
--to make them more digestable
SELECT ST_AsEWKT((ST_Dump(the_geom)).geom)
		FROM
		(SELECT ST_Locate_Between_Measures(
			ST_GeomFromEWKT('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),
		(1 2 3, 5 4 5))'),1.5, 3) As the_geom) As foo;

		   st_asewkt
--------------------------------
 LINESTRINGM(1 2 3,3 4 2,9 4 3)
 POINTM(1 2 3)</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Dump" />, <xref linkend="ST_Locate_Along_Measure" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_LocateBetweenElevations">
	  <refnamediv>
		<refname>ST_LocateBetweenElevations</refname>

		<refpurpose>Return a derived geometry (collection) value with elements
			that intersect the specified range of elevations inclusively. Only 3D, 4D LINESTRINGS and MULTILINESTRINGS
			are supported.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LocateBetweenElevations</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom_mline</parameter></paramdef>
			<paramdef><type>float </type> <parameter>elevation_start</parameter></paramdef>
			<paramdef><type>float </type> <parameter>elevation_end</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		   <para>Return a derived geometry (collection) value with elements
			that intersect the specified range of elevations inclusively. Only 3D, 3DM LINESTRINGS and MULTILINESTRINGS
			are supported.</para>

			<para>Availability: 1.4.0</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsEWKT(ST_LocateBetweenElevations(
			ST_GeomFromEWKT('LINESTRING(1 2 3, 4 5 6)'),2,4)) As ewelev;
								   ewelev
----------------------------------------------------------------
	MULTILINESTRING((1 2 3,2 3 4))

SELECT ST_AsEWKT(ST_LocateBetweenElevations(
			ST_GeomFromEWKT('LINESTRING(1 2 6, 4 5 -1, 7 8 9)'),6,9)) As ewelev;

				ewelev
----------------------------------------------------------------
GEOMETRYCOLLECTION(POINT(1 2 6),LINESTRING(6.1 7.1 6,7 8 9))

--Geometry collections are difficult animals so dump them
--to make them more digestable
SELECT ST_AsEWKT((ST_Dump(the_geom)).geom)
		FROM
		(SELECT ST_LocateBetweenElevations(
			ST_GeomFromEWKT('LINESTRING(1 2 6, 4 5 -1, 7 8 9)'),6,9) As the_geom) As foo;

		   st_asewkt
--------------------------------
POINT(1 2 6)
LINESTRING(6.1 7.1 6,7 8 9)
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Dump" /></para>
	  </refsection>
	</refentry>
  </sect1>

  <sect1 id="Long_Transactions_Support">
	  <title>Long Transactions Support</title>

	   <para>This module and associated pl/pgsql functions have been
	  implemented to provide long locking support required by <ulink
	  url="http://portal.opengeospatial.org/files/index.php?artifact_id=7176">Web Feature Service</ulink> specification.</para>

	  <note>
		<para>Users must use <ulink
		url="http://www.postgresql.org/docs/8.3/static/transaction-iso.html">serializable
		transaction level</ulink> otherwise locking mechanism would
		break.</para>
	  </note>

	<refentry id="AddAuth">
	  <refnamediv>
		<refname>AddAuth</refname>

		<refpurpose>Add an authorization token to be used in current transaction.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>AddAuth</function></funcdef>
			<paramdef><type>text </type> <parameter>auth_token</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Add an authorization token to be used in current transaction.</para>

		<para>Creates/adds to a temp table called temp_lock_have_table the current transaction identifier
			and authorization token key.</para>

		<para>Availability: 1.1.3</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
		SELECT LockRow('towns', '353', 'priscilla');
		BEGIN TRANSACTION;
			SELECT AddAuth('joey');
			UPDATE towns SET the_geom = ST_Translate(the_geom,2,2) WHERE gid = 353;
		COMMIT;


		---Error--
		ERROR:  UPDATE where "gid" = '353' requires authorization 'priscilla'
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="LockRow" /></para>
	  </refsection>
	</refentry>

	  <refentry id="CheckAuth">
		  <refnamediv>
			<refname>CheckAuth</refname>

			<refpurpose>Creates trigger on a table to prevent/allow updates and deletes of rows based on authorization token.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>integer <function>CheckAuth</function></funcdef>
				<paramdef><type>text </type> <parameter>a_schema_name</parameter></paramdef>
				<paramdef><type>text </type> <parameter>a_table_name</parameter></paramdef>
				<paramdef><type>text </type> <parameter>a_key_column_name</parameter></paramdef>
			  </funcprototype>

			  <funcprototype>
				<funcdef>integer <function>CheckAuth</function></funcdef>
				<paramdef><type>text </type> <parameter>a_table_name</parameter></paramdef>
				<paramdef><type>text </type> <parameter>a_key_column_name</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Creates trigger on a table to prevent/allow updates and deletes of rows based on authorization token. Identify rows using &lt;rowid_col&gt; column.</para>

			<para>If a_schema_name is not passed in, then searches for table in current schema.</para>
			<note><para>If an authorization trigger already exists on this table function errors.</para>
				<para>If Transaction support is not enabled, function throws an exception.</para>
			</note>

			<para>Availability: 1.1.3</para>

		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>
			SELECT CheckAuth('public', 'towns', 'gid');
			result
			------
			0
			</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="EnableLongTransactions" /></para>
		  </refsection>
		</refentry>

	  <refentry id="DisableLongTransactions">
		<refnamediv>
		  <refname>DisableLongTransactions</refname>

		  <refpurpose>Disable long transaction support. This function removes the
			long transaction support metadata tables, and drops all triggers
			attached to lock-checked tables.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		  <funcsynopsis>
			<funcprototype>
			  <funcdef>text <function>DisableLongTransactions</function></funcdef>
			</funcprototype>
		  </funcsynopsis>
		</refsynopsisdiv>

		<refsection>
		  <title>Description</title>

			<para>Disable long transaction support. This function removes the
			long transaction support metadata tables, and drops all triggers
			attached to lock-checked tables.</para>
			<para>Drops meta table called <varname>authorization_table</varname> and a view called <varname>authorized_tables</varname>
				and all triggers called <varname>checkauthtrigger</varname></para>

			<para>Availability: 1.1.3</para>

		</refsection>


		<refsection>
		  <title>Examples</title>

		  <programlisting>SELECT DisableLongTransactions();
--result--
Long transactions support disabled
		  </programlisting>
		</refsection>

		<!-- Optionally add a "See Also" section -->
		<refsection>
		  <title>See Also</title>

		  <para><xref linkend="EnableLongTransactions" /></para>
		</refsection>
	  </refentry>

	  <refentry id="EnableLongTransactions">
		<refnamediv>
		  <refname>EnableLongTransactions</refname>

		  <refpurpose>Enable long transaction support. This function creates the
			required metadata tables, needs to be called once before using the
			other functions in this section. Calling it twice is
			harmless.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		  <funcsynopsis>
			<funcprototype>
			  <funcdef>text <function>EnableLongTransactions</function></funcdef>
			</funcprototype>
		  </funcsynopsis>
		</refsynopsisdiv>

		<refsection>
		  <title>Description</title>

			<para>Enable long transaction support. This function creates the
			required metadata tables, needs to be called once before using the
			other functions in this section. Calling it twice is
			harmless.</para>
			<para>Creates a meta table called <varname>authorization_table</varname> and a view called <varname>authorized_tables</varname></para>

			<para>Availability: 1.1.3</para>

		</refsection>


		<refsection>
		  <title>Examples</title>

		  <programlisting>SELECT EnableLongTransactions();
--result--
Long transactions support enabled
		  </programlisting>
		</refsection>

		<!-- Optionally add a "See Also" section -->
		<refsection>
		  <title>See Also</title>

		  <para><xref linkend="DisableLongTransactions" /></para>
		</refsection>
	  </refentry>

	<refentry id="LockRow">
	  <refnamediv>
		<refname>LockRow</refname>

		<refpurpose>Set lock/authorization for specific row in table</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>LockRow</function></funcdef>
			<paramdef><type>text </type> <parameter>a_schema_name</parameter></paramdef>
			<paramdef><type>text </type> <parameter>a_table_name</parameter></paramdef>
			<paramdef><type>text </type> <parameter>a_row_key</parameter></paramdef>
			<paramdef><type>text</type> <parameter>an_auth_token</parameter></paramdef>
			<paramdef><type>timestamp</type> <parameter>expire_dt</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>integer <function>LockRow</function></funcdef>
			<paramdef><type>text </type> <parameter>a_table_name</parameter></paramdef>
			<paramdef><type>text </type> <parameter>a_row_key</parameter></paramdef>
			<paramdef><type>text</type> <parameter>an_auth_token</parameter></paramdef>
			<paramdef><type>timestamp</type> <parameter>expire_dt</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>integer <function>LockRow</function></funcdef>
			<paramdef><type>text </type> <parameter>a_table_name</parameter></paramdef>
			<paramdef><type>text </type> <parameter>a_row_key</parameter></paramdef>
			<paramdef><type>text</type> <parameter>an_auth_token</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Set lock/authorization for specific row in table
		&lt;authid&gt; is a text value, &lt;expires&gt; is a timestamp
		defaulting to now()+1hour. Returns 1 if lock has been assigned, 0
		otherwise (already locked by other auth)</para>

		<para>Availability: 1.1.3</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT LockRow('public', 'towns', '2', 'joey');
LockRow
-------
1

--Joey has already locked the record and Priscilla is out of luck
SELECT LockRow('public', 'towns', '2', 'priscilla');
LockRow
-------
0

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="UnlockRows" /></para>
	  </refsection>
	</refentry>

	<refentry id="UnlockRows">
	  <refnamediv>
		<refname>UnlockRows</refname>

		<refpurpose>Remove all locks held by specified authorization id. Returns
			the number of locks released.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>UnlockRows</function></funcdef>
			<paramdef><type>text </type> <parameter>auth_token</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Remove all locks held by specified authorization id. Returns
			the number of locks released.</para>

		<para>Availability: 1.1.3</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
		SELECT LockRow('towns', '353', 'priscilla');
		SELECT LockRow('towns', '2', 'priscilla');
		SELECT UnLockRows('priscilla');
		UnLockRows
		------------
		2
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="LockRow" /></para>
	  </refsection>
	</refentry>
  </sect1>

  <sect1 id="Miscellaneous_Functions">
	<title>Miscellaneous Functions</title>

	<refentry id="ST_Accum">
	  <refnamediv>
		<refname>ST_Accum</refname>

		<refpurpose>Aggregate. Constructs an array of geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry[] <function>ST_Accum</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Aggregate. Constructs an array of geometries.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT (ST_Accum(the_geom)) As all_em, ST_AsText((ST_Accum(the_geom))[1]) As grabone,
(ST_Accum(the_geom))[2:4] as grab_rest
			FROM (SELECT ST_MakePoint(a*CAST(random()*10 As integer), a*CAST(random()*10 As integer), a*CAST(random()*10 As integer)) As the_geom
				FROM generate_series(1,4) a) As foo;

all_em|grabone   | grab_rest

-------------------------------------------------------------------------------+

 {0101000080000000000000144000000000000024400000000000001040:
 0101000080000000000
00018400000000000002C400000000000003040:
0101000080000000000000354000000000000038400000000000001840:
010100008000000000000040400000000000003C400000000000003040} |
 POINT(5 10) | {010100008000000000000018400000000000002C400000000000003040:
 0101000080000000000000354000000000000038400000000000001840:
 010100008000000000000040400000000000003C400000000000003040}
(1 row)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Collect" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Box2D">
	  <refnamediv>
		<refname>ST_Box2D</refname>

		<refpurpose>Returns a BOX2D representing the maximum extents of the geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>box2d <function>ST_Box2D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a BOX2D representing the maximum extents of the geometry.</para>

	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Box2D(ST_GeomFromText('LINESTRING(1 2, 3 4, 5 6)'));
	st_box2d
	---------
	BOX(1 2,5 6)

	SELECT ST_Box2D(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)'));
	st_box2d
	--------
	BOX(220186.984375 150406,220288.25 150506.140625)
	</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Box3D" />, <xref linkend="ST_GeomFromText" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Box3D">
	  <refnamediv>
		<refname>ST_Box3D</refname>

		<refpurpose>Returns a BOX3D representing the maximum extents of the geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>box3d <function>ST_Box3D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a BOX3D representing the maximum extents of the geometry.</para>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		  <!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Box3D(ST_GeomFromEWKT('LINESTRING(1 2 3, 3 4 5, 5 6 5)'));
	st_box3d
	---------
	BOX3D(1 2 3,5 6 5)

	SELECT ST_Box3D(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 1,220227 150406 1)'));
	st_box3d
	--------
	BOX3D(220227 150406 1,220268 150415 1)
	</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Box2D" />, <xref linkend="ST_GeomFromEWKT" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Estimated_Extent">
	  <refnamediv>
		<refname>ST_Estimated_Extent</refname>

		<refpurpose>Return the 'estimated' extent of the given spatial table.
			The estimated is taken from the geometry column's statistics. The
			current schema will be used if not specified.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>box2d <function>ST_Estimated_Extent</function></funcdef>
			<paramdef><type>text </type> <parameter>schema_name</parameter></paramdef>
			<paramdef><type>text </type> <parameter>table_name</parameter></paramdef>
			<paramdef><type>text </type> <parameter>geocolumn_name</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>box2d <function>ST_Estimated_Extent</function></funcdef>
			<paramdef><type>text </type> <parameter>table_name</parameter></paramdef>
			<paramdef><type>text </type> <parameter>geocolumn_name</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the 'estimated' extent of the given spatial table.
			The estimated is taken from the geometry column's statistics. The
			current schema will be used if not specified.</para>

		<para>For PostgreSQL&gt;=8.0.0 statistics are gathered by VACUUM
		ANALYZE and resulting extent will be about 95% of the real
		one.</para>

		<para>For PostgreSQL&lt;8.0.0 statistics are gathered by
		update_geometry_stats() and resulting extent will be exact.</para>

	<!-- Optionally mention Circular String Support -->
		<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Estimated_extent('ny', 'edges', 'the_geom');
--result--
BOX(-8877653 4912316,-8010225.5 5589284)

SELECT ST_Estimated_Extent('feature_poly', 'the_geom');
--result--
BOX(-124.659652709961 24.6830825805664,-67.7798080444336 49.0012092590332)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Extent" /></para>
	  </refsection>
	</refentry>
	<refentry id="ST_Expand">
	  <refnamediv>
		<refname>ST_Expand</refname>
		<refpurpose>Returns bounding box expanded in all directions from the bounding box of the input geometry</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Expand</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>float</type> <parameter>units_to_expand</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>box2d <function>ST_Expand</function></funcdef>
			<paramdef><type>box2d </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>float</type> <parameter>units_to_expand</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>box3d <function>ST_Expand</function></funcdef>
			<paramdef><type>box3d </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>float</type> <parameter>units_to_expand</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>This function returns a bounding box expanded in all
		directions from the bounding box of the input geometry, by an
		amount specified in the second argument. Very useful for
		distance() queries, or bounding box queries to add an index filter to the query.</para>
		<para>There are 3 variants of this.  The one that takes a geometry will return a POLYGON geometry representation
			of the bounding box and is the most commonly used variant.</para>
		<para>ST_Expand is similar in concept to ST_Buffer except while buffer expands the geometry in all directions,
			ST_Expand expands the bounding box an x,y,z unit amount.</para>
		<para>Units are in the units of the spatial reference system in use denoted by the SRID</para>

		<note>
		  <para>Pre 1.3, ST_Expand was used in conjunction with distance to do indexable queries.  Something of the form
			<code>the_geom &amp;&amp; ST_Expand('POINT(10 20)', 10) AND ST_Distance(the_geom, 'POINT(10 20)') &lt; 10</code>
			Post 1.2, this was replaced with the easier ST_DWithin construct.</para>
		</note>

		<note>
		  <para>Bounding boxes of all geometries are currently 2-d even if they are 3-dimensional geometries.</para>
		</note>

	  </refsection>

	  <refsection>
		<title>Examples</title>
		<note><para>Examples below use US National Atlas Equal Area (SRID=2163) which is a meter projection</para></note>
		<programlisting>
--10 meter expanded box around bbox of a linestring
SELECT CAST(ST_Expand(ST_GeomFromText('LINESTRING(2312980 110676,2312923 110701,2312892 110714)', 2163),10) As box2d);
					 st_expand
------------------------------------
 BOX(2312882 110666,2312990 110724)

--10 meter expanded 3d box of a 3d box
SELECT ST_Expand(CAST('BOX3D(778783 2951741 1,794875 2970042.61545891 10)' As box3d),10)
							  st_expand
-----------------------------------------------------
 BOX3D(778773 2951731 -9,794885 2970052.61545891 20)

 --10 meter geometry astext rep of a expand box around a point geometry
 SELECT ST_AsEWKT(ST_Expand(ST_GeomFromEWKT('SRID=2163;POINT(2312980 110676)'),10));
											st_asewkt
-------------------------------------------------------------------------------------------------
 SRID=2163;POLYGON((2312970 110666,2312970 110686,2312990 110686,2312990 110666,2312970 110666))

		</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_Buffer" />, <xref linkend="ST_DWithin" />, <xref linkend="ST_GeomFromEWKT" />,<xref linkend="ST_GeomFromText" />, <xref linkend="ST_SRID" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Extent">
	  <refnamediv>
		<refname>ST_Extent</refname>
		<refpurpose>an aggregate function that returns the bounding box that bounds rows of geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>box3d_extent <function>ST_Extent</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>ST_Extent returns a bounding box that encloses a set of geometries. The ST_Extent function is an "aggregate" function in the
			terminology of SQL. That means that it operates on lists
			of data, in the same way the SUM() and AVG() functions do.</para>
		<para>Since it returns a bounding box, the spatial Units are in the units of the spatial reference system in use denoted by the SRID</para>
		<para>ST_Extent is similar in concept to Oracle Spatial/Locator's SDO_AGGR_MBR</para>
		<note>
		  <para>Since ST_Extent returns a bounding box, the SRID meta-data is lost.  Use ST_SetSRID to force it back into
			a geometry with SRID meta data.  The coordinates are in the units of the spatial ref of the orginal geometries.</para>
		</note>

		<note>
		  <para>ST_Extent will return boxes with only an x and y component even with (x,y,z) coordinate geometries.  To maintain x,y,z use ST_Extent3D instead.</para>
		</note>
		
		<note>
		  <para>Availability: 1.4.0 As of 1.4.0 now returns a box3d_extent instead of box2d object.</para>
		</note>

	  </refsection>

	  <refsection>
		<title>Examples</title>
		<note><para>Examples below use Massachusetts State Plane ft (SRID=2249)</para></note>
		<programlisting>

SELECT ST_Extent(the_geom) as bextent FROM sometable;
					 st_bextent
------------------------------------
BOX(739651.875 2908247.25,794875.8125 2970042.75)


--Return extent of each category of geometries
SELECT ST_Extent(the_geom) as bextent
FROM sometable
GROUP BY category ORDER BY category;

					  bextent                       |         name
----------------------------------------------------+----------------
 BOX(778783.5625 2951741.25,794875.8125 2970042.75) | A
 BOX(751315.8125 2919164.75,765202.6875 2935417.25) | B
 BOX(739651.875 2917394.75,756688.375 2935866)      | C

 --Force back into a geometry
 -- and render the extended text representation of that geometry
SELECT ST_SetSRID(ST_Extent(the_geom),2249) as bextent FROM sometable;

				bextent
--------------------------------------------------------------------------------
 SRID=2249;POLYGON((739651.875 2908247.25,739651.875 2970042.75,794875.8125 2970042.75,
 794875.8125 2908247.25,739651.875 2908247.25))
		</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_Extent3D" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_SRID" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Extent3D">
	  <refnamediv>
		<refname>ST_Extent3D</refname>
		<refpurpose>an aggregate function that returns the box3D bounding box that bounds rows of geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>box3d <function>ST_Extent3D</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>ST_Extent3D returns a box3d (includes Z coordinate) bounding box that encloses a set of geometries. The ST_Extent3D function is an "aggregate" function in the
			terminology of SQL. That means that it operates on lists
			of data, in the same way the SUM() and AVG() functions do.</para>
		<para>Since it returns a bounding box, the spatial Units are in the units of the spatial reference system in use denoted by the SRID</para>

		<note>
		  <para>Since ST_Extent3D returns a bounding box, the SRID meta-data is lost.  Use ST_SetSRID to force it back into
			a geometry with SRID meta data.  The coordinates are in the units of the spatial ref of the orginal geometries.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>

		<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>
SELECT ST_Extent3D(foo.the_geom) As b3extent
FROM (SELECT ST_MakePoint(x,y,z) As the_geom
	FROM generate_series(1,3) As x
		CROSS JOIN generate_series(1,2) As y
		CROSS JOIN generate_series(0,2) As Z) As foo;
	  b3extent
--------------------
 BOX3D(1 1 0,3 2 2)

--Get the extent of various elevated circular strings
SELECT ST_Extent3D(foo.the_geom) As b3extent
FROM (SELECT ST_Translate(ST_Force_3DZ(ST_LineToCurve(ST_Buffer(ST_MakePoint(x,y),1))),0,0,z) As the_geom
	FROM generate_series(1,3) As x
		CROSS JOIN generate_series(1,2) As y
		CROSS JOIN generate_series(0,2) As Z) As foo;

	b3extent
--------------------
 BOX3D(1 0 0,4 2 2)
		</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Extent" />, <xref linkend="ST_Force_3DZ" /></para>
	  </refsection>
	</refentry>


	<refentry id="Find_SRID">
	  <refnamediv>
		<refname>Find_SRID</refname>

		<refpurpose>The syntax is find_srid(&lt;db/schema&gt;, &lt;table&gt;,
			&lt;column&gt;) and the function returns the integer SRID of the
			specified column by searching through the GEOMETRY_COLUMNS table.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>Find_SRID</function></funcdef>
			<paramdef><type>varchar </type> <parameter>a_schema_name</parameter></paramdef>
			<paramdef><type>varchar </type> <parameter>a_table_name</parameter></paramdef>
			 <paramdef><type>varchar </type> <parameter>a_geomfield_name</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>The syntax is find_srid(&lt;db/schema&gt;, &lt;table&gt;,
			&lt;column&gt;) and the function returns the integer SRID of the
			specified column by searching through the GEOMETRY_COLUMNS table.
			If the geometry column has not been properly added with the
			AddGeometryColumns() function, this function will not work
			either.</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting> SELECT Find_SRID('public', 'tiger_us_state_2007', 'the_geom_4269');
find_srid
----------
4269
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_SRID" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Mem_Size">
	  <refnamediv>
		<refname>ST_Mem_Size</refname>

		<refpurpose>Returns the amount of space (in bytes) the geometry takes.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>integer <function>ST_Mem_Size</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns the amount of space (in bytes) the geometry takes. </para>
		<para>This is a nice compliment to PostgreSQL built in functions pg_size_pretty, pg_relation_size, pg_total_relation_size.</para>
		<note><para>pg_relation_size which gives the byte size of a table may return byte size lower than ST_Mem_Size. This is because
		pg_relation_size does not add toasted table contribution and large geometries are stored in TOAST tables.</para>
		<para>pg_total_relation_size - includes, the table, the toasted tables, and the indexes.</para>
		</note>


		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Return how much byte space Boston takes up  in our Mass data set
SELECT pg_size_pretty(SUM(ST_Mem_Size(the_geom))) as totgeomsum,
pg_size_pretty(SUM(CASE WHEN town = 'BOSTON' THEN st_mem_size(the_geom) ELSE 0 END)) As bossum,
CAST(SUM(CASE WHEN town = 'BOSTON' THEN st_mem_size(the_geom) ELSE 0 END)*1.00 /
		SUM(st_mem_size(the_geom))*100 As numeric(10,2)) As perbos
FROM towns;

totgeomsum	bossum	perbos
----------	------	------
1522 kB		30 kB	1.99


SELECT ST_Mem_Size(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)'));

---
73

--What percentage of our table is taken up by just the geometry
SELECT pg_total_relation_size('public.neighborhoods') As fulltable_size, sum(ST_Mem_Size(the_geom)) As geomsize,
sum(ST_Mem_Size(the_geom))*1.00/pg_total_relation_size('public.neighborhoods')*100 As pergeom
FROM neighborhoods;
fulltable_size geomsize  pergeom
------------------------------------------------
262144         96238	 36.71188354492187500000
	</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Point_Inside_Circle">
	  <refnamediv>
		<refname>ST_Point_Inside_Circle</refname>

		<refpurpose>Is the point geometry insert circle defined by center_x, center_y , radius</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_Point_Inside_Circle</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef>
			<paramdef><type>float </type> <parameter>center_x</parameter></paramdef>
			<paramdef><type>float </type> <parameter>center_y</parameter></paramdef>
			<paramdef><type>float </type> <parameter>radius</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>The syntax for this functions is
			point_inside_circle(&lt;geometry&gt;,&lt;circle_center_x&gt;,&lt;circle_center_y&gt;,&lt;radius&gt;).
			Returns the true if the geometry is a point and is inside the
			circle. Returns false otherwise.</para>
		<para><note>This only works for points as the name suggests</note></para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_Point_Inside_Circle(ST_Point(1,2), 0.5, 2, 3);
 st_point_inside_circle
------------------------
 t
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_DWithin" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_XMax">
	  <refnamediv>
		<refname>ST_XMax</refname>

		<refpurpose>Returns X maxima of a bounding box 2d or 3d or a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_XMax</function></funcdef>
			<paramdef><type>box3d </type> <parameter>aGeomorBox2DorBox3D</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns X maxima of a bounding box 2d or 3d or a geometry.</para>

		<note>
		  <para>Although this function is only defined for box3d, it will work for box2d and geometry because of the auto-casting behavior
			defined for geometries and box2d.  However you can not feed it a geometry or box2d text represenation, since that will not auto-cast.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_XMax('BOX3D(1 2 3, 4 5 6)');
st_xmax
-------
4

SELECT ST_XMax(ST_GeomFromText('LINESTRING(1 3 4, 5 6 7)'));
st_xmax
-------
5

SELECT ST_XMax(CAST('BOX(-3 2, 3 4)' As box2d));
st_xmax
-------
3
--Observe THIS DOES NOT WORK because it will try to autocast the string representation to a BOX3D
SELECT ST_XMax('LINESTRING(1 3, 5 6)');

--ERROR:  BOX3D parser - doesnt start with BOX3D(

SELECT ST_XMax(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)'));
st_xmax
--------
220288.248780547
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_XMin" />, <xref linkend="ST_YMax" />, <xref linkend="ST_YMin" />, <xref linkend="ST_ZMax" />, <xref linkend="ST_ZMin" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_XMin">
	  <refnamediv>
		<refname>ST_XMin</refname>

		<refpurpose>Returns X minima of a bounding box 2d or 3d or a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_XMin</function></funcdef>
			<paramdef><type>box3d </type> <parameter>aGeomorBox2DorBox3D</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns X minima of a bounding box 2d or 3d or a geometry.</para>

		<note>
		  <para>Although this function is only defined for box3d, it will work for box2d and geometry because of the auto-casting behavior
			defined for geometries and box2d.  However you can not feed it a geometry or box2d text represenation, since that will not auto-cast.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_XMin('BOX3D(1 2 3, 4 5 6)');
st_xmin
-------
1

SELECT ST_XMin(ST_GeomFromText('LINESTRING(1 3 4, 5 6 7)'));
st_xmin
-------
1

SELECT ST_XMin(CAST('BOX(-3 2, 3 4)' As box2d));
st_xmin
-------
-3
--Observe THIS DOES NOT WORK because it will try to autocast the string representation to a BOX3D
SELECT ST_XMin('LINESTRING(1 3, 5 6)');

--ERROR:  BOX3D parser - doesnt start with BOX3D(

SELECT ST_XMin(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)'));
st_xmin
--------
220186.995121892
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_XMax" />, <xref linkend="ST_YMax" />, <xref linkend="ST_YMin" />, <xref linkend="ST_ZMax" />, <xref linkend="ST_ZMin" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_YMax">
	  <refnamediv>
		<refname>ST_YMax</refname>

		<refpurpose>Returns Y maxima of a bounding box 2d or 3d or a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_YMax</function></funcdef>
			<paramdef><type>box3d </type> <parameter>aGeomorBox2DorBox3D</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns Y maxima of a bounding box 2d or 3d or a geometry.</para>

		<note>
		  <para>Although this function is only defined for box3d, it will work for box2d and geometry because of the auto-casting behavior
			defined for geometries and box2d.  However you can not feed it a geometry or box2d text represenation, since that will not auto-cast.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_YMax('BOX3D(1 2 3, 4 5 6)');
st_ymax
-------
5

SELECT ST_YMax(ST_GeomFromText('LINESTRING(1 3 4, 5 6 7)'));
st_ymax
-------
6

SELECT ST_YMax(CAST('BOX(-3 2, 3 4)' As box2d));
st_ymax
-------
4
--Observe THIS DOES NOT WORK because it will try to autocast the string representation to a BOX3D
SELECT ST_YMax('LINESTRING(1 3, 5 6)');

--ERROR:  BOX3D parser - doesnt start with BOX3D(

SELECT ST_YMax(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)'));
st_ymax
--------
150506.126829327
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_XMin" />, <xref linkend="ST_XMax" />, <xref linkend="ST_YMin" />, <xref linkend="ST_ZMax" />, <xref linkend="ST_ZMin" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_YMin">
	  <refnamediv>
		<refname>ST_YMin</refname>

		<refpurpose>Returns Y minima of a bounding box 2d or 3d or a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_YMin</function></funcdef>
			<paramdef><type>box3d </type> <parameter>aGeomorBox2DorBox3D</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns Y minima of a bounding box 2d or 3d or a geometry.</para>

		<note>
		  <para>Although this function is only defined for box3d, it will work for box2d and geometry because of the auto-casting behavior
			defined for geometries and box2d.  However you can not feed it a geometry or box2d text represenation, since that will not auto-cast.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_YMin('BOX3D(1 2 3, 4 5 6)');
st_ymin
-------
2

SELECT ST_YMin(ST_GeomFromText('LINESTRING(1 3 4, 5 6 7)'));
st_ymin
-------
3

SELECT ST_YMin(CAST('BOX(-3 2, 3 4)' As box2d));
st_ymin
-------
2
--Observe THIS DOES NOT WORK because it will try to autocast the string representation to a BOX3D
SELECT ST_YMin('LINESTRING(1 3, 5 6)');

--ERROR:  BOX3D parser - doesnt start with BOX3D(

SELECT ST_YMin(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)'));
st_ymin
--------
150406
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_XMin" />, <xref linkend="ST_XMax" />, <xref linkend="ST_YMax" />, <xref linkend="ST_ZMax" />, <xref linkend="ST_ZMin" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_ZMax">
	  <refnamediv>
		<refname>ST_ZMax</refname>

		<refpurpose>Returns Z minima of a bounding box 2d or 3d or a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_ZMax</function></funcdef>
			<paramdef><type>box3d </type> <parameter>aGeomorBox2DorBox3D</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns Z maxima of a bounding box 2d or 3d or a geometry.</para>

		<note>
		  <para>Although this function is only defined for box3d, it will work for box2d and geometry because of the auto-casting behavior
			defined for geometries and box2d.  However you can not feed it a geometry or box2d text represenation, since that will not auto-cast.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_ZMax('BOX3D(1 2 3, 4 5 6)');
st_zmax
-------
6

SELECT ST_ZMax(ST_GeomFromEWKT('LINESTRING(1 3 4, 5 6 7)'));
st_zmax
-------
7

SELECT ST_ZMax('BOX3D(-3 2 1, 3 4 1)' );
st_zmax
-------
1
--Observe THIS DOES NOT WORK because it will try to autocast the string representation to a BOX3D
SELECT ST_ZMax('LINESTRING(1 3 4, 5 6 7)');

--ERROR:  BOX3D parser - doesnt start with BOX3D(

SELECT ST_ZMax(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)'));
st_zmax
--------
3
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_XMin" />, <xref linkend="ST_XMax" />, <xref linkend="ST_YMax" />, <xref linkend="ST_YMin" />, <xref linkend="ST_ZMax" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_ZMin">
	  <refnamediv>
		<refname>ST_ZMin</refname>

		<refpurpose>Returns Z minima of a bounding box 2d or 3d or a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>float <function>ST_ZMin</function></funcdef>
			<paramdef><type>box3d </type> <parameter>aGeomorBox2DorBox3D</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns Z minima of a bounding box 2d or 3d or a geometry.</para>

		<note>
		  <para>Although this function is only defined for box3d, it will work for box2d and geometry because of the auto-casting behavior
			defined for geometries and box2d.  However you can not feed it a geometry or box2d text represenation, since that will not auto-cast.</para>
		</note>

		<!-- Optionally mention 3d support -->
		<para><inlinemediaobject>
			<imageobject>
			  <imagedata fileref="images/check.png" />
			</imageobject>
		  </inlinemediaobject> This function supports 3d and will not drop the z-index.</para>
	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_ZMin('BOX3D(1 2 3, 4 5 6)');
st_zmin
-------
3

SELECT ST_ZMin(ST_GeomFromEWKT('LINESTRING(1 3 4, 5 6 7)'));
st_zmin
-------
4

SELECT ST_ZMin('BOX3D(-3 2 1, 3 4 1)' );
st_zmin
-------
1
--Observe THIS DOES NOT WORK because it will try to autocast the string representation to a BOX3D
SELECT ST_ZMin('LINESTRING(1 3 4, 5 6 7)');

--ERROR:  BOX3D parser - doesnt start with BOX3D(

SELECT ST_ZMin(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)'));
st_zmin
--------
1
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_XMin" />, <xref linkend="ST_XMax" />, <xref linkend="ST_YMax" />, <xref linkend="ST_YMin" />, <xref linkend="ST_ZMax" /></para>
	  </refsection>
	</refentry>

 </sect1>
 <sect1 id="Exceptional_Functions">
	<title>Exceptional Functions</title>
	<para>These functions are rarely used functions that should only be used if your data is corrupted in someway.  They are used for troubleshooting corruption
		and also fixing things that should under normal circumstances, never happen.</para>

	<refentry id="ST_AddBBox">
		  <refnamediv>
			<refname>ST_AddBBox</refname>

			<refpurpose>Add bounding box to the geometry.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_AddBBox</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Add bounding box to the geometry. This would make bounding
			box based queries faster, but will increase the size of the
			geometry.</para>

			<note>
			  <para>Bounding boxes are automatically added to geometries so in general this is not needed
				unless the generated bounding box somehow becomes corrupted or you have an old install that is lacking bounding boxes.  Then you need to drop the old and readd.</para>
			</note>

		<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>UPDATE sometable
 SET the_geom =  ST_AddBBox(the_geom)
 WHERE ST_HasBBox(the_geom) = false;</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_DropBBox" />, <xref linkend="ST_HasBBox" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_DropBBox">
		  <refnamediv>
			<refname>ST_DropBBox</refname>

			<refpurpose>Drop the bounding box cache from the geometry.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_DropBBox</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Drop the bounding box cache from the geometry. This reduces
			geometry size, but makes bounding-box based queries slower.  It is also used to drop a corrupt bounding box.  A tale-tell sign of a corrupt cached bounding box
				is when your ST_Intersects and other relation queries leave out geometries that rightfully should return true.</para>

			<note>
			  <para>Bounding boxes are automatically added to geometries and improve speed of queries so in general this is not needed
				unless the generated bounding box somehow becomes corrupted or you have an old install that is lacking bounding boxes.
				Then you need to drop the old and readd.  This kind of corruption has been observed in 8.3-8.3.6 series whereby cached bboxes were not always recalculated when a geometry changed and upgrading to a newer version without a dump reload will not
				correct already corrupted boxes.  So one can manually correct using below and readd the bbox or do a dump reload.</para>
			</note>

		<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>--This example drops bounding boxes where the cached box is not correct
			--The force to ST_AsBinary before applying ST_box2D forces a recalculation of the box, and ST_Box2D applied to the table geometry always
			-- returns the cached bounding box.
			UPDATE sometable
 SET the_geom =  ST_DropBBox(the_geom)
 WHERE Not (ST_Box2D(ST_AsBinary(the_geom)) = ST_Box2D(the_geom));

	UPDATE sometable
 SET the_geom =  ST_AddBBox(the_geom)
 WHERE Not ST_HasBBOX(the_geom);


 </programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_AddBBox" />, <xref linkend="ST_HasBBox" />, <xref linkend="ST_Box2D" /></para>
		  </refsection>
	</refentry>


	<refentry id="ST_HasBBox">
	  <refnamediv>
		<refname>ST_HasBBox</refname>

		<refpurpose>Returns TRUE if the bbox of this geometry is cached, FALSE otherwise.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>boolean <function>ST_HasBBox</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns TRUE if the bbox of this geometry is cached, FALSE
				otherwise. Use <xref linkend="ST_AddBBox" /> and <xref linkend="ST_DropBBox" /> to control caching.</para>


	<!-- Optionally mention Circular String Support -->
			<para><inlinemediaobject>
				<imageobject>
				  <imagedata fileref="images/check.png" />
				</imageobject>
			  </inlinemediaobject> This method supports Circular Strings and curves </para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT the_geom
FROM sometable WHERE ST_HasBBox(the_geom) = false;</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AddBBox" />, <xref linkend="ST_DropBBox" /></para>
	  </refsection>
	</refentry>

 </sect1>

</chapter>
