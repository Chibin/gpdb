-- --------------------------------------
-- tidycat2
-- --------------------------------------
-- *********************************************************************
-- *********************************************************************
-- This script will produce diffs if you add or change function
-- definitions in src/include/pg_proc.sql. If you want to change the results, 
-- you must make the changes in regress/output/tidycat2.source, not
-- regress/expected, and use gpsourcify.pl to generate a ".out" file.
--
-- From the regress directory invoke the command:
--
--    gpsourcify.pl results/tidycat2.out  > output/tidycat2.source
--
-- *********************************************************************
-- *********************************************************************
-- *********************************************************************
-- *********************************************************************
create schema tidycat2;
set search_path to tidycat2, "$user", public;
-- pg_proc testing
--
-- replace the anyarray, anyelement, and internal return types with
-- FAKE types to avoid problems.
-- Also fix the PGNSP reference.
--
CREATE EXTERNAL WEB TABLE get_pgproc (x text)
execute E'((echo \'set search_path to tidycat2;\'; cat @abs_srcdir@/../../include/catalog/pg_proc.sql | perl -ple \' s/\\s*with\\s*\\(.*\\)\\s*//gmi\' | perl -ple \' s/RETURNS\\s+anyarray\\s+/RETURNS fake_anyarray /gmi \' | perl -ple \' s/RETURNS\\s+anyelement\\s+/RETURNS fake_anyelement /gmi \' | perl -ple \' s/RETURNS\\s+internal\\s+/RETURNS fake_internal /gmi \' | perl -ple \' s/relnamespace\\s+=\\s+PGNSP/relnamespace = 11 /gmi \') | psql $GP_DATABASE >/dev/null)' 
ON MASTER
FORMAT 'text' (delimiter '|');
select * from get_pgproc order by 1;
 x 
---
(0 rows)

drop external table get_pgproc;
-- how many non-tidycat2 procs? (should be ZERO)
select proname from pg_proc pp
where
pp.pronamespace =
(select oid from pg_namespace where nspname = 'pg_catalog')
and
oid < 10000
and
pp.proname not in
(select proname from pg_proc pp2
where pp2.pronamespace =
(select oid from pg_namespace where nspname = 'tidycat2'))
order by proname;
 proname 
---------
(0 rows)

select proname from pg_proc pp
where
pp.pronamespace =
(select oid from pg_namespace where nspname = 'tidycat2')
and
pp.proname not in
(select proname from pg_proc pp2
where pp2.pronamespace =
(select oid from pg_namespace where nspname = 'pg_catalog'))
order by proname;
 proname 
---------
(0 rows)

CREATE OR REPLACE FUNCTION equivalent_result(sql1 text, sql2 text) RETURNS bool AS $$
DECLARE
  sql0 text;
  res bool;
BEGIN
  sql0 := 'WITH base AS ( ' || sql1 || ' )
           SELECT count(*) = (SELECT count(*) FROM base) FROM (SELECT * FROM base INTERSECT ALL ' || sql2 || ')s';

  EXECUTE sql0 INTO res;

  RETURN res;
END;
$$ LANGUAGE plpgsql;
select equivalent_result(
$$
select
  replace(textin(regprocedureout(oid::regprocedure)), 'fake_', '') proc,
  replace(textin(regtypeout(prorettype::regtype)), 'fake_', '') rettype
from pg_proc pp
where
pp.pronamespace =
(select oid from pg_namespace where nspname = 'pg_catalog')
and oid < 10000
$$,
$$
select
  replace(replace(textin(regprocedureout(oid::regprocedure)), 'fake_', ''), 'tidycat2.', ''),
  replace(textin(regtypeout(prorettype::regtype)), 'fake_', '')
from pg_proc pp
where
pp.pronamespace =
(select oid from pg_namespace where nspname = 'tidycat2')
$$);
 equivalent_result 
-------------------
 t
(1 row)

set client_min_messages to error;
drop schema tidycat2 CASCADE;
